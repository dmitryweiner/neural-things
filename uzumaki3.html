<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Uzumaki (from formula)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }

    .ui{
      position:fixed; left:12px; top:12px;
      color:#eee; font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:10px 12px;
      min-width: 320px;
      backdrop-filter: blur(6px);
    }
    .topbar{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
      margin-bottom: 6px;
    }
    .title{ opacity:.9; font-weight:600; }
    .row{ display:flex; align-items:center; gap:10px; margin:8px 0; }
    .row label{ width:78px; opacity:.9; }
    .row input[type="range"]{ flex:1; }
    .val{ width:84px; text-align:right; opacity:.9; font-variant-numeric: tabular-nums; }

    button{
      cursor:pointer; user-select:none;
      padding:6px 10px; border-radius:10px;
      border:1px solid rgba(255,255,255,.15);
      background:rgba(255,255,255,.06);
      color:#eee;
    }

    .hint{ opacity:.7; font-size:12px; margin-top:8px; }
    .controls{ display:block; }
    .ui.collapsed{ min-width: auto; padding:10px 12px; }
    .ui.collapsed .controls{ display:none; }

    .chk {
      display:flex; align-items:center; gap:8px;
      opacity:.9;
    }
    .chk input { transform: translateY(1px); }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui" id="panel">
  <div class="topbar">
    <div class="title">Uzumaki</div>
    <button id="toggle">Hide</button>
  </div>

  <div class="controls" id="controls">
    <div class="row">
      <label for="T">time T</label>
      <input id="T" type="range" min="0.001" max="60" step="0.001" value="8">
      <div class="val" id="TVal"></div>
    </div>

    <div class="row">
      <label for="N">n max</label>
      <input id="N" type="range" min="50" max="2000" step="1" value="900">
      <div class="val" id="NVal"></div>
    </div>

    <div class="row">
      <label for="nStep">n step</label>
      <input id="nStep" type="range" min="1" max="20" step="1" value="3">
      <div class="val" id="nStepVal"></div>
    </div>

    <div class="row">
      <label for="samples">samples</label>
      <input id="samples" type="range" min="200" max="4000" step="1" value="1400">
      <div class="val" id="SVal"></div>
    </div>

    <div class="row">
      <label for="gain">gain</label>
      <input id="gain" type="range" min="5" max="2000" step="1" value="350">
      <div class="val" id="GVal"></div>
    </div>

    <div class="row" style="justify-content:space-between;">
      <button id="fit">Fit</button>
      <button id="play">Play</button>
    </div>

    <div class="row">
      <label></label>
      <div class="chk">
        <input id="sound" type="checkbox" />
        <label for="sound" style="width:auto;">включить звук</label>
      </div>
    </div>

    <div class="hint">
      Play теперь в 10 раз медленнее.<br/>
      Звук: стерео, x → L, y → R (центрируется и нормализуется).
    </div>
  </div>
</div>

<script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  const panel = document.getElementById('panel');
  const toggleBtn = document.getElementById('toggle');

  const TInp = document.getElementById('T');
  const NInp = document.getElementById('N');
  const stepInp = document.getElementById('nStep');
  const SInp = document.getElementById('samples');
  const GInp = document.getElementById('gain');

  const TVal = document.getElementById('TVal');
  const NVal = document.getElementById('NVal');
  const stepVal = document.getElementById('nStepVal');
  const SVal = document.getElementById('SVal');
  const GVal = document.getElementById('GVal');

  const fitBtn = document.getElementById('fit');
  const playBtn = document.getElementById('play');
  const soundChk = document.getElementById('sound');

  let W=0, H=0, dpr=1;
  let playing = false;
  let lastTs = 0;

  // ---------- Audio ----------
  let audioCtx = null;
  let workletNode = null;

  function resize(){
    dpr = Math.max(1, Math.min(2.5, devicePixelRatio || 1));
    W = Math.floor(innerWidth * dpr);
    H = Math.floor(innerHeight * dpr);
    canvas.width = W;
    canvas.height = H;
    draw();
  }
  addEventListener('resize', resize);

  // F(n,t) = (n^(3/2)/(n+1000)) * sin(0.1 n sin(83.3333 t)) / (0.1 n t)
  function F(n, t){
    const a = Math.pow(n, 1.5) / (n + 1000.0);
    const num = Math.sin(0.1 * n * Math.sin(83.3333 * t));
    const den = 0.1 * n * t;
    if (Math.abs(den) < 1e-8) return a * num;
    return a * (num / den);
  }

  function polarPoint(n, t){
    const theta = 0.1 * n * t;
    const r = F(n, t);
    return [r * Math.cos(theta), r * Math.sin(theta)];
  }

  function draw(){
    const T = parseFloat(TInp.value);
    const N = parseInt(NInp.value, 10);
    const nStep = parseInt(stepInp.value, 10);
    const samples = parseInt(SInp.value, 10);
    const gain = parseFloat(GInp.value);

    TVal.textContent = T.toFixed(3);
    NVal.textContent = String(N);
    stepVal.textContent = String(nStep);
    SVal.textContent = String(samples);
    GVal.textContent = String(gain);

    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);

    const cx = W/2, cy = H/2;

    // низкая непрозрачность, иначе всё закрасит
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 0.8 * dpr;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    for(let n=1; n<=N; n+=nStep){
      ctx.beginPath();
      let t = 0;
      let [x, y] = polarPoint(n, t);
      ctx.moveTo(cx + x * gain * dpr, cy + y * gain * dpr);

      for(let i=1; i<samples; i++){
        t = (T * i) / (samples - 1);
        [x, y] = polarPoint(n, t);
        ctx.lineTo(cx + x * gain * dpr, cy + y * gain * dpr);
      }
      ctx.stroke();
    }
  }

  function fit(){
    const T = parseFloat(TInp.value);
    const N = parseInt(NInp.value, 10);
    const nStep = parseInt(stepInp.value, 10);

    let rMax = 0;
    const probeSamples = 600;
    for(let n=1; n<=N; n+=Math.max(nStep, Math.floor(N/300))){
      for(let i=0; i<probeSamples; i++){
        const t = (T * i) / (probeSamples - 1);
        rMax = Math.max(rMax, Math.abs(F(n, t)));
      }
    }
    const target = 0.42 * Math.min(W, H) / dpr;
    const newGain = (rMax > 1e-9) ? (target / rMax) : 350;
    GInp.value = String(Math.max(5, Math.min(2000, newGain)));
    draw();

    // сообщаем аудио текущие параметры (если включено)
    pushAudioParams();
  }

  let raf=0;
  function scheduleDraw(){
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(() => {
      draw();
      pushAudioParams();
    });
  }

  TInp.addEventListener('input', scheduleDraw);
  NInp.addEventListener('input', scheduleDraw);
  stepInp.addEventListener('input', scheduleDraw);
  SInp.addEventListener('input', scheduleDraw);
  GInp.addEventListener('input', scheduleDraw);

  fitBtn.addEventListener('click', fit);

  // Play: теперь в 10 раз медленнее
  playBtn.addEventListener('click', ()=>{
    playing = !playing;
    playBtn.textContent = playing ? 'Pause' : 'Play';
    lastTs = performance.now();
    if (playing) requestAnimationFrame(tick);
  });

  function tick(ts){
    if (!playing) return;
    const dt = (ts - lastTs)/1000;
    lastTs = ts;

    let T = parseFloat(TInp.value);
    const speed = 0.06; // было 0.6
    T += dt * speed;
    if (T > parseFloat(TInp.max)) T = parseFloat(TInp.min);
    TInp.value = String(T);

    draw();
    pushAudioParams();
    requestAnimationFrame(tick);
  }

  // ---------- Panel collapse ----------
  toggleBtn.addEventListener('click', () => {
    const collapsed = panel.classList.toggle('collapsed');
    toggleBtn.textContent = collapsed ? 'Show' : 'Hide';
  });

  // ---------- Sound (Web Audio) ----------
  // Идея: берём "движение точки" для одного n (или пары n) и делаем аудио-осциллятор:
  // сигналL = x(t), сигналR = y(t), но:
  // - вычитаем DC (скользящее среднее) -> "колебания вокруг средней"
  // - нормируем амплитуду, чтобы не клиппило
  // ВАЖНО: браузер потребует user gesture — чекбокс как раз им и является.

  async function enableSound(){
    if (audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const processorCode = `
      class UzumakiProcessor extends AudioWorkletProcessor {
        constructor() {
          super();
          this.phase = 0;
          this.dcL = 0;
          this.dcR = 0;
          this.params = {
            T: 8.0,
            n: 120,
            speed: 30.0,   // насколько быстро t бежит в звуке (секунд t в 1 секунду аудио)
            gain: 0.7
          };
          this.port.onmessage = (e) => {
            Object.assign(this.params, e.data || {});
          };
        }

        F(n, t){
          const a = Math.pow(n, 1.5) / (n + 1000.0);
          const num = Math.sin(0.1 * n * Math.sin(83.3333 * t));
          const den = 0.1 * n * t;
          if (Math.abs(den) < 1e-8) return a * num;
          return a * (num / den);
        }

        polarPoint(n, t){
          const theta = 0.1 * n * t;
          const r = this.F(n, t);
          return [r * Math.cos(theta), r * Math.sin(theta)];
        }

        process(inputs, outputs) {
          const out = outputs[0];
          const L = out[0];
          const R = out[1] || out[0];

          const Tbase = this.params.T;
          const n = this.params.n;
          const speed = this.params.speed;
          const g = this.params.gain;

          // коэффициент DC-фильтра (чем ближе к 1, тем медленнее среднее)
          const dcA = 0.9995;

          for (let i = 0; i < L.length; i++) {
            // t для звука: базовый T (из слайдера) + бегущая составляющая
            const t = Tbase + (this.phase / sampleRate) * speed;

            const [x, y] = this.polarPoint(n, t);

            // DC remove (скользящее среднее)
            this.dcL = dcA * this.dcL + (1 - dcA) * x;
            this.dcR = dcA * this.dcR + (1 - dcA) * y;

            let sL = (x - this.dcL) * g;
            let sR = (y - this.dcR) * g;

            // мягкий лимитер (tanh)
            sL = Math.tanh(sL);
            sR = Math.tanh(sR);

            L[i] = sL;
            R[i] = sR;

            this.phase++;
          }

          return true;
        }
      }

      registerProcessor('uzumaki-processor', UzumakiProcessor);
    `;

    const blob = new Blob([processorCode], { type: 'application/javascript' });
    const url = URL.createObjectURL(blob);
    await audioCtx.audioWorklet.addModule(url);
    URL.revokeObjectURL(url);

    workletNode = new AudioWorkletNode(audioCtx, 'uzumaki-processor', {
      numberOfInputs: 0,
      numberOfOutputs: 1,
      outputChannelCount: [2]
    });

    // на всякий случай тише:
    const master = audioCtx.createGain();
    master.gain.value = 0.25;
    workletNode.connect(master).connect(audioCtx.destination);

    pushAudioParams();
    await audioCtx.resume();
  }

  async function disableSound(){
    if (!audioCtx) return;
    try { workletNode?.disconnect(); } catch {}
    try { await audioCtx.close(); } catch {}
    workletNode = null;
    audioCtx = null;
  }

  function pushAudioParams(){
    if (!workletNode) return;
    // берём “репрезентативный n”: примерно середина диапазона
    const N = parseInt(NInp.value, 10);
    const nStep = parseInt(stepInp.value, 10);
    const n = Math.max(1, Math.floor((N / 2) / nStep) * nStep);

    workletNode.port.postMessage({
      T: parseFloat(TInp.value),
      n,
      // скорость “t” для звука: можно поиграться (10..80)
      speed: 40.0,
      gain: 0.9
    });
  }

  soundChk.addEventListener('change', async () => {
    if (soundChk.checked) {
      try { await enableSound(); }
      catch (e) {
        console.error(e);
        soundChk.checked = false;
        alert('Не удалось включить звук (возможно, браузер блокирует AudioContext).');
      }
    } else {
      await disableSound();
    }
  });

  // init
  resize();
  fit();
</script>
</body>
</html>
