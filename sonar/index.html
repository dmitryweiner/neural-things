<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ultrasonic Sonogram</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 16px; }
    
    /* Top bar with controls */
    .topbar {
      position: sticky;
      top: 0;
      z-index: 20;
      background: #fff;
      border-bottom: 1px solid #ddd;
      padding: 12px 0;
      margin: -16px -16px 16px -16px;
      padding: 12px 16px;
    }
    .topbar h2 { margin: 0 0 10px; font-size: 18px; font-weight: 700; }
    .topbar-desc { color: #666; font-size: 12px; margin-bottom: 12px; }
    
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .btn-group { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    
    button {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    #toggleBtn {
      background: #27ae60;
      color: #fff;
      border-color: #27ae60;
      box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
    }
    #toggleBtn:hover:not(:disabled) {
      background: #2ecc71;
      border-color: #2ecc71;
    }
    #toggleBtn.running {
      background: #e67e22;
      border-color: #e67e22;
      box-shadow: 0 2px 8px rgba(230, 126, 34, 0.3);
    }
    #toggleBtn.running:hover {
      background: #f39c12;
      border-color: #f39c12;
    }
    
    .collapseBtn {
      background: #f5f5f5;
      border: 1px solid #ddd;
      color: #333;
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
    }
    .collapseBtn:hover { background: #eee; }
    .collapseBtn.active {
      background: #e3f2fd;
      border-color: #2196f3;
      color: #1976d2;
    }
    
    /* Settings panel */
    .settingsPanel {
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px;
      max-width: 700px;
      margin-top: 12px;
      display: none;
      background: #fafafa;
    }
    .settingsPanel.open { display: block; }
    
    /* Slider controls */
    .ctrl {
      display: grid;
      grid-template-columns: 140px 1fr 60px;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }
    .ctrl.with-adj {
      grid-template-columns: 140px auto 1fr auto 60px;
      gap: 6px;
    }
    .ctrl:first-child { margin-top: 0; }
    .ctrl label { font-size: 12px; color: #333; font-weight: 500; }
    input[type="range"] { width: 100%; }
    
    select {
      padding: 8px 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
      min-width: 120px;
    }
    
    .small { font-size: 12px; color: #666; text-align: right; }
    
    .adj-btn {
      width: 28px;
      height: 28px;
      padding: 0;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      color: #333;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      touch-action: manipulation;
      user-select: none;
    }
    .adj-btn:hover { background: #f0f0f0; border-color: #bbb; }
    .adj-btn:active { background: #27ae60; color: #fff; border-color: #27ae60; }
    
    /* System info panel */
    .infoPanel {
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px;
      max-width: 700px;
      margin-top: 12px;
      display: none;
      background: #fafafa;
    }
    .infoPanel.open { display: block; }
    
    .kpi { display: flex; gap: 16px; flex-wrap: wrap; }
    .kpi div { font-size: 12px; color: #333; }
    .kpi b { font-size: 12px; }
    
    .wake-lock-status { 
      display: inline-flex; 
      align-items: center; 
      gap: 4px; 
      font-size: 12px; 
      padding: 2px 8px; 
      border-radius: 6px; 
      background: #f0f0f0;
    }
    .wake-lock-status.active { background: #d4edda; color: #155724; }
    .wake-lock-status.inactive { background: #f8d7da; color: #721c24; }
    .wake-lock-status.unsupported { background: #fff3cd; color: #856404; }
    
    /* Calibration panel */
    .calibrationPanel {
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px;
      max-width: 700px;
      margin-top: 12px;
      display: none;
      background: #fafafa;
    }
    .calibrationPanel.open { display: block; }
    
    .calib-section {
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      padding: 12px;
      margin-bottom: 12px;
      background: #fff;
    }
    .calib-section:last-child { margin-bottom: 0; }
    .calib-section h4 {
      margin: 0 0 10px;
      font-size: 13px;
      font-weight: 600;
      color: #333;
    }
    .calib-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
      margin-top: 8px;
    }
    .calib-row:first-of-type { margin-top: 0; }
    
    .calib-btn {
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
      font-size: 12px;
      font-weight: 500;
    }
    .calib-btn:hover { background: #f5f5f5; border-color: #bbb; }
    .calib-btn:disabled { opacity: 0.5; cursor: not-allowed; }
    .calib-btn.primary {
      background: #2196f3;
      color: #fff;
      border-color: #2196f3;
    }
    .calib-btn.primary:hover:not(:disabled) { background: #1e88e5; }
    .calib-btn.running {
      background: #ff9800;
      color: #fff;
      border-color: #ff9800;
    }
    
    .calib-info {
      font-size: 11px;
      color: #666;
      padding: 4px 8px;
      background: #f5f5f5;
      border-radius: 4px;
    }
    .calib-info.highlight {
      background: #e8f5e9;
      color: #2e7d32;
      font-weight: 500;
    }
    
    #freqResponseChart {
      width: 100%;
      max-width: 400px;
      height: 120px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #1a1a1f;
      margin-top: 8px;
    }
    
    .calib-progress {
      font-size: 11px;
      color: #666;
      margin-top: 6px;
    }
    
    /* Info chart */
    .infoChartSection { margin-top: 4px; }
    .infoChartLabel { font-size: 11px; color: #666; margin-bottom: 6px; }
    #infoChart {
      width: 100%;
      max-width: 400px;
      height: 100px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #1a1a1f;
    }
    
    /* Canvas area */
    .canvas-section { max-width: 600px; margin-top: 16px; }
    .canvas-section h3 { margin: 0 0 10px; font-size: 14px; }
    
    .canvas-container {
      position: relative;
      display: inline-block;
    }
    
    .canvas-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(4px);
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid rgba(0, 0, 0, 0.15);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }
    .canvas-btn:hover {
      background: rgba(255, 255, 255, 0.95);
      border-color: rgba(0, 0, 0, 0.25);
    }
    .canvas-btn:active {
      background: rgba(230, 230, 230, 0.95);
    }
    
    canvas { 
      width: 100%; 
      max-width: 520px; 
      height: auto; 
      border: 1px solid #ddd; 
      border-radius: 12px;
      aspect-ratio: 1;
    }
    
    .muted { color: #666; font-size: 12px; }
    .warn { color: #8a3b00; font-size: 12px; margin-top: 10px; }
    code { background: #f6f6f6; padding: 1px 6px; border-radius: 6px; }
    
    .sep { height: 1px; background: #eee; margin: 12px 0; }
    
    @media (max-width: 600px) {
      .ctrl { grid-template-columns: 100px 1fr 50px; }
      .ctrl.with-adj { grid-template-columns: 100px auto 1fr auto 50px; }
    }
  </style>
</head>
<body>

<section class="topbar">
  <h2>Ultrasonic Sonogram</h2>

  <div class="row">
    <div class="btn-group">
      <button id="toggleBtn">‚ñ∂ Start</button>
      <button id="btnPng">Export PNG</button>
    </div>

    <div class="btn-group">
      <button id="settingsBtn" class="collapseBtn" type="button">‚öôÔ∏è Settings</button>
      <button id="infoBtn" class="collapseBtn" type="button">üìä Info</button>
      <button id="calibrationBtn" class="collapseBtn" type="button">üîß Calibration</button>
    </div>
  </div>

  <div id="settingsPanel" class="settingsPanel">
    <div class="ctrl with-adj">
      <label for="freq">Frequency (Hz)</label>
      <button class="adj-btn" data-slider="freq" data-dir="-1">‚àí</button>
      <input id="freq" type="range" min="16000" max="20000" step="10" value="19000">
      <button class="adj-btn" data-slider="freq" data-dir="1">+</button>
      <div class="small" id="freqVal">19000</div>
    </div>

    <div class="ctrl with-adj">
      <label for="burstMs">Burst duration (ms)</label>
      <button class="adj-btn" data-slider="burstMs" data-dir="-1">‚àí</button>
      <input id="burstMs" type="range" min="1" max="40" step="1" value="6">
      <button class="adj-btn" data-slider="burstMs" data-dir="1">+</button>
      <div class="small" id="burstMsVal">6</div>
    </div>

    <div class="ctrl with-adj">
      <label for="listenMs">Listen after (ms)</label>
      <button class="adj-btn" data-slider="listenMs" data-dir="-1">‚àí</button>
      <input id="listenMs" type="range" min="5" max="250" step="1" value="50">
      <button class="adj-btn" data-slider="listenMs" data-dir="1">+</button>
      <div class="small" id="listenMsVal">50</div>
    </div>

    <div class="ctrl">
      <label for="channel">Output channel</label>
      <select id="channel">
        <option value="L">Left</option>
        <option value="R">Right</option>
      </select>
      <div></div>
    </div>

    <div class="ctrl with-adj">
      <label for="amp">Amplitude (0..1)</label>
      <button class="adj-btn" data-slider="amp" data-dir="-1">‚àí</button>
      <input id="amp" type="range" min="0.01" max="1" step="0.01" value="0.18">
      <button class="adj-btn" data-slider="amp" data-dir="1">+</button>
      <div class="small" id="ampVal">0.18</div>
    </div>

    <div class="ctrl with-adj">
      <label for="frame">Frame size (samples)</label>
      <button class="adj-btn" data-slider="frame" data-dir="-1">‚àí</button>
      <input id="frame" type="range" min="128" max="4096" step="128" value="512">
      <button class="adj-btn" data-slider="frame" data-dir="1">+</button>
      <div class="small" id="frameVal">512</div>
    </div>

    <div class="ctrl with-adj">
      <label for="hop">Hop (samples)</label>
      <button class="adj-btn" data-slider="hop" data-dir="-1">‚àí</button>
      <input id="hop" type="range" min="32" max="2048" step="32" value="128">
      <button class="adj-btn" data-slider="hop" data-dir="1">+</button>
      <div class="small" id="hopVal">128</div>
    </div>

    <p class="warn">
      ‚ö†Ô∏è 19‚Äì20 kHz is often filtered by speakers/microphones and "enhancements" (AEC/NS/AGC) on many devices. For testing, a PC + external audio interface often works better.
      Don't crank up the volume: "can't hear it" ‚â† "safe".
    </p>
  </div>

  <div id="infoPanel" class="infoPanel">
    <div class="muted" id="status">Status: idle</div>
    <div class="sep"></div>
    <div class="kpi">
      <div><b>sampleRate:</b> <span id="sr">‚Äî</span></div>
      <div><b>heading:</b> <span id="heading">‚Äî</span></div>
      <div><b>angle bucket:</b> <span id="bucket">‚Äî</span></div>
      <div><b>notes:</b> <span id="notes">‚Äî</span></div>
    </div>
    <div class="sep"></div>
    <span id="wakeLockStatus" class="wake-lock-status unsupported">Wake Lock: checking...</span>
    <div class="sep"></div>
    <div class="infoChartSection">
      <div class="infoChartLabel">Intensity vs Time (current angle)</div>
      <canvas id="infoChart" width="400" height="100"></canvas>
    </div>
  </div>

  <div id="calibrationPanel" class="calibrationPanel">
    <!-- 1. Frequency Response Test -->
    <div class="calib-section">
      <h4>üìà Frequency Response Test</h4>
      <p class="muted" style="margin: 0 0 8px; font-size: 11px;">
        Test which frequencies work best on your device. Sweeps 15‚Äì20 kHz and measures mic response.
      </p>
      <div class="calib-row">
        <button id="runFreqTest" class="calib-btn primary">‚ñ∂ Run Frequency Test</button>
        <span id="freqTestStatus" class="calib-info">Ready</span>
      </div>
      <div class="calib-progress" id="freqTestProgress"></div>
      <canvas id="freqResponseChart" width="400" height="120"></canvas>
      <div class="calib-row" style="margin-top: 8px;">
        <span class="calib-info highlight" id="freqRecommendation">Best frequency: ‚Äî</span>
        <button id="applyBestFreq" class="calib-btn" disabled>Apply to Settings</button>
      </div>
    </div>

    <!-- 2. Compass Zero Calibration -->
    <div class="calib-section">
      <h4>üß≠ Compass Zero</h4>
      <p class="muted" style="margin: 0 0 8px; font-size: 11px;">
        Set current direction as 0¬∞ reference. All angles will be relative to this point.
      </p>
      <div class="calib-row">
        <button id="setZero" class="calib-btn primary">Set 0¬∞</button>
        <button id="resetZero" class="calib-btn">Reset to Magnetic North</button>
        <span id="compassOffset" class="calib-info">Offset: 0¬∞</span>
      </div>
      <div class="calib-row">
        <span class="muted" style="font-size: 11px;">Current raw heading: <span id="rawHeading">‚Äî</span></span>
      </div>
    </div>

    <!-- 3. Range Calibration -->
    <div class="calib-section">
      <h4>üìè Range Calibration</h4>
      <p class="muted" style="margin: 0 0 8px; font-size: 11px;">
        Configure speed of sound for distance calculations (varies with temperature).
      </p>
      <div class="ctrl with-adj" style="max-width: 400px;">
        <label for="speedOfSound">Speed of sound (m/s)</label>
        <button class="adj-btn" data-slider="speedOfSound" data-dir="-1">‚àí</button>
        <input id="speedOfSound" type="range" min="300" max="360" step="1" value="343">
        <button class="adj-btn" data-slider="speedOfSound" data-dir="1">+</button>
        <div class="small" id="speedOfSoundVal">343</div>
      </div>
      <div class="calib-row" style="margin-top: 10px;">
        <span class="calib-info" id="maxRangeInfo">Max range: ‚Äî m</span>
        <label style="font-size: 11px; display: flex; align-items: center; gap: 4px;">
          <input type="checkbox" id="showRangeLabels"> Show distance labels on sonogram
        </label>
      </div>
    </div>

    <!-- 4. Sensitivity Calibration -->
    <div class="calib-section">
      <h4>üéöÔ∏è Sensitivity</h4>
      <p class="muted" style="margin: 0 0 8px; font-size: 11px;">
        Adjust visualization normalization and thresholds.
      </p>
      <div class="ctrl" style="max-width: 400px;">
        <label for="normMode">Normalization</label>
        <select id="normMode">
          <option value="per-burst">Per-burst (dynamic)</option>
          <option value="global">Global (stable)</option>
        </select>
        <div></div>
      </div>
      <div class="ctrl with-adj" style="max-width: 400px; margin-top: 10px;">
        <label for="noiseFloor">Noise floor</label>
        <button class="adj-btn" data-slider="noiseFloor" data-dir="-1">‚àí</button>
        <input id="noiseFloor" type="range" min="0" max="0.5" step="0.01" value="0">
        <button class="adj-btn" data-slider="noiseFloor" data-dir="1">+</button>
        <div class="small" id="noiseFloorVal">0.00</div>
      </div>
      <div class="ctrl with-adj" style="max-width: 400px; margin-top: 10px;">
        <label for="gamma">Gamma (contrast)</label>
        <button class="adj-btn" data-slider="gamma" data-dir="-1">‚àí</button>
        <input id="gamma" type="range" min="0.2" max="3" step="0.1" value="0.5">
        <button class="adj-btn" data-slider="gamma" data-dir="1">+</button>
        <div class="small" id="gammaVal">0.5</div>
      </div>
    </div>
  </div>
</section>

<section class="canvas-section">
  <h3>Polar Sonogram</h3>
  <div class="canvas-container">
    <canvas id="canvas" width="520" height="520"></canvas>
    <button id="btnClear" class="canvas-btn">Clear</button>
  </div>
  <p class="muted">
    Polar view: angle = heading (0¬∞ at top, clockwise), radius = time-of-flight (center = close, edge = far). 
    Brighter = more energy. Green line = current device heading.
  </p>
</section>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const srEl = $("sr");
  const headingEl = $("heading");
  const bucketEl = $("bucket");
  const notesEl = $("notes");
  const wakeLockStatusEl = $("wakeLockStatus");

  const canvas = $("canvas");
  const g = canvas.getContext("2d", { alpha: false });

  const infoChart = $("infoChart");
  const chartCtx = infoChart.getContext("2d", { alpha: false });

  function setStatus(s) { statusEl.textContent = "Status: " + s; }
  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

  // --- Slider value formatting
  function fmt(v, decimals = 0) {
    v = Number(v);
    if (decimals === 0) return String(Math.round(v));
    return v.toFixed(decimals);
  }

  // --- +/- Adjustment buttons (with hold-to-repeat)
  let adjRepeatInterval = null;
  const ADJ_REPEAT_DELAY = 150;

  function adjustSlider(btn) {
    const sliderId = btn.dataset.slider;
    const dir = Number(btn.dataset.dir);
    const slider = document.getElementById(sliderId);
    if (!slider) return;
    
    const step = Number(slider.step) || 1;
    const min = Number(slider.min);
    const max = Number(slider.max);
    let newVal = Number(slider.value) + dir * step;
    newVal = Math.max(min, Math.min(max, newVal));
    
    slider.value = newVal;
    slider.dispatchEvent(new Event('input', { bubbles: true }));
  }

  function stopAdjRepeat() {
    if (adjRepeatInterval) {
      clearInterval(adjRepeatInterval);
      adjRepeatInterval = null;
    }
  }

  function setupAdjustmentButtons(container) {
    container.addEventListener('pointerdown', (e) => {
      const btn = e.target.closest('.adj-btn');
      if (!btn) return;
      
      e.preventDefault();
      stopAdjRepeat();
      
      adjustSlider(btn);
      adjRepeatInterval = setInterval(() => adjustSlider(btn), ADJ_REPEAT_DELAY);
    });

    container.addEventListener('pointerup', stopAdjRepeat);
    container.addEventListener('pointerleave', stopAdjRepeat);
    container.addEventListener('pointercancel', stopAdjRepeat);
  }

  document.addEventListener('pointerup', stopAdjRepeat);

  // --- Slider value display updates
  const sliderConfigs = {
    freq: { decimals: 0 },
    burstMs: { decimals: 0 },
    listenMs: { decimals: 0 },
    amp: { decimals: 2 },
    frame: { decimals: 0 },
    hop: { decimals: 0 },
    // Calibration sliders
    speedOfSound: { decimals: 0 },
    noiseFloor: { decimals: 2 },
    gamma: { decimals: 1 }
  };

  for (const [id, cfg] of Object.entries(sliderConfigs)) {
    const slider = $(id);
    const valEl = $(id + 'Val');
    if (slider && valEl) {
      slider.addEventListener('input', () => {
        valEl.textContent = fmt(slider.value, cfg.decimals);
      });
    }
  }

  // --- Settings panel
  setupAdjustmentButtons($("settingsPanel"));

  // --- Panel toggles
  const settingsPanel = $("settingsPanel");
  const infoPanel = $("infoPanel");
  const settingsBtn = $("settingsBtn");
  const infoBtn = $("infoBtn");

  settingsBtn.addEventListener('click', () => {
    const open = !settingsPanel.classList.contains('open');
    settingsPanel.classList.toggle('open', open);
    settingsBtn.classList.toggle('active', open);
  });

  infoBtn.addEventListener('click', () => {
    const open = !infoPanel.classList.contains('open');
    infoPanel.classList.toggle('open', open);
    infoBtn.classList.toggle('active', open);
  });

  // Calibration panel toggle
  const calibrationPanel = $("calibrationPanel");
  const calibrationBtn = $("calibrationBtn");

  calibrationBtn.addEventListener('click', () => {
    const open = !calibrationPanel.classList.contains('open');
    calibrationPanel.classList.toggle('open', open);
    calibrationBtn.classList.toggle('active', open);
  });

  // Setup adjustment buttons for calibration panel
  setupAdjustmentButtons($("calibrationPanel"));

  // --- Polar data storage
  const ANGLE_BUCKETS = 360;
  const RADIUS_BINS = 256;
  let polarData = null;

  function resetPolarData() {
    polarData = new Array(ANGLE_BUCKETS);
    for (let a = 0; a < ANGLE_BUCKETS; a++) {
      polarData[a] = new Float32Array(RADIUS_BINS);
    }
  }

  // --- Wake Lock API
  let wakeLock = null;

  function updateWakeLockStatus(status) {
    wakeLockStatusEl.className = 'wake-lock-status ' + status;
    switch (status) {
      case 'active':
        wakeLockStatusEl.textContent = 'üîí Wake Lock: active';
        break;
      case 'inactive':
        wakeLockStatusEl.textContent = 'üîì Wake Lock: inactive';
        break;
      case 'unsupported':
        wakeLockStatusEl.textContent = '‚ö†Ô∏è Wake Lock: unsupported';
        break;
      default:
        wakeLockStatusEl.textContent = 'Wake Lock: ' + status;
    }
  }

  async function enableWakeLock() {
    if (!('wakeLock' in navigator)) {
      updateWakeLockStatus('unsupported');
      return;
    }
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      updateWakeLockStatus('active');
      
      wakeLock.addEventListener('release', () => {
        updateWakeLockStatus('inactive');
        wakeLock = null;
      });
    } catch (e) {
      console.warn('Wake Lock failed:', e);
      updateWakeLockStatus('inactive');
    }
  }

  async function releaseWakeLock() {
    if (wakeLock) {
      try {
        await wakeLock.release();
      } catch (e) {
        console.warn('Wake Lock release failed:', e);
      }
      wakeLock = null;
      updateWakeLockStatus('inactive');
    }
  }

  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible' && running && !wakeLock) {
      await enableWakeLock();
    }
  });

  // --- Polar rendering
  function drawPolarSonogram(currentHeadingDeg) {
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const maxR = Math.min(cx, cy) - 2;

    const imgData = g.createImageData(w, h);
    const data = imgData.data;

    for (let py = 0; py < h; py++) {
      for (let px = 0; px < w; px++) {
        const dx = px - cx;
        const dy = py - cy;
        const r = Math.sqrt(dx * dx + dy * dy);
        
        const i = (py * w + px) * 4;
        
        if (r > maxR) {
          data[i] = 20;
          data[i + 1] = 20;
          data[i + 2] = 25;
          data[i + 3] = 255;
          continue;
        }

        let angleDeg = Math.atan2(dx, -dy) * 180 / Math.PI;
        if (angleDeg < 0) angleDeg += 360;
        
        const radiusBin = Math.floor((r / maxR) * (RADIUS_BINS - 1));
        const angleBucket = Math.floor(angleDeg) % ANGLE_BUCKETS;
        
        const v = polarData[angleBucket][radiusBin];
        const c = Math.floor(clamp(v, 0, 1) * 255);
        
        data[i] = c;
        data[i + 1] = c;
        data[i + 2] = c;
        data[i + 3] = 255;
      }
    }

    g.putImageData(imgData, 0, 0);

    g.strokeStyle = 'rgba(80, 80, 90, 0.5)';
    g.lineWidth = 1;
    
    // Calculate max range in meters for labels
    const listenMs = scanParams.listenMs;
    const speed = calibrationState.speedOfSound;
    const maxRangeM = (listenMs / 1000) * speed / 2;
    
    for (const frac of [0.25, 0.5, 0.75]) {
      g.beginPath();
      g.arc(cx, cy, maxR * frac, 0, Math.PI * 2);
      g.stroke();
      
      // Draw range labels if enabled
      if (calibrationState.showRangeLabels) {
        const rangeM = maxRangeM * frac;
        g.fillStyle = 'rgba(150, 150, 160, 0.9)';
        g.font = '10px system-ui';
        g.textAlign = 'left';
        g.textBaseline = 'bottom';
        g.fillText(rangeM.toFixed(2) + 'm', cx + 4, cy - maxR * frac - 2);
      }
    }
    
    // Draw edge label (max range)
    if (calibrationState.showRangeLabels) {
      g.fillStyle = 'rgba(150, 150, 160, 0.9)';
      g.font = '10px system-ui';
      g.textAlign = 'left';
      g.textBaseline = 'bottom';
      g.fillText(maxRangeM.toFixed(2) + 'm', cx + 4, cy - maxR - 2);
    }

    g.beginPath();
    g.moveTo(cx, cy - maxR);
    g.lineTo(cx, cy + maxR);
    g.moveTo(cx - maxR, cy);
    g.lineTo(cx + maxR, cy);
    g.stroke();

    if (typeof currentHeadingDeg === 'number') {
      const rad = (currentHeadingDeg * Math.PI) / 180;
      const lineX = cx + Math.sin(rad) * maxR;
      const lineY = cy - Math.cos(rad) * maxR;

      g.strokeStyle = '#00ff00';
      g.lineWidth = 2;
      g.beginPath();
      g.moveTo(cx, cy);
      g.lineTo(lineX, lineY);
      g.stroke();

      g.fillStyle = '#00ff00';
      g.beginPath();
      g.arc(lineX, lineY, 4, 0, Math.PI * 2);
      g.fill();

      g.fillStyle = '#00ff00';
      g.font = 'bold 12px system-ui';
      const labelX = cx + Math.sin(rad) * (maxR + 15);
      const labelY = cy - Math.cos(rad) * (maxR + 15);
      g.textAlign = 'center';
      g.textBaseline = 'middle';
      g.fillText(currentHeadingDeg.toFixed(0) + '¬∞', labelX, labelY);
    }

    g.fillStyle = '#666';
    g.beginPath();
    g.arc(cx, cy, 3, 0, Math.PI * 2);
    g.fill();
  }

  function resetImage() {
    resetPolarData();
    drawPolarSonogram(null);
  }

  // --- Info chart drawing
  function drawInfoChart(bins) {
    const w = infoChart.width;
    const h = infoChart.height;
    const padding = { top: 8, right: 8, bottom: 20, left: 32 };
    const plotW = w - padding.left - padding.right;
    const plotH = h - padding.top - padding.bottom;

    // Clear with dark background
    chartCtx.fillStyle = "#1a1a1f";
    chartCtx.fillRect(0, 0, w, h);

    if (!bins || bins.length === 0) return;

    // Draw grid lines
    chartCtx.strokeStyle = "rgba(255, 255, 255, 0.1)";
    chartCtx.lineWidth = 1;
    
    // Horizontal grid (intensity levels)
    for (let i = 0; i <= 4; i++) {
      const y = padding.top + (i / 4) * plotH;
      chartCtx.beginPath();
      chartCtx.moveTo(padding.left, y);
      chartCtx.lineTo(w - padding.right, y);
      chartCtx.stroke();
    }

    // Y-axis labels
    chartCtx.fillStyle = "#666";
    chartCtx.font = "9px system-ui";
    chartCtx.textAlign = "right";
    chartCtx.textBaseline = "middle";
    for (let i = 0; i <= 4; i++) {
      const val = 1 - i / 4;
      const y = padding.top + (i / 4) * plotH;
      chartCtx.fillText(val.toFixed(1), padding.left - 4, y);
    }

    // X-axis label
    chartCtx.fillStyle = "#666";
    chartCtx.font = "9px system-ui";
    chartCtx.textAlign = "center";
    chartCtx.textBaseline = "top";
    chartCtx.fillText("time ‚Üí", w / 2, h - 12);

    // Draw the intensity line
    chartCtx.strokeStyle = "#00ff00";
    chartCtx.lineWidth = 1.5;
    chartCtx.beginPath();

    for (let i = 0; i < bins.length; i++) {
      const x = padding.left + (i / (bins.length - 1)) * plotW;
      const y = padding.top + (1 - bins[i]) * plotH;
      
      if (i === 0) {
        chartCtx.moveTo(x, y);
      } else {
        chartCtx.lineTo(x, y);
      }
    }
    chartCtx.stroke();

    // Draw filled area under the line
    chartCtx.fillStyle = "rgba(0, 255, 0, 0.15)";
    chartCtx.beginPath();
    chartCtx.moveTo(padding.left, padding.top + plotH);
    for (let i = 0; i < bins.length; i++) {
      const x = padding.left + (i / (bins.length - 1)) * plotW;
      const y = padding.top + (1 - bins[i]) * plotH;
      chartCtx.lineTo(x, y);
    }
    chartCtx.lineTo(padding.left + plotW, padding.top + plotH);
    chartCtx.closePath();
    chartCtx.fill();
  }

  function clearInfoChart() {
    const w = infoChart.width;
    const h = infoChart.height;
    chartCtx.fillStyle = "#1a1a1f";
    chartCtx.fillRect(0, 0, w, h);
    
    // Draw "no data" text
    chartCtx.fillStyle = "#444";
    chartCtx.font = "11px system-ui";
    chartCtx.textAlign = "center";
    chartCtx.textBaseline = "middle";
    chartCtx.fillText("No data ‚Äî start scanning", w / 2, h / 2);
  }

  function updatePolarDataAtAngle(angleDeg, bins) {
    const bucket = Math.floor(normalizeDeg(angleDeg)) % ANGLE_BUCKETS;
    
    for (let r = 0; r < RADIUS_BINS; r++) {
      const srcIdx = Math.floor((r / RADIUS_BINS) * bins.length);
      polarData[bucket][r] = bins[srcIdx] || 0;
    }
  }

  // --- Orientation / heading
  let headingDegrees = 0;
  let hasHeading = false;

  function normalizeDeg(d) {
    d = d % 360;
    if (d < 0) d += 360;
    return d;
  }

  async function enableSensors() {
    notesEl.textContent = "";
    try {
      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
        const p = await DeviceOrientationEvent.requestPermission();
        if (p !== "granted") throw new Error("DeviceOrientation permission not granted");
      }
    } catch (e) {
      notesEl.textContent = "DeviceOrientation permission failed: " + (e?.message || e);
    }

    window.addEventListener("deviceorientation", (ev) => {
      let raw = null;
      if (typeof ev.webkitCompassHeading === "number") {
        raw = ev.webkitCompassHeading;
      } else if (ev.absolute === true && typeof ev.alpha === "number") {
        raw = ev.alpha;
      } else if (typeof ev.alpha === "number") {
        raw = ev.alpha;
      }
      
      if (raw !== null) {
        rawHeadingDegrees = normalizeDeg(raw);
        // Apply compass offset
        headingDegrees = normalizeDeg(raw - calibrationState.compassOffset);
        hasHeading = true;
        headingEl.textContent = headingDegrees.toFixed(1) + "¬∞";
        // Update raw heading display in calibration panel
        const rawEl = $("rawHeading");
        if (rawEl) rawEl.textContent = rawHeadingDegrees.toFixed(1) + "¬∞";
      }
    }, { passive: true });

    notesEl.textContent = "Sensors enabled (if supported). Rotate the device to change heading.";
  }

  // --- Audio
  let audioCtx = null;
  let micStream = null;
  let micSource = null;
  let micTap = null;
  let running = false;

  // --- Live scan parameters (synced from UI with debounce)
  let scanParams = {
    freq: 19000,
    burstMs: 6,
    listenMs: 50,
    channel: 'L',
    amp: 0.18,
    frameSize: 512,
    hopSize: 128,
    burst: null  // cached tone buffer, regenerated when freq/burstMs change
  };

  // --- Calibration state
  let calibrationState = {
    // Compass zero
    compassOffset: 0,  // degrees to subtract from raw heading
    
    // Range calibration
    speedOfSound: 343,  // m/s
    showRangeLabels: false,
    
    // Sensitivity
    normMode: 'per-burst',  // 'per-burst' or 'global'
    noiseFloor: 0,
    gamma: 0.5,
    
    // Global normalization state (for 'global' mode)
    globalMinLog: Infinity,
    globalMaxLog: -Infinity,
    
    // Frequency test results
    freqTestResults: null,  // array of {freq, power}
    bestFrequency: null
  };

  // --- Frequency Response Test
  const freqResponseChart = $("freqResponseChart");
  const freqChartCtx = freqResponseChart.getContext("2d", { alpha: false });

  function clearFreqResponseChart() {
    const w = freqResponseChart.width;
    const h = freqResponseChart.height;
    freqChartCtx.fillStyle = "#1a1a1f";
    freqChartCtx.fillRect(0, 0, w, h);
    freqChartCtx.fillStyle = "#444";
    freqChartCtx.font = "11px system-ui";
    freqChartCtx.textAlign = "center";
    freqChartCtx.textBaseline = "middle";
    freqChartCtx.fillText("Run test to see frequency response", w / 2, h / 2);
  }

  function drawFreqResponseChart(results, currentIdx = -1) {
    const w = freqResponseChart.width;
    const h = freqResponseChart.height;
    const padding = { top: 12, right: 12, bottom: 24, left: 40 };
    const plotW = w - padding.left - padding.right;
    const plotH = h - padding.top - padding.bottom;

    freqChartCtx.fillStyle = "#1a1a1f";
    freqChartCtx.fillRect(0, 0, w, h);

    if (!results || results.length === 0) return;

    // Find max power for normalization
    let maxPower = 0;
    for (const r of results) {
      if (r.power > maxPower) maxPower = r.power;
    }
    if (maxPower === 0) maxPower = 1;

    // Find best frequency
    let bestIdx = 0;
    for (let i = 1; i < results.length; i++) {
      if (results[i].power > results[bestIdx].power) bestIdx = i;
    }

    // Draw grid
    freqChartCtx.strokeStyle = "rgba(255, 255, 255, 0.1)";
    freqChartCtx.lineWidth = 1;
    for (let i = 0; i <= 4; i++) {
      const y = padding.top + (i / 4) * plotH;
      freqChartCtx.beginPath();
      freqChartCtx.moveTo(padding.left, y);
      freqChartCtx.lineTo(w - padding.right, y);
      freqChartCtx.stroke();
    }

    // Draw bars
    const barWidth = plotW / results.length * 0.8;
    const gap = plotW / results.length * 0.2;

    for (let i = 0; i < results.length; i++) {
      const r = results[i];
      const x = padding.left + (i / results.length) * plotW + gap / 2;
      const barH = (r.power / maxPower) * plotH;
      const y = padding.top + plotH - barH;

      // Color: green for best, yellow for current, blue for others
      if (i === bestIdx) {
        freqChartCtx.fillStyle = "#4caf50";
      } else if (i === currentIdx) {
        freqChartCtx.fillStyle = "#ff9800";
      } else {
        freqChartCtx.fillStyle = "#2196f3";
      }

      freqChartCtx.fillRect(x, y, barWidth, barH);
    }

    // X-axis labels (every 2nd or 3rd)
    freqChartCtx.fillStyle = "#888";
    freqChartCtx.font = "9px system-ui";
    freqChartCtx.textAlign = "center";
    freqChartCtx.textBaseline = "top";
    const labelStep = Math.ceil(results.length / 6);
    for (let i = 0; i < results.length; i += labelStep) {
      const x = padding.left + ((i + 0.5) / results.length) * plotW;
      freqChartCtx.fillText((results[i].freq / 1000).toFixed(1) + "k", x, h - 14);
    }

    // Y-axis label
    freqChartCtx.save();
    freqChartCtx.translate(12, h / 2);
    freqChartCtx.rotate(-Math.PI / 2);
    freqChartCtx.textAlign = "center";
    freqChartCtx.fillText("Power", 0, 0);
    freqChartCtx.restore();
  }

  let freqTestRunning = false;

  async function runFrequencyTest() {
    if (freqTestRunning || running) return;
    
    const runBtn = $("runFreqTest");
    const statusEl = $("freqTestStatus");
    const progressEl = $("freqTestProgress");
    const recommendEl = $("freqRecommendation");
    const applyBtn = $("applyBestFreq");

    try {
      freqTestRunning = true;
      runBtn.textContent = "‚èπ Stop";
      runBtn.classList.add("running");
      statusEl.textContent = "Initializing...";
      applyBtn.disabled = true;

      await ensureAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();

      const sr = audioCtx.sampleRate;
      const testAmp = Number($("amp").value);
      const testChannel = $("channel").value;
      const burstMs = 10;  // fixed burst for testing
      const listenMs = 30;

      // Frequency range: 15kHz to 20kHz, step 500Hz
      const freqStart = 15000;
      const freqEnd = 20000;
      const freqStep = 500;
      const frequencies = [];
      for (let f = freqStart; f <= freqEnd; f += freqStep) {
        frequencies.push(f);
      }

      const results = [];
      calibrationState.freqTestResults = results;

      for (let i = 0; i < frequencies.length; i++) {
        if (!freqTestRunning) break;

        const freq = frequencies[i];
        statusEl.textContent = `Testing ${freq} Hz...`;
        progressEl.textContent = `${i + 1} / ${frequencies.length}`;

        // Generate and play burst
        const burst = makeToneBurst(sr, freq, burstMs / 1000);
        const burstSec = playBurstOneChannel(burst, testAmp, testChannel);

        // Record
        const recSec = burstSec + (listenMs / 1000);
        const recorded = await recordWindow(recSec);

        // Measure power at this frequency
        const skip = Math.floor(burstSec * sr * 0.5);
        const tail = recorded.subarray(skip);
        const power = goertzelPower(tail, sr, freq);

        results.push({ freq, power });
        drawFreqResponseChart(results, i);

        // Small delay between tests
        await new Promise(r => setTimeout(r, 50));
      }

      // Find best frequency
      if (results.length > 0) {
        let bestIdx = 0;
        for (let i = 1; i < results.length; i++) {
          if (results[i].power > results[bestIdx].power) bestIdx = i;
        }
        calibrationState.bestFrequency = results[bestIdx].freq;
        recommendEl.textContent = `Best frequency: ${results[bestIdx].freq} Hz`;
        applyBtn.disabled = false;
      }

      statusEl.textContent = "Complete";
      progressEl.textContent = "";

    } catch (e) {
      console.error("Frequency test error:", e);
      statusEl.textContent = "Error: " + (e?.message || e);
    } finally {
      freqTestRunning = false;
      runBtn.textContent = "‚ñ∂ Run Frequency Test";
      runBtn.classList.remove("running");
    }
  }

  $("runFreqTest").onclick = () => {
    if (freqTestRunning) {
      freqTestRunning = false;
    } else {
      runFrequencyTest();
    }
  };

  $("applyBestFreq").onclick = () => {
    if (calibrationState.bestFrequency) {
      const slider = $("freq");
      slider.value = calibrationState.bestFrequency;
      slider.dispatchEvent(new Event('input', { bubbles: true }));
    }
  };

  // --- Compass Zero Calibration
  let rawHeadingDegrees = 0;

  $("setZero").onclick = () => {
    calibrationState.compassOffset = rawHeadingDegrees;
    updateCompassOffsetDisplay();
    // Clear polar data when changing zero point
    resetImage();
  };

  $("resetZero").onclick = () => {
    calibrationState.compassOffset = 0;
    updateCompassOffsetDisplay();
    resetImage();
  };

  function updateCompassOffsetDisplay() {
    const offset = calibrationState.compassOffset;
    const sign = offset >= 0 ? "+" : "";
    $("compassOffset").textContent = `Offset: ${sign}${offset.toFixed(1)}¬∞`;
  }

  // --- Range Calibration
  function updateRangeInfo() {
    const listenMs = Number($("listenMs").value);
    const speed = calibrationState.speedOfSound;
    // Max range = (listenMs / 1000) * speed / 2  (divide by 2 for round-trip)
    const maxRange = (listenMs / 1000) * speed / 2;
    $("maxRangeInfo").textContent = `Max range: ${maxRange.toFixed(2)} m`;
  }

  $("speedOfSound").addEventListener('input', () => {
    calibrationState.speedOfSound = Number($("speedOfSound").value);
    updateRangeInfo();
  });

  $("listenMs").addEventListener('input', updateRangeInfo);

  $("showRangeLabels").addEventListener('change', (e) => {
    calibrationState.showRangeLabels = e.target.checked;
    // Redraw sonogram with/without labels
    drawPolarSonogram(hasHeading ? headingDegrees : null);
  });

  // --- Sensitivity Calibration
  $("normMode").addEventListener('change', (e) => {
    calibrationState.normMode = e.target.value;
    // Reset global normalization state when switching
    calibrationState.globalMinLog = Infinity;
    calibrationState.globalMaxLog = -Infinity;
  });

  $("noiseFloor").addEventListener('input', () => {
    calibrationState.noiseFloor = Number($("noiseFloor").value);
  });

  $("gamma").addEventListener('input', () => {
    calibrationState.gamma = Number($("gamma").value);
  });

  function syncParamsFromUI() {
    const newFreq = Number($("freq").value);
    const newBurstMs = Number($("burstMs").value);
    const needNewBurst = audioCtx && (
      newFreq !== scanParams.freq || 
      newBurstMs !== scanParams.burstMs
    );

    scanParams.freq = newFreq;
    scanParams.burstMs = newBurstMs;
    scanParams.listenMs = Number($("listenMs").value);
    scanParams.channel = String($("channel").value);
    scanParams.amp = Number($("amp").value);
    scanParams.frameSize = Number($("frame").value);
    scanParams.hopSize = Number($("hop").value);

    if (needNewBurst) {
      const sr = audioCtx.sampleRate;
      scanParams.burst = makeToneBurst(sr, scanParams.freq, scanParams.burstMs / 1000);
    }
  }

  // --- Debounced parameter sync
  const PARAMS_DEBOUNCE_MS = 250;
  let paramsSyncTimer = null;

  function scheduleSyncParams() {
    if (paramsSyncTimer) clearTimeout(paramsSyncTimer);
    paramsSyncTimer = setTimeout(() => {
      syncParamsFromUI();
      paramsSyncTimer = null;
    }, PARAMS_DEBOUNCE_MS);
  }

  // Wire up debounced sync to all settings controls
  function setupLiveParamsSync() {
    const sliderIds = ['freq', 'burstMs', 'listenMs', 'amp', 'frame', 'hop'];
    for (const id of sliderIds) {
      const slider = $(id);
      if (slider) {
        slider.addEventListener('input', scheduleSyncParams);
      }
    }
    // Also listen to channel select changes
    const channelSelect = $("channel");
    if (channelSelect) {
      channelSelect.addEventListener('change', scheduleSyncParams);
    }
  }

  async function ensureAudio() {
    if (audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)({
      latencyHint: "interactive"
    });

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    });

    micSource = audioCtx.createMediaStreamSource(micStream);

    const useWorklet = !!audioCtx.audioWorklet;
    if (useWorklet) {
      const workletCode = `
        class TapProcessor extends AudioWorkletProcessor {
          process(inputs) {
            const input = inputs[0];
            if (input && input[0]) this.port.postMessage(input[0].slice(0));
            return true;
          }
        }
        registerProcessor('tap-processor', TapProcessor);
      `;
      const blob = new Blob([workletCode], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      await audioCtx.audioWorklet.addModule(url);

      micTap = new AudioWorkletNode(audioCtx, "tap-processor");
      micSource.connect(micTap);
    } else {
      const bufSize = 2048;
      micTap = audioCtx.createScriptProcessor(bufSize, 1, 1);
      micSource.connect(micTap);
      micTap.connect(audioCtx.destination);
    }

    srEl.textContent = String(audioCtx.sampleRate);
  }

  function makeToneBurst(sr, freq, durationSec) {
    const N = Math.max(16, Math.floor(durationSec * sr));
    const x = new Float32Array(N);
    for (let n = 0; n < N; n++) {
      const t = n / sr;
      const w = 0.5 * (1 - Math.cos(2 * Math.PI * n / (N - 1)));
      x[n] = Math.sin(2 * Math.PI * freq * t) * w;
    }
    return x;
  }

  function playBurstOneChannel(burst, amp, channel) {
    const sr = audioCtx.sampleRate;
    const N = burst.length;
    const buf = audioCtx.createBuffer(2, N, sr);
    const L = buf.getChannelData(0);
    const R = buf.getChannelData(1);

    if (channel === "L") {
      for (let i = 0; i < N; i++) { L[i] = burst[i] * amp; R[i] = 0; }
    } else {
      for (let i = 0; i < N; i++) { L[i] = 0; R[i] = burst[i] * amp; }
    }

    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(audioCtx.destination);
    src.start();
    return N / sr;
  }

  async function recordWindow(durationSec) {
    const sr = audioCtx.sampleRate;
    const need = Math.floor(durationSec * sr);
    const chunks = [];
    let got = 0;

    return new Promise((resolve) => {
      const onData = (data) => {
        chunks.push(data);
        got += data.length;
        if (got >= need) {
          const out = new Float32Array(got);
          let o = 0;
          for (const c of chunks) { out.set(c, o); o += c.length; }
          cleanup();
          resolve(out.subarray(0, need));
        }
      };

      const cleanup = () => {
        if (micTap instanceof AudioWorkletNode) micTap.port.onmessage = null;
        else micTap.onaudioprocess = null;
      };

      if (micTap instanceof AudioWorkletNode) {
        micTap.port.onmessage = (ev) => onData(ev.data);
      } else {
        micTap.onaudioprocess = (ev) => onData(new Float32Array(ev.inputBuffer.getChannelData(0)));
      }
    });
  }

  function goertzelPower(frame, sr, freq) {
    const N = frame.length;
    const k = Math.round((N * freq) / sr);
    const w = (2 * Math.PI * k) / N;
    const cosw = Math.cos(w);
    const coeff = 2 * cosw;

    let s0 = 0, s1 = 0, s2 = 0;
    for (let n = 0; n < N; n++) {
      s0 = frame[n] + coeff * s1 - s2;
      s2 = s1;
      s1 = s0;
    }
    const power = s1 * s1 + s2 * s2 - coeff * s1 * s2;
    return Math.max(0, power);
  }

  function energyEnvelopeBins(recordedTail, sr, freq, frameSize, hopSize, numBins) {
    const powers = [];
    for (let i = 0; i + frameSize <= recordedTail.length; i += hopSize) {
      const frame = recordedTail.subarray(i, i + frameSize);
      powers.push(goertzelPower(frame, sr, freq));
    }
    
    if (powers.length === 0) return new Float32Array(numBins);

    const logPowers = powers.map(p => Math.log10(p + 1e-10));
    
    let minLog, maxLog;
    
    if (calibrationState.normMode === 'global') {
      // Update global min/max
      for (const lp of logPowers) {
        if (lp < calibrationState.globalMinLog) calibrationState.globalMinLog = lp;
        if (lp > calibrationState.globalMaxLog) calibrationState.globalMaxLog = lp;
      }
      minLog = calibrationState.globalMinLog;
      maxLog = calibrationState.globalMaxLog;
    } else {
      // Per-burst normalization (original behavior)
      minLog = logPowers[0];
      maxLog = logPowers[0];
      for (const lp of logPowers) {
        if (lp < minLog) minLog = lp;
        if (lp > maxLog) maxLog = lp;
      }
    }
    
    const rangeLog = maxLog - minLog || 1;
    const noiseFloor = calibrationState.noiseFloor;
    const gamma = calibrationState.gamma;

    const out = new Float32Array(numBins);

    for (let b = 0; b < numBins; b++) {
      const pStart = (b / numBins) * powers.length;
      const pEnd = ((b + 1) / numBins) * powers.length;
      
      const iStart = Math.floor(pStart);
      const iEnd = Math.max(iStart + 1, Math.ceil(pEnd));
      
      let m = -Infinity;
      for (let i = iStart; i < iEnd && i < logPowers.length; i++) {
        m = Math.max(m, logPowers[i]);
      }
      
      let normalized = clamp((m - minLog) / rangeLog, 0, 1);
      
      // Apply noise floor
      normalized = Math.max(0, normalized - noiseFloor) / (1 - noiseFloor);
      
      // Apply gamma correction
      out[b] = Math.pow(normalized, gamma);
    }
    return out;
  }

  async function scanLoop() {
    const sr = audioCtx.sampleRate;
    
    // Initialize burst buffer if not already created
    if (!scanParams.burst) {
      scanParams.burst = makeToneBurst(sr, scanParams.freq, scanParams.burstMs / 1000);
    }

    running = true;
    setStatus("running");

    while (running) {
      // Read current params from the live-synced object
      const { freq, listenMs, channel, amp, frameSize, hopSize, burst } = scanParams;

      const deg = hasHeading ? headingDegrees : (performance.now() / 50) % 360;
      const bucket = Math.floor(normalizeDeg(deg));
      bucketEl.textContent = bucket + "¬∞ / " + ANGLE_BUCKETS;

      const burstSec = playBurstOneChannel(burst, amp, channel);

      const recSec = burstSec + (listenMs / 1000);
      const recorded = await recordWindow(recSec);

      const skip = Math.floor(burstSec * sr * 0.9);
      const tail = recorded.subarray(skip);

      const bins = energyEnvelopeBins(tail, sr, freq, frameSize, hopSize, RADIUS_BINS);

      updatePolarDataAtAngle(deg, bins);
      drawPolarSonogram(deg);

      // Update info chart only if panel is open
      if (infoPanel.classList.contains('open')) {
        drawInfoChart(bins);
      }

      await new Promise(r => setTimeout(r, 0));
    }

    setStatus("stopped");
  }

  // --- UI wiring
  const toggleBtn = $("toggleBtn");

  async function startScan() {
    try {
      toggleBtn.disabled = true;

      await enableSensors();
      await enableWakeLock();
      await ensureAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();

      toggleBtn.disabled = false;
      toggleBtn.textContent = "‚èπ Stop";
      toggleBtn.classList.add("running");

      scanLoop();
    } catch (e) {
      console.error(e);
      setStatus("error: " + (e?.message || e));
      toggleBtn.disabled = false;
      toggleBtn.textContent = "‚ñ∂ Start";
      toggleBtn.classList.remove("running");
    }
  }

  async function stopScan() {
    running = false;
    await releaseWakeLock();
    toggleBtn.textContent = "‚ñ∂ Start";
    toggleBtn.classList.remove("running");
  }

  toggleBtn.onclick = async () => {
    if (running) {
      await stopScan();
    } else {
      await startScan();
    }
  };

  $("btnClear").onclick = () => resetImage();

  $("btnPng").onclick = () => {
    const a = document.createElement("a");
    a.download = "sonogram_19k_polar.png";
    a.href = canvas.toDataURL("image/png");
    a.click();
  };

  // init
  resetPolarData();
  resetImage();
  clearInfoChart();
  clearFreqResponseChart();
  setStatus("idle");
  headingEl.textContent = "‚Äî";
  bucketEl.textContent = "‚Äî";
  setupLiveParamsSync();
  syncParamsFromUI(); // initialize scanParams from current UI values
  updateRangeInfo();  // initialize range display
  updateCompassOffsetDisplay();  // initialize compass offset display
  
  if ('wakeLock' in navigator) {
    updateWakeLockStatus('inactive');
  } else {
    updateWakeLockStatus('unsupported');
  }
})();
</script>
</body>
</html>
