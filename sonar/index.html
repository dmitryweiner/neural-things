<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ultrasonic Sonogram</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 16px; }
    
    /* Top bar with controls */
    .topbar {
      position: sticky;
      top: 0;
      z-index: 20;
      background: #fff;
      border-bottom: 1px solid #ddd;
      padding: 12px 0;
      margin: -16px -16px 16px -16px;
      padding: 12px 16px;
    }
    .topbar h2 { margin: 0 0 10px; font-size: 18px; font-weight: 700; }
    .topbar-desc { color: #666; font-size: 12px; margin-bottom: 12px; }
    
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .btn-group { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    
    button {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    #toggleBtn {
      background: #27ae60;
      color: #fff;
      border-color: #27ae60;
      box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
    }
    #toggleBtn:hover:not(:disabled) {
      background: #2ecc71;
      border-color: #2ecc71;
    }
    #toggleBtn.running {
      background: #e67e22;
      border-color: #e67e22;
      box-shadow: 0 2px 8px rgba(230, 126, 34, 0.3);
    }
    #toggleBtn.running:hover {
      background: #f39c12;
      border-color: #f39c12;
    }
    
    .collapseBtn {
      background: #f5f5f5;
      border: 1px solid #ddd;
      color: #333;
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
    }
    .collapseBtn:hover { background: #eee; }
    .collapseBtn.active {
      background: #e3f2fd;
      border-color: #2196f3;
      color: #1976d2;
    }
    
    /* Settings panel */
    .settingsPanel {
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px;
      max-width: 700px;
      margin-top: 12px;
      display: none;
      background: #fafafa;
    }
    .settingsPanel.open { display: block; }
    
    /* Slider controls */
    .ctrl {
      display: grid;
      grid-template-columns: 140px 1fr 60px;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }
    .ctrl.with-adj {
      grid-template-columns: 140px auto 1fr auto 60px;
      gap: 6px;
    }
    .ctrl:first-child { margin-top: 0; }
    .ctrl label { font-size: 12px; color: #333; font-weight: 500; }
    input[type="range"] { width: 100%; }
    
    select {
      padding: 8px 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
      min-width: 120px;
    }
    
    .small { font-size: 12px; color: #666; text-align: right; }
    
    .adj-btn {
      width: 28px;
      height: 28px;
      padding: 0;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      color: #333;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      touch-action: manipulation;
      user-select: none;
    }
    .adj-btn:hover { background: #f0f0f0; border-color: #bbb; }
    .adj-btn:active { background: #27ae60; color: #fff; border-color: #27ae60; }
    
    /* System info panel */
    .infoPanel {
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px;
      max-width: 700px;
      margin-top: 12px;
      display: none;
      background: #fafafa;
    }
    .infoPanel.open { display: block; }
    
    .kpi { display: flex; gap: 16px; flex-wrap: wrap; }
    .kpi div { font-size: 12px; color: #333; }
    .kpi b { font-size: 12px; }
    
    .wake-lock-status { 
      display: inline-flex; 
      align-items: center; 
      gap: 4px; 
      font-size: 12px; 
      padding: 2px 8px; 
      border-radius: 6px; 
      background: #f0f0f0;
    }
    .wake-lock-status.active { background: #d4edda; color: #155724; }
    .wake-lock-status.inactive { background: #f8d7da; color: #721c24; }
    .wake-lock-status.unsupported { background: #fff3cd; color: #856404; }
    
    /* Info chart */
    .infoChartSection { margin-top: 4px; }
    .infoChartLabel { font-size: 11px; color: #666; margin-bottom: 6px; }
    #infoChart {
      width: 100%;
      max-width: 400px;
      height: 100px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #1a1a1f;
    }
    
    /* Canvas area */
    .canvas-section { max-width: 600px; margin-top: 16px; }
    .canvas-section h3 { margin: 0 0 10px; font-size: 14px; }
    
    .canvas-container {
      position: relative;
      display: inline-block;
    }
    
    .canvas-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(4px);
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid rgba(0, 0, 0, 0.15);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }
    .canvas-btn:hover {
      background: rgba(255, 255, 255, 0.95);
      border-color: rgba(0, 0, 0, 0.25);
    }
    .canvas-btn:active {
      background: rgba(230, 230, 230, 0.95);
    }
    
    canvas { 
      width: 100%; 
      max-width: 520px; 
      height: auto; 
      border: 1px solid #ddd; 
      border-radius: 12px;
      aspect-ratio: 1;
    }
    
    .muted { color: #666; font-size: 12px; }
    .warn { color: #8a3b00; font-size: 12px; margin-top: 10px; }
    code { background: #f6f6f6; padding: 1px 6px; border-radius: 6px; }
    
    .sep { height: 1px; background: #eee; margin: 12px 0; }
    
    /* Calibration overlay */
    .calibration-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.85);
      z-index: 100;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      color: #fff;
      padding: 20px;
    }
    .calibration-overlay.hidden { display: none; }
    .calibration-overlay h3 {
      margin: 0 0 16px;
      font-size: 20px;
      font-weight: 600;
    }
    .calibration-overlay .calib-status {
      font-size: 14px;
      color: #aaa;
      margin-bottom: 12px;
      text-align: center;
    }
    .calibration-overlay .calib-progress {
      width: 300px;
      max-width: 90%;
      height: 8px;
      background: #333;
      border-radius: 4px;
      overflow: hidden;
      margin-bottom: 16px;
    }
    .calibration-overlay .calib-progress-bar {
      height: 100%;
      background: #27ae60;
      transition: width 0.2s ease;
    }
    .calibration-overlay .calib-params {
      font-size: 12px;
      color: #888;
      font-family: monospace;
      margin-bottom: 20px;
      text-align: center;
    }
    .calibration-overlay .calib-cancel {
      padding: 10px 24px;
      border-radius: 8px;
      border: 1px solid #666;
      background: transparent;
      color: #fff;
      cursor: pointer;
      font-size: 14px;
      font-weight: 500;
    }
    .calibration-overlay .calib-cancel:hover {
      background: #333;
      border-color: #888;
    }
    
    @media (max-width: 600px) {
      .ctrl { grid-template-columns: 100px 1fr 50px; }
      .ctrl.with-adj { grid-template-columns: 100px auto 1fr auto 50px; }
    }
  </style>
</head>
<body>

<section class="topbar">
  <h2>Ultrasonic Sonogram</h2>

  <div class="row">
    <div class="btn-group">
      <button id="toggleBtn">‚ñ∂ Start</button>
      <button id="btnPng">Export PNG</button>
    </div>

    <div class="btn-group">
      <button id="settingsBtn" class="collapseBtn" type="button">‚öôÔ∏è Settings</button>
      <button id="infoBtn" class="collapseBtn" type="button">üìä Info</button>
      <button id="calibrateBtn" class="collapseBtn" type="button" style="display: none;">üìê Calibrate</button>
      <input type="file" id="calibrationFileInput" accept=".json" style="display: none;" />
    </div>
  </div>

  <div id="settingsPanel" class="settingsPanel">
    <div class="ctrl with-adj">
      <label for="freq">Frequency (Hz)</label>
      <button class="adj-btn" data-slider="freq" data-dir="-1">‚àí</button>
      <input id="freq" type="range" min="16000" max="20000" step="10" value="19000">
      <button class="adj-btn" data-slider="freq" data-dir="1">+</button>
      <div class="small" id="freqVal">19000</div>
    </div>

    <div class="ctrl with-adj">
      <label for="burstMs">Burst duration (ms)</label>
      <button class="adj-btn" data-slider="burstMs" data-dir="-1">‚àí</button>
      <input id="burstMs" type="range" min="1" max="40" step="1" value="8">
      <button class="adj-btn" data-slider="burstMs" data-dir="1">+</button>
      <div class="small" id="burstMsVal">8</div>
    </div>

    <div class="ctrl with-adj">
      <label for="listenMs">Listen after (ms)</label>
      <button class="adj-btn" data-slider="listenMs" data-dir="-1">‚àí</button>
      <input id="listenMs" type="range" min="5" max="250" step="1" value="80">
      <button class="adj-btn" data-slider="listenMs" data-dir="1">+</button>
      <div class="small" id="listenMsVal">80</div>
    </div>

    <div class="ctrl">
      <label for="channel">Output channel</label>
      <select id="channel">
        <option value="L">Left</option>
        <option value="R" selected>Right</option>
      </select>
      <div></div>
    </div>

    <div class="ctrl with-adj">
      <label for="amp">Amplitude (0..1)</label>
      <button class="adj-btn" data-slider="amp" data-dir="-1">‚àí</button>
      <input id="amp" type="range" min="0.01" max="1" step="0.01" value="0.18">
      <button class="adj-btn" data-slider="amp" data-dir="1">+</button>
      <div class="small" id="ampVal">0.18</div>
    </div>

    <div class="sep"></div>

    <div class="ctrl with-adj">
      <label for="speedOfSound">Speed of sound (m/s)</label>
      <button class="adj-btn" data-slider="speedOfSound" data-dir="-1">‚àí</button>
      <input id="speedOfSound" type="range" min="300" max="400" step="1" value="343">
      <button class="adj-btn" data-slider="speedOfSound" data-dir="1">+</button>
      <div class="small" id="speedOfSoundVal">343</div>
    </div>

    <div class="ctrl with-adj">
      <label for="minDist">Min distance (m)</label>
      <button class="adj-btn" data-slider="minDist" data-dir="-1">‚àí</button>
      <input id="minDist" type="range" min="0.05" max="1" step="0.05" value="0.15">
      <button class="adj-btn" data-slider="minDist" data-dir="1">+</button>
      <div class="small" id="minDistVal">0.15</div>
    </div>

    <div class="ctrl with-adj">
      <label for="maxDist">Max distance (m)</label>
      <button class="adj-btn" data-slider="maxDist" data-dir="-1">‚àí</button>
      <input id="maxDist" type="range" min="1" max="20" step="0.5" value="10">
      <button class="adj-btn" data-slider="maxDist" data-dir="1">+</button>
      <div class="small" id="maxDistVal">10</div>
    </div>

    <div class="ctrl with-adj">
      <label for="bandwidth">Bandpass width (Hz)</label>
      <button class="adj-btn" data-slider="bandwidth" data-dir="-1">‚àí</button>
      <input id="bandwidth" type="range" min="500" max="5000" step="100" value="2000">
      <button class="adj-btn" data-slider="bandwidth" data-dir="1">+</button>
      <div class="small" id="bandwidthVal">2000</div>
    </div>

    <p class="warn">
      ‚ö†Ô∏è 19‚Äì20 kHz is often filtered by speakers/microphones and "enhancements" (AEC/NS/AGC) on many devices. For testing, a PC + external audio interface often works better.
      Don't crank up the volume: "can't hear it" ‚â† "safe".
    </p>
  </div>

  <div id="infoPanel" class="infoPanel">
    <div class="muted" id="status">Status: idle</div>
    <div class="sep"></div>
    <div class="kpi">
      <div><b>sampleRate:</b> <span id="sr">‚Äî</span></div>
      <div><b>heading:</b> <span id="heading">‚Äî</span></div>
      <div><b>angle bucket:</b> <span id="bucket">‚Äî</span></div>
      <div><b>notes:</b> <span id="notes">‚Äî</span></div>
    </div>
    <div class="sep"></div>
    <span id="wakeLockStatus" class="wake-lock-status unsupported">Wake Lock: checking...</span>
    <div class="sep"></div>
    <div class="infoChartSection">
      <div class="infoChartLabel">Cepstrum Magnitude vs Distance (current angle)</div>
      <canvas id="infoChart" width="400" height="100"></canvas>
    </div>
  </div>
</section>

<section class="canvas-section">
  <h3>Polar Sonogram</h3>
  <div class="canvas-container">
    <canvas id="canvas" width="520" height="520"></canvas>
    <button id="btnClear" class="canvas-btn">Clear</button>
  </div>
  <p class="muted">
    Polar view: current direction always at top (green line), radius = distance (center = min, edge = max). 
    Brighter = stronger echo. Cepstrum analysis detects time-of-flight peaks. Sonogram rotates as you turn.
  </p>
</section>

<!-- Calibration overlay -->
<div id="calibrationOverlay" class="calibration-overlay hidden">
  <h3>üìê Calibration in progress</h3>
  <div class="calib-status" id="calibStatus">Place device 1m from wall, then click Calibrate</div>
  <div class="calib-progress">
    <div class="calib-progress-bar" id="calibProgressBar" style="width: 0%"></div>
  </div>
  <div class="calib-params" id="calibParams">‚Äî</div>
  <button class="calib-cancel" id="calibCancelBtn">Cancel</button>
</div>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const srEl = $("sr");
  const headingEl = $("heading");
  const bucketEl = $("bucket");
  const notesEl = $("notes");
  const wakeLockStatusEl = $("wakeLockStatus");

  const canvas = $("canvas");
  const g = canvas.getContext("2d", { alpha: false });

  const infoChart = $("infoChart");
  const chartCtx = infoChart.getContext("2d", { alpha: false });

  function setStatus(s) { statusEl.textContent = "Status: " + s; }
  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

  // --- FFT/IFFT Implementation (Radix-2 Cooley-Tukey)
  function nextPow2(n) {
    let p = 1;
    while (p < n) p <<= 1;
    return p;
  }

  // In-place radix-2 FFT
  // real and imag are Float64Arrays of length N (must be power of 2)
  function fft(real, imag) {
    const N = real.length;
    if (N <= 1) return;

    // Bit-reversal permutation
    let j = 0;
    for (let i = 0; i < N - 1; i++) {
      if (i < j) {
        let tr = real[i]; real[i] = real[j]; real[j] = tr;
        let ti = imag[i]; imag[i] = imag[j]; imag[j] = ti;
      }
      let k = N >> 1;
      while (k <= j) { j -= k; k >>= 1; }
      j += k;
    }

    // Cooley-Tukey iterative FFT
    for (let len = 2; len <= N; len <<= 1) {
      const halfLen = len >> 1;
      const angle = -2 * Math.PI / len;
      const wReal = Math.cos(angle);
      const wImag = Math.sin(angle);
      
      for (let i = 0; i < N; i += len) {
        let wr = 1, wi = 0;
        for (let k = 0; k < halfLen; k++) {
          const evenIdx = i + k;
          const oddIdx = i + k + halfLen;
          
          const tr = wr * real[oddIdx] - wi * imag[oddIdx];
          const ti = wr * imag[oddIdx] + wi * real[oddIdx];
          
          real[oddIdx] = real[evenIdx] - tr;
          imag[oddIdx] = imag[evenIdx] - ti;
          real[evenIdx] += tr;
          imag[evenIdx] += ti;
          
          const newWr = wr * wReal - wi * wImag;
          wi = wr * wImag + wi * wReal;
          wr = newWr;
        }
      }
    }
  }

  // Inverse FFT via conjugate trick
  function ifft(real, imag) {
    const N = real.length;
    // Conjugate
    for (let i = 0; i < N; i++) imag[i] = -imag[i];
    // Forward FFT
    fft(real, imag);
    // Conjugate and scale
    for (let i = 0; i < N; i++) {
      real[i] /= N;
      imag[i] = -imag[i] / N;
    }
  }

  // Compute magnitude spectrum
  function magnitude(real, imag) {
    const N = real.length;
    const mag = new Float64Array(N);
    for (let i = 0; i < N; i++) {
      mag[i] = Math.sqrt(real[i] * real[i] + imag[i] * imag[i]);
    }
    return mag;
  }

  // --- Real Cepstrum Computation
  // Computes: C = IFFT(log|FFT(signal)|)
  // With bandpass filtering around pingFreq ¬± bandwidthHz
  function computeRealCepstrum(signal, sampleRate, pingFreq, bandwidthHz) {
    // Zero-pad to next power of 2
    const N = nextPow2(signal.length);
    const real = new Float64Array(N);
    const imag = new Float64Array(N);
    
    // Copy signal with Hann window to reduce spectral leakage
    for (let i = 0; i < signal.length; i++) {
      const window = 0.5 * (1 - Math.cos(2 * Math.PI * i / (signal.length - 1)));
      real[i] = signal[i] * window;
    }
    // Rest is zero-padded
    
    // Forward FFT
    fft(real, imag);
    
    // Compute magnitude spectrum
    const mag = magnitude(real, imag);
    
    // Apply bandpass filter in frequency domain
    // Zero out frequencies outside pingFreq ¬± bandwidthHz
    const freqPerBin = sampleRate / N;
    const lowBin = Math.max(0, Math.floor((pingFreq - bandwidthHz) / freqPerBin));
    const highBin = Math.min(N / 2, Math.ceil((pingFreq + bandwidthHz) / freqPerBin));
    
    // Take log of magnitude spectrum (only in bandpass region)
    // Use epsilon to avoid log(0)
    const EPS = 1e-10;
    const logMag = new Float64Array(N);
    
    for (let i = 0; i < N; i++) {
      // Mirror for negative frequencies (N/2 to N-1 mirrors 1 to N/2-1)
      const freqBin = i <= N / 2 ? i : N - i;
      
      if (freqBin >= lowBin && freqBin <= highBin) {
        logMag[i] = Math.log(mag[i] + EPS);
      } else {
        logMag[i] = Math.log(EPS); // Suppress out-of-band
      }
    }
    
    // IFFT of log magnitude to get real cepstrum
    const cepReal = new Float64Array(N);
    const cepImag = new Float64Array(N);
    for (let i = 0; i < N; i++) {
      cepReal[i] = logMag[i];
      cepImag[i] = 0;
    }
    
    ifft(cepReal, cepImag);
    
    // Return real part of cepstrum (quefrency domain)
    // Index = quefrency in samples
    return cepReal;
  }

  // --- Cepstrum to Distance Bins Conversion
  // Converts cepstrum (quefrency in samples) to distance bins
  // minDist and maxDist define the valid range (ignore direct leakage at low quefrency)
  function cepstrumToDistanceBins(cepstrum, sampleRate, speedOfSound, minDist, maxDist, numBins) {
    // Convert distance to quefrency (round-trip time)
    // distance = speedOfSound * quefrencySec / 2
    // quefrencySec = 2 * distance / speedOfSound
    // quefrencySamples = quefrencySec * sampleRate
    
    const minQuefrency = Math.floor((2 * minDist / speedOfSound) * sampleRate);
    const maxQuefrency = Math.min(
      Math.ceil((2 * maxDist / speedOfSound) * sampleRate),
      cepstrum.length / 2  // Only use first half (positive quefrencies)
    );
    
    if (maxQuefrency <= minQuefrency) {
      return new Float32Array(numBins);
    }
    
    const quefrencyRange = maxQuefrency - minQuefrency;
    const out = new Float32Array(numBins);
    
    // Sample cepstrum at evenly spaced distance intervals
    for (let b = 0; b < numBins; b++) {
      // Map bin to quefrency
      const t = b / (numBins - 1);
      const quefrency = Math.round(minQuefrency + t * quefrencyRange);
      
      if (quefrency >= 0 && quefrency < cepstrum.length) {
        // Take absolute value since cepstrum can be negative
        out[b] = Math.abs(cepstrum[quefrency]);
      }
    }
    
    return out;
  }

  // --- Temporal Sliding Mean for Cepstrum Stability
  const CEPSTRUM_HISTORY_SIZE = 5;  // Number of frames to average
  let cepstrumHistory = null;  // Will be initialized with resetCepstrumHistory()
  let cepstrumHistoryIdx = null;  // Circular buffer index per angle

  function resetCepstrumHistory() {
    cepstrumHistory = new Array(ANGLE_BUCKETS);
    cepstrumHistoryIdx = new Uint8Array(ANGLE_BUCKETS);
    for (let a = 0; a < ANGLE_BUCKETS; a++) {
      // Each angle bucket has a circular buffer of cepstrum frames
      cepstrumHistory[a] = new Array(CEPSTRUM_HISTORY_SIZE);
      for (let h = 0; h < CEPSTRUM_HISTORY_SIZE; h++) {
        cepstrumHistory[a][h] = null;  // Will be Float32Array when populated
      }
      cepstrumHistoryIdx[a] = 0;
    }
  }

  // Subtract temporal sliding mean from new cepstrum bins
  // This removes stationary components (consistent leakage patterns)
  function applySlidingMeanSubtraction(angleBucket, newBins) {
    const history = cepstrumHistory[angleBucket];
    const idx = cepstrumHistoryIdx[angleBucket];
    
    // Store new bins in circular buffer
    history[idx] = new Float32Array(newBins);
    cepstrumHistoryIdx[angleBucket] = (idx + 1) % CEPSTRUM_HISTORY_SIZE;
    
    // Count valid history entries
    let validCount = 0;
    for (let h = 0; h < CEPSTRUM_HISTORY_SIZE; h++) {
      if (history[h] !== null) validCount++;
    }
    
    // If we don't have enough history, just normalize and return
    if (validCount < 2) {
      return normalizeBins(newBins);
    }
    
    // Compute sliding mean
    const mean = new Float32Array(newBins.length);
    for (let h = 0; h < CEPSTRUM_HISTORY_SIZE; h++) {
      if (history[h] !== null) {
        for (let i = 0; i < newBins.length; i++) {
          mean[i] += history[h][i];
        }
      }
    }
    for (let i = 0; i < mean.length; i++) {
      mean[i] /= validCount;
    }
    
    // Subtract mean from current bins
    const result = new Float32Array(newBins.length);
    for (let i = 0; i < newBins.length; i++) {
      // Subtract mean, but keep positive values (rectify)
      result[i] = Math.max(0, newBins[i] - mean[i] * 0.8);  // 0.8 factor for partial subtraction
    }
    
    return normalizeBins(result);
  }

  // Normalize bins to 0-1 range with sqrt compression
  function normalizeBins(bins) {
    let maxVal = 0;
    for (let i = 0; i < bins.length; i++) {
      if (bins[i] > maxVal) maxVal = bins[i];
    }
    
    if (maxVal <= 0) return new Float32Array(bins.length);
    
    const out = new Float32Array(bins.length);
    for (let i = 0; i < bins.length; i++) {
      // Normalize and apply sqrt compression for better visualization
      out[i] = Math.sqrt(clamp(bins[i] / maxVal, 0, 1));
    }
    return out;
  }

  // --- Slider value formatting
  function fmt(v, decimals = 0) {
    v = Number(v);
    if (decimals === 0) return String(Math.round(v));
    return v.toFixed(decimals);
  }

  // --- +/- Adjustment buttons (with hold-to-repeat)
  let adjRepeatInterval = null;
  const ADJ_REPEAT_DELAY = 150;

  function adjustSlider(btn) {
    const sliderId = btn.dataset.slider;
    const dir = Number(btn.dataset.dir);
    const slider = document.getElementById(sliderId);
    if (!slider) return;
    
    const step = Number(slider.step) || 1;
    const min = Number(slider.min);
    const max = Number(slider.max);
    let newVal = Number(slider.value) + dir * step;
    newVal = Math.max(min, Math.min(max, newVal));
    
    slider.value = newVal;
    slider.dispatchEvent(new Event('input', { bubbles: true }));
  }

  function stopAdjRepeat() {
    if (adjRepeatInterval) {
      clearInterval(adjRepeatInterval);
      adjRepeatInterval = null;
    }
  }

  function setupAdjustmentButtons(container) {
    container.addEventListener('pointerdown', (e) => {
      const btn = e.target.closest('.adj-btn');
      if (!btn) return;
      
      e.preventDefault();
      stopAdjRepeat();
      
      adjustSlider(btn);
      adjRepeatInterval = setInterval(() => adjustSlider(btn), ADJ_REPEAT_DELAY);
    });

    container.addEventListener('pointerup', stopAdjRepeat);
    container.addEventListener('pointerleave', stopAdjRepeat);
    container.addEventListener('pointercancel', stopAdjRepeat);
  }

  document.addEventListener('pointerup', stopAdjRepeat);

  // --- Slider value display updates
  const sliderConfigs = {
    freq: { decimals: 0 },
    burstMs: { decimals: 0 },
    listenMs: { decimals: 0 },
    amp: { decimals: 2 },
    speedOfSound: { decimals: 0 },
    minDist: { decimals: 2 },
    maxDist: { decimals: 1 },
    bandwidth: { decimals: 0 }
  };

  for (const [id, cfg] of Object.entries(sliderConfigs)) {
    const slider = $(id);
    const valEl = $(id + 'Val');
    if (slider && valEl) {
      slider.addEventListener('input', () => {
        valEl.textContent = fmt(slider.value, cfg.decimals);
      });
    }
  }

  // --- Settings panel
  setupAdjustmentButtons($("settingsPanel"));

  // --- Panel toggles
  const settingsPanel = $("settingsPanel");
  const infoPanel = $("infoPanel");
  const settingsBtn = $("settingsBtn");
  const infoBtn = $("infoBtn");

  settingsBtn.addEventListener('click', () => {
    const open = !settingsPanel.classList.contains('open');
    settingsPanel.classList.toggle('open', open);
    settingsBtn.classList.toggle('active', open);
  });

  infoBtn.addEventListener('click', () => {
    const open = !infoPanel.classList.contains('open');
    infoPanel.classList.toggle('open', open);
    infoBtn.classList.toggle('active', open);
  });

  // --- Polar data storage
  const ANGLE_BUCKETS = 360;
  const RADIUS_BINS = 256;
  let polarData = null;

  function resetPolarData() {
    polarData = new Array(ANGLE_BUCKETS);
    for (let a = 0; a < ANGLE_BUCKETS; a++) {
      polarData[a] = new Float32Array(RADIUS_BINS);
    }
  }

  // --- Wake Lock API
  let wakeLock = null;

  function updateWakeLockStatus(status) {
    wakeLockStatusEl.className = 'wake-lock-status ' + status;
    switch (status) {
      case 'active':
        wakeLockStatusEl.textContent = 'üîí Wake Lock: active';
        break;
      case 'inactive':
        wakeLockStatusEl.textContent = 'üîì Wake Lock: inactive';
        break;
      case 'unsupported':
        wakeLockStatusEl.textContent = '‚ö†Ô∏è Wake Lock: unsupported';
        break;
      default:
        wakeLockStatusEl.textContent = 'Wake Lock: ' + status;
    }
  }

  async function enableWakeLock() {
    if (!('wakeLock' in navigator)) {
      updateWakeLockStatus('unsupported');
      return;
    }
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      updateWakeLockStatus('active');
      
      wakeLock.addEventListener('release', () => {
        updateWakeLockStatus('inactive');
        wakeLock = null;
      });
    } catch (e) {
      console.warn('Wake Lock failed:', e);
      updateWakeLockStatus('inactive');
    }
  }

  async function releaseWakeLock() {
    if (wakeLock) {
      try {
        await wakeLock.release();
      } catch (e) {
        console.warn('Wake Lock release failed:', e);
      }
      wakeLock = null;
      updateWakeLockStatus('inactive');
    }
  }

  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible' && running && !wakeLock) {
      await enableWakeLock();
    }
  });

  // --- Polar rendering
  // The sonogram rotates so that current direction always points up (0¬∞ position).
  // Green line is fixed at top, data rotates beneath it.
  function drawPolarSonogram(currentHeadingDeg) {
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const maxR = Math.min(cx, cy) - 2;

    const imgData = g.createImageData(w, h);
    const data = imgData.data;

    // Rotation offset: we add currentHeadingDeg to screen angle to look up data
    // This makes the current heading appear at the top (0¬∞ screen position)
    const rotationOffset = typeof currentHeadingDeg === 'number' ? currentHeadingDeg : 0;

    for (let py = 0; py < h; py++) {
      for (let px = 0; px < w; px++) {
        const dx = px - cx;
        const dy = py - cy;
        const r = Math.sqrt(dx * dx + dy * dy);
        
        const i = (py * w + px) * 4;
        
        if (r > maxR) {
          data[i] = 20;
          data[i + 1] = 20;
          data[i + 2] = 25;
          data[i + 3] = 255;
          continue;
        }

        // Screen angle (0¬∞ at top, clockwise)
        let screenAngleDeg = Math.atan2(dx, -dy) * 180 / Math.PI;
        if (screenAngleDeg < 0) screenAngleDeg += 360;
        
        // Data angle = screen angle + rotation offset
        // This rotates the data so current heading is at top
        let dataAngleDeg = screenAngleDeg + rotationOffset;
        dataAngleDeg = ((dataAngleDeg % 360) + 360) % 360;
        
        const radiusBin = Math.floor((r / maxR) * (RADIUS_BINS - 1));
        const angleBucket = Math.floor(dataAngleDeg) % ANGLE_BUCKETS;
        
        const v = polarData[angleBucket][radiusBin];
        const c = Math.floor(clamp(v, 0, 1) * 255);
        
        data[i] = c;
        data[i + 1] = c;
        data[i + 2] = c;
        data[i + 3] = 255;
      }
    }

    g.putImageData(imgData, 0, 0);

    g.strokeStyle = 'rgba(80, 80, 90, 0.5)';
    g.lineWidth = 1;
    
    for (const frac of [0.25, 0.5, 0.75]) {
      g.beginPath();
      g.arc(cx, cy, maxR * frac, 0, Math.PI * 2);
      g.stroke();
    }

    g.beginPath();
    g.moveTo(cx, cy - maxR);
    g.lineTo(cx, cy + maxR);
    g.moveTo(cx - maxR, cy);
    g.lineTo(cx + maxR, cy);
    g.stroke();

    // Green direction line: always points up (current direction)
    if (typeof currentHeadingDeg === 'number') {
      g.strokeStyle = '#00ff00';
      g.lineWidth = 2;
      g.beginPath();
      g.moveTo(cx, cy);
      g.lineTo(cx, cy - maxR);  // Always points up
      g.stroke();

      g.fillStyle = '#00ff00';
      g.beginPath();
      g.arc(cx, cy - maxR, 4, 0, Math.PI * 2);  // Dot at top
      g.fill();
    }

    g.fillStyle = '#666';
    g.beginPath();
    g.arc(cx, cy, 3, 0, Math.PI * 2);
    g.fill();
  }

  function resetImage() {
    resetPolarData();
    resetCepstrumHistory();
    drawPolarSonogram(null);
  }

  // --- Info chart drawing
  function drawInfoChart(bins, minDist, maxDist) {
    const w = infoChart.width;
    const h = infoChart.height;
    const padding = { top: 8, right: 8, bottom: 20, left: 32 };
    const plotW = w - padding.left - padding.right;
    const plotH = h - padding.top - padding.bottom;

    // Clear with dark background
    chartCtx.fillStyle = "#1a1a1f";
    chartCtx.fillRect(0, 0, w, h);

    if (!bins || bins.length === 0) return;

    // Draw grid lines
    chartCtx.strokeStyle = "rgba(255, 255, 255, 0.1)";
    chartCtx.lineWidth = 1;
    
    // Horizontal grid (magnitude levels)
    for (let i = 0; i <= 4; i++) {
      const y = padding.top + (i / 4) * plotH;
      chartCtx.beginPath();
      chartCtx.moveTo(padding.left, y);
      chartCtx.lineTo(w - padding.right, y);
      chartCtx.stroke();
    }

    // Vertical grid (distance markers)
    const numDistMarkers = 5;
    for (let i = 0; i <= numDistMarkers; i++) {
      const x = padding.left + (i / numDistMarkers) * plotW;
      chartCtx.beginPath();
      chartCtx.moveTo(x, padding.top);
      chartCtx.lineTo(x, padding.top + plotH);
      chartCtx.stroke();
    }

    // Y-axis labels
    chartCtx.fillStyle = "#666";
    chartCtx.font = "9px system-ui";
    chartCtx.textAlign = "right";
    chartCtx.textBaseline = "middle";
    for (let i = 0; i <= 4; i++) {
      const val = 1 - i / 4;
      const y = padding.top + (i / 4) * plotH;
      chartCtx.fillText(val.toFixed(1), padding.left - 4, y);
    }

    // X-axis labels (distance in meters)
    chartCtx.fillStyle = "#666";
    chartCtx.font = "9px system-ui";
    chartCtx.textAlign = "center";
    chartCtx.textBaseline = "top";
    
    const distMin = minDist || 0.15;
    const distMax = maxDist || 10;
    
    for (let i = 0; i <= numDistMarkers; i++) {
      const dist = distMin + (i / numDistMarkers) * (distMax - distMin);
      const x = padding.left + (i / numDistMarkers) * plotW;
      chartCtx.fillText(dist.toFixed(1) + "m", x, h - 12);
    }

    // Draw the cepstrum magnitude line
    chartCtx.strokeStyle = "#00ff00";
    chartCtx.lineWidth = 1.5;
    chartCtx.beginPath();

    for (let i = 0; i < bins.length; i++) {
      const x = padding.left + (i / (bins.length - 1)) * plotW;
      const y = padding.top + (1 - bins[i]) * plotH;
      
      if (i === 0) {
        chartCtx.moveTo(x, y);
      } else {
        chartCtx.lineTo(x, y);
      }
    }
    chartCtx.stroke();

    // Draw filled area under the line
    chartCtx.fillStyle = "rgba(0, 255, 0, 0.15)";
    chartCtx.beginPath();
    chartCtx.moveTo(padding.left, padding.top + plotH);
    for (let i = 0; i < bins.length; i++) {
      const x = padding.left + (i / (bins.length - 1)) * plotW;
      const y = padding.top + (1 - bins[i]) * plotH;
      chartCtx.lineTo(x, y);
    }
    chartCtx.lineTo(padding.left + plotW, padding.top + plotH);
    chartCtx.closePath();
    chartCtx.fill();

    // Find and mark peaks (echo candidates)
    const peakThreshold = 0.5;
    chartCtx.fillStyle = "#ff6600";
    for (let i = 1; i < bins.length - 1; i++) {
      if (bins[i] > peakThreshold && bins[i] > bins[i-1] && bins[i] > bins[i+1]) {
        const x = padding.left + (i / (bins.length - 1)) * plotW;
        const y = padding.top + (1 - bins[i]) * plotH;
        chartCtx.beginPath();
        chartCtx.arc(x, y, 3, 0, Math.PI * 2);
        chartCtx.fill();
      }
    }
  }

  function clearInfoChart() {
    const w = infoChart.width;
    const h = infoChart.height;
    chartCtx.fillStyle = "#1a1a1f";
    chartCtx.fillRect(0, 0, w, h);
    
    // Draw "no data" text
    chartCtx.fillStyle = "#444";
    chartCtx.font = "11px system-ui";
    chartCtx.textAlign = "center";
    chartCtx.textBaseline = "middle";
    chartCtx.fillText("No data ‚Äî start scanning", w / 2, h / 2);
  }

  function updatePolarDataAtAngle(angleDeg, bins) {
    const bucket = Math.floor(normalizeDeg(angleDeg)) % ANGLE_BUCKETS;
    
    for (let r = 0; r < RADIUS_BINS; r++) {
      const srcIdx = Math.floor((r / RADIUS_BINS) * bins.length);
      polarData[bucket][r] = bins[srcIdx] || 0;
    }
  }

  // --- Orientation / heading
  let headingDegrees = 0;
  let hasHeading = false;

  function normalizeDeg(d) {
    d = d % 360;
    if (d < 0) d += 360;
    return d;
  }

  async function enableSensors() {
    notesEl.textContent = "";
    try {
      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
        const p = await DeviceOrientationEvent.requestPermission();
        if (p !== "granted") throw new Error("DeviceOrientation permission not granted");
      }
    } catch (e) {
      notesEl.textContent = "DeviceOrientation permission failed: " + (e?.message || e);
    }

    window.addEventListener("deviceorientation", (ev) => {
      if (typeof ev.webkitCompassHeading === "number") {
        headingDegrees = normalizeDeg(ev.webkitCompassHeading);
        hasHeading = true;
      } else if (ev.absolute === true && typeof ev.alpha === "number") {
        headingDegrees = normalizeDeg(ev.alpha);
        hasHeading = true;
      } else if (typeof ev.alpha === "number") {
        headingDegrees = normalizeDeg(ev.alpha);
        hasHeading = true;
      }
      headingEl.textContent = hasHeading ? headingDegrees.toFixed(1) + "¬∞" : "‚Äî";
    }, { passive: true });

    notesEl.textContent = "Sensors enabled (if supported). Rotate the device to change heading.";
  }

  // --- Audio
  let audioCtx = null;
  let micStream = null;
  let micSource = null;
  let micTap = null;
  let running = false;

  // --- Live scan parameters (synced from UI with debounce)
  // Cepstrum-based echo detection parameters
  let scanParams = {
    freq: 19000,
    burstMs: 8,
    listenMs: 80,
    channel: 'R',
    amp: 0.18,
    speedOfSound: 343,  // m/s
    minDist: 0.15,      // meters (skip direct leakage)
    maxDist: 10,        // meters (physical plausibility limit)
    bandwidth: 2000,    // Hz (bandpass filter width around ping freq)
    burst: null  // cached tone buffer, regenerated when freq/burstMs change
  };

  function syncParamsFromUI() {
    const newFreq = Number($("freq").value);
    const newBurstMs = Number($("burstMs").value);
    const needNewBurst = audioCtx && (
      newFreq !== scanParams.freq || 
      newBurstMs !== scanParams.burstMs
    );

    scanParams.freq = newFreq;
    scanParams.burstMs = newBurstMs;
    scanParams.listenMs = Number($("listenMs").value);
    scanParams.channel = String($("channel").value);
    scanParams.amp = Number($("amp").value);
    scanParams.speedOfSound = Number($("speedOfSound").value);
    scanParams.minDist = Number($("minDist").value);
    scanParams.maxDist = Number($("maxDist").value);
    scanParams.bandwidth = Number($("bandwidth").value);

    if (needNewBurst) {
      const sr = audioCtx.sampleRate;
      scanParams.burst = makeToneBurst(sr, scanParams.freq, scanParams.burstMs / 1000);
    }
  }

  // --- Debounced parameter sync
  const PARAMS_DEBOUNCE_MS = 250;
  let paramsSyncTimer = null;

  function scheduleSyncParams() {
    if (paramsSyncTimer) clearTimeout(paramsSyncTimer);
    paramsSyncTimer = setTimeout(() => {
      syncParamsFromUI();
      paramsSyncTimer = null;
    }, PARAMS_DEBOUNCE_MS);
  }

  // Wire up debounced sync to all settings controls
  function setupLiveParamsSync() {
    const sliderIds = ['freq', 'burstMs', 'listenMs', 'amp', 'speedOfSound', 'minDist', 'maxDist', 'bandwidth'];
    for (const id of sliderIds) {
      const slider = $(id);
      if (slider) {
        slider.addEventListener('input', scheduleSyncParams);
      }
    }
    // Also listen to channel select changes
    const channelSelect = $("channel");
    if (channelSelect) {
      channelSelect.addEventListener('change', scheduleSyncParams);
    }
  }

  async function ensureAudio() {
    if (audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)({
      latencyHint: "interactive"
    });

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    });

    micSource = audioCtx.createMediaStreamSource(micStream);

    const useWorklet = !!audioCtx.audioWorklet;
    if (useWorklet) {
      const workletCode = `
        class TapProcessor extends AudioWorkletProcessor {
          process(inputs) {
            const input = inputs[0];
            if (input && input[0]) this.port.postMessage(input[0].slice(0));
            return true;
          }
        }
        registerProcessor('tap-processor', TapProcessor);
      `;
      const blob = new Blob([workletCode], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      await audioCtx.audioWorklet.addModule(url);

      micTap = new AudioWorkletNode(audioCtx, "tap-processor");
      micSource.connect(micTap);
    } else {
      const bufSize = 2048;
      micTap = audioCtx.createScriptProcessor(bufSize, 1, 1);
      micSource.connect(micTap);
      micTap.connect(audioCtx.destination);
    }

    srEl.textContent = String(audioCtx.sampleRate);
  }

  function makeToneBurst(sr, freq, durationSec) {
    const N = Math.max(16, Math.floor(durationSec * sr));
    const x = new Float32Array(N);
    for (let n = 0; n < N; n++) {
      const t = n / sr;
      const w = 0.5 * (1 - Math.cos(2 * Math.PI * n / (N - 1)));
      x[n] = Math.sin(2 * Math.PI * freq * t) * w;
    }
    return x;
  }

  function playBurstOneChannel(burst, amp, channel) {
    const sr = audioCtx.sampleRate;
    const N = burst.length;
    const buf = audioCtx.createBuffer(2, N, sr);
    const L = buf.getChannelData(0);
    const R = buf.getChannelData(1);

    if (channel === "L") {
      for (let i = 0; i < N; i++) { L[i] = burst[i] * amp; R[i] = 0; }
    } else {
      for (let i = 0; i < N; i++) { L[i] = 0; R[i] = burst[i] * amp; }
    }

    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(audioCtx.destination);
    src.start();
    return N / sr;
  }

  async function recordWindow(durationSec) {
    const sr = audioCtx.sampleRate;
    const need = Math.floor(durationSec * sr);
    const chunks = [];
    let got = 0;

    return new Promise((resolve) => {
      const onData = (data) => {
        chunks.push(data);
        got += data.length;
        if (got >= need) {
          const out = new Float32Array(got);
          let o = 0;
          for (const c of chunks) { out.set(c, o); o += c.length; }
          cleanup();
          resolve(out.subarray(0, need));
        }
      };

      const cleanup = () => {
        if (micTap instanceof AudioWorkletNode) micTap.port.onmessage = null;
        else micTap.onaudioprocess = null;
      };

      if (micTap instanceof AudioWorkletNode) {
        micTap.port.onmessage = (ev) => onData(ev.data);
      } else {
        micTap.onaudioprocess = (ev) => onData(new Float32Array(ev.inputBuffer.getChannelData(0)));
      }
    });
  }

  function goertzelPower(frame, sr, freq) {
    const N = frame.length;
    const k = Math.round((N * freq) / sr);
    const w = (2 * Math.PI * k) / N;
    const cosw = Math.cos(w);
    const coeff = 2 * cosw;

    let s0 = 0, s1 = 0, s2 = 0;
    for (let n = 0; n < N; n++) {
      s0 = frame[n] + coeff * s1 - s2;
      s2 = s1;
      s1 = s0;
    }
    const power = s1 * s1 + s2 * s2 - coeff * s1 * s2;
    return Math.max(0, power);
  }

  function energyEnvelopeBins(recordedTail, sr, freq, frameSize, hopSize, numBins) {
    const powers = [];
    for (let i = 0; i + frameSize <= recordedTail.length; i += hopSize) {
      const frame = recordedTail.subarray(i, i + frameSize);
      powers.push(goertzelPower(frame, sr, freq));
    }
    
    if (powers.length === 0) return new Float32Array(numBins);

    const logPowers = powers.map(p => Math.log10(p + 1e-10));
    
    let minLog = logPowers[0], maxLog = logPowers[0];
    for (const lp of logPowers) {
      if (lp < minLog) minLog = lp;
      if (lp > maxLog) maxLog = lp;
    }
    const rangeLog = maxLog - minLog || 1;

    const out = new Float32Array(numBins);

    for (let b = 0; b < numBins; b++) {
      const pStart = (b / numBins) * powers.length;
      const pEnd = ((b + 1) / numBins) * powers.length;
      
      const iStart = Math.floor(pStart);
      const iEnd = Math.max(iStart + 1, Math.ceil(pEnd));
      
      let m = -Infinity;
      for (let i = iStart; i < iEnd && i < logPowers.length; i++) {
        m = Math.max(m, logPowers[i]);
      }
      
      const normalized = clamp((m - minLog) / rangeLog, 0, 1);
      out[b] = Math.pow(normalized, 0.5);
    }
    return out;
  }

  async function scanLoop() {
    const sr = audioCtx.sampleRate;
    
    // Initialize burst buffer if not already created
    if (!scanParams.burst) {
      scanParams.burst = makeToneBurst(sr, scanParams.freq, scanParams.burstMs / 1000);
    }

    running = true;
    setStatus("running (cepstrum mode)");

    while (running) {
      // Read current params from the live-synced object
      const { freq, listenMs, channel, amp, speedOfSound, minDist, maxDist, bandwidth, burst } = scanParams;

      const deg = hasHeading ? headingDegrees : (performance.now() / 50) % 360;
      const bucket = Math.floor(normalizeDeg(deg));
      bucketEl.textContent = bucket + "¬∞ / " + ANGLE_BUCKETS;

      const burstSec = playBurstOneChannel(burst, amp, channel);

      const recSec = burstSec + (listenMs / 1000);
      const recorded = await recordWindow(recSec);

      // Skip the burst portion to reduce direct leakage
      const skip = Math.floor(burstSec * sr * 0.9);
      const tail = recorded.subarray(skip);

      // Compute real cepstrum with bandpass filtering
      const cepstrum = computeRealCepstrum(tail, sr, freq, bandwidth);
      
      // Convert cepstrum to distance bins (filtering by min/max distance)
      const rawBins = cepstrumToDistanceBins(cepstrum, sr, speedOfSound, minDist, maxDist, RADIUS_BINS);
      
      // Apply temporal sliding mean subtraction for stability
      const bins = applySlidingMeanSubtraction(bucket, rawBins);

      updatePolarDataAtAngle(deg, bins);
      drawPolarSonogram(deg);

      // Update info chart only if panel is open
      if (infoPanel.classList.contains('open')) {
        drawInfoChart(bins, minDist, maxDist);
      }

      await new Promise(r => setTimeout(r, 0));
    }

    setStatus("stopped");
  }

  // --- UI wiring
  const toggleBtn = $("toggleBtn");

  async function startScan() {
    try {
      toggleBtn.disabled = true;

      await enableSensors();
      await enableWakeLock();
      await ensureAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();

      toggleBtn.disabled = false;
      toggleBtn.textContent = "‚èπ Stop";
      toggleBtn.classList.add("running");

      scanLoop();
    } catch (e) {
      console.error(e);
      setStatus("error: " + (e?.message || e));
      toggleBtn.disabled = false;
      toggleBtn.textContent = "‚ñ∂ Start";
      toggleBtn.classList.remove("running");
    }
  }

  async function stopScan() {
    running = false;
    await releaseWakeLock();
    toggleBtn.textContent = "‚ñ∂ Start";
    toggleBtn.classList.remove("running");
  }

  toggleBtn.onclick = async () => {
    if (running) {
      await stopScan();
    } else {
      await startScan();
    }
  };

  $("btnClear").onclick = () => resetImage();

  $("btnPng").onclick = () => {
    const a = document.createElement("a");
    a.download = "sonogram_19k_polar.png";
    a.href = canvas.toDataURL("image/png");
    a.click();
  };

  // --- Calibration system
  const calibrationOverlay = $("calibrationOverlay");
  const calibStatus = $("calibStatus");
  const calibProgressBar = $("calibProgressBar");
  const calibParams = $("calibParams");
  const calibCancelBtn = $("calibCancelBtn");
  const calibrateBtn = $("calibrateBtn");

  let calibrationRunning = false;

  // Parameter sweep ranges (~540 combinations)
  const CALIB_FREQUENCIES = [17000, 17500, 18000, 18500, 19000];
  const CALIB_BURST_MS = [4, 8, 12];
  const CALIB_LISTEN_MS = [30, 50, 80];
  const CALIB_FRAME_SIZES = [256, 512, 1024];
  const CALIB_HOP_SIZES = [128, 256];
  const CALIB_CHANNELS = ['L', 'R'];
  const CALIB_ITERATIONS = 3;  // measurements per parameter combination

  function calculateTotalCalibCombinations() {
    return CALIB_FREQUENCIES.length * 
           CALIB_BURST_MS.length * 
           CALIB_LISTEN_MS.length * 
           CALIB_FRAME_SIZES.length * 
           CALIB_HOP_SIZES.length * 
           CALIB_CHANNELS.length;
  }

  async function runCalibration() {
    if (calibrationRunning || running) return;

    try {
      calibrationRunning = true;
      calibrationOverlay.classList.remove('hidden');
      calibStatus.textContent = 'Initializing audio...';
      calibProgressBar.style.width = '0%';
      calibParams.textContent = '‚Äî';

      // Ensure audio is ready
      await ensureAudio();
      if (audioCtx.state !== 'running') await audioCtx.resume();

      const sr = audioCtx.sampleRate;
      const totalCombinations = calculateTotalCalibCombinations();
      let completedCombinations = 0;

      const results = {
        deviceInfo: {
          userAgent: navigator.userAgent,
          sampleRate: sr,
          timestamp: new Date().toISOString(),
          platform: navigator.platform || 'unknown'
        },
        targetDistance: 1.0,
        measurements: []
      };

      calibStatus.textContent = `Running calibration: 0 / ${totalCombinations}`;

      // Iterate through all parameter combinations
      for (const freq of CALIB_FREQUENCIES) {
        for (const burstMs of CALIB_BURST_MS) {
          for (const listenMs of CALIB_LISTEN_MS) {
            for (const frameSize of CALIB_FRAME_SIZES) {
              for (const hopSize of CALIB_HOP_SIZES) {
                for (const channel of CALIB_CHANNELS) {
                  if (!calibrationRunning) {
                    // Cancelled
                    calibrationOverlay.classList.add('hidden');
                    return;
                  }

                  // Update UI
                  const progress = ((completedCombinations / totalCombinations) * 100).toFixed(1);
                  calibProgressBar.style.width = progress + '%';
                  calibStatus.textContent = `Running calibration: ${completedCombinations + 1} / ${totalCombinations}`;
                  calibParams.textContent = `freq=${freq}Hz burst=${burstMs}ms listen=${listenMs}ms frame=${frameSize} hop=${hopSize} ch=${channel}`;

                  // Generate burst for this frequency/duration
                  const burst = makeToneBurst(sr, freq, burstMs / 1000);
                  const amp = 0.18;  // Fixed amplitude for calibration

                  // Run multiple iterations
                  const iterationResults = [];
                  for (let iter = 0; iter < CALIB_ITERATIONS; iter++) {
                    if (!calibrationRunning) {
                      calibrationOverlay.classList.add('hidden');
                      return;
                    }

                    // Play burst and record
                    const burstSec = playBurstOneChannel(burst, amp, channel);
                    const recSec = burstSec + (listenMs / 1000);
                    const recorded = await recordWindow(recSec);

                    // Skip the burst portion
                    const skip = Math.floor(burstSec * sr * 0.9);
                    const tail = recorded.subarray(skip);

                    // Compute energy at target frequency for each frame
                    const powers = [];
                    for (let i = 0; i + frameSize <= tail.length; i += hopSize) {
                      const frame = tail.subarray(i, i + frameSize);
                      powers.push(goertzelPower(frame, sr, freq));
                    }

                    if (powers.length > 0) {
                      // Find peak power and its position
                      let peakPower = powers[0];
                      let peakIdx = 0;
                      let sumPower = 0;
                      for (let i = 0; i < powers.length; i++) {
                        sumPower += powers[i];
                        if (powers[i] > peakPower) {
                          peakPower = powers[i];
                          peakIdx = i;
                        }
                      }
                      const meanPower = sumPower / powers.length;
                      
                      // Calculate peak time in ms
                      const peakTimeSamples = skip + peakIdx * hopSize;
                      const peakTimeMs = (peakTimeSamples / sr) * 1000;
                      
                      // Simple SNR estimate: peak / mean
                      const snr = meanPower > 0 ? peakPower / meanPower : 0;

                      iterationResults.push({
                        peakPower,
                        meanPower,
                        peakTimeMs,
                        snr,
                        peakBin: peakIdx,
                        numBins: powers.length
                      });
                    }

                    // Small delay between iterations
                    await new Promise(r => setTimeout(r, 30));
                  }

                  // Aggregate iteration results
                  if (iterationResults.length > 0) {
                    const powers = iterationResults.map(r => r.peakPower);
                    const meanPeakPower = powers.reduce((a, b) => a + b, 0) / powers.length;
                    const avgPeakTimeMs = iterationResults.reduce((a, r) => a + r.peakTimeMs, 0) / iterationResults.length;
                    const avgSnr = iterationResults.reduce((a, r) => a + r.snr, 0) / iterationResults.length;

                    results.measurements.push({
                      params: {
                        frequency: freq,
                        burstMs,
                        listenMs,
                        frameSize,
                        hopSize,
                        channel
                      },
                      results: {
                        iterations: iterationResults.length,
                        powers: powers,
                        meanPower: meanPeakPower,
                        peakBin: Math.round(iterationResults.reduce((a, r) => a + r.peakBin, 0) / iterationResults.length),
                        peakTimeMs: avgPeakTimeMs,
                        snr: avgSnr
                      }
                    });
                  }

                  completedCombinations++;
                }
              }
            }
          }
        }
      }

      // Calibration complete - download JSON
      calibStatus.textContent = 'Calibration complete! Downloading results...';
      calibProgressBar.style.width = '100%';
      calibParams.textContent = `${results.measurements.length} measurements collected`;

      const jsonStr = JSON.stringify(results, null, 2);
      const blob = new Blob([jsonStr], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `sonar_calibration_${new Date().toISOString().slice(0, 19).replace(/[:-]/g, '')}.json`;
      a.click();
      URL.revokeObjectURL(url);

      // Close overlay after short delay
      await new Promise(r => setTimeout(r, 1500));
      calibrationOverlay.classList.add('hidden');

    } catch (e) {
      console.error('Calibration error:', e);
      calibStatus.textContent = 'Error: ' + (e?.message || e);
      await new Promise(r => setTimeout(r, 3000));
      calibrationOverlay.classList.add('hidden');
    } finally {
      calibrationRunning = false;
    }
  }

  calibrateBtn.onclick = () => {
    if (running) {
      alert('Please stop scanning before running calibration.');
      return;
    }
    runCalibration();
  };

  calibCancelBtn.onclick = () => {
    calibrationRunning = false;
    calibStatus.textContent = 'Cancelling...';
  };

  // --- Calibration data analysis
  // Function to analyze calibration JSON and find optimal parameters
  // Usage: analyzeCalibrationData(jsonData) or load JSON file and call this function
  function analyzeCalibrationData(data) {
    if (!data || !data.measurements || !Array.isArray(data.measurements)) {
      console.error('Invalid calibration data format');
      return null;
    }

    // Expected time-of-flight for 1m distance (round trip = 2m)
    // Speed of sound ~343 m/s, so 2m / 343 m/s = ~5.83 ms
    const EXPECTED_TOF_MS = 5.83;
    const TOF_TOLERANCE_MS = 1.5; // ¬±1.5ms tolerance

    // Filter and score measurements
    const scored = data.measurements.map(m => {
      const { params, results } = m;
      
      // Score based on:
      // 1. SNR (higher is better)
      // 2. Mean power (higher is better)
      // 3. Time-of-flight accuracy (closer to expected is better)
      // 4. Stability (lower variance in powers is better)
      
      const tofError = Math.abs(results.peakTimeMs - EXPECTED_TOF_MS);
      const tofScore = Math.max(0, 1 - (tofError / TOF_TOLERANCE_MS));
      
      // Calculate variance in powers
      const powers = results.powers.filter(p => p > 0);
      const variance = powers.length > 1 
        ? powers.reduce((sum, p) => sum + Math.pow(p - results.meanPower, 2), 0) / powers.length
        : 0;
      const stabilityScore = results.meanPower > 0 ? 1 / (1 + variance / results.meanPower) : 0;
      
      // Combined score (weighted)
      const score = (
        results.snr * 0.4 +           // SNR is important
        Math.log10(results.meanPower + 1e-10) * 0.3 +  // Log power (wider range)
        tofScore * 0.2 +              // Time-of-flight accuracy
        stabilityScore * 0.1          // Stability
      );
      
      return {
        params,
        results,
        score,
        tofError,
        stabilityScore
      };
    });

    // Filter out measurements with zero power or very poor SNR
    const valid = scored.filter(m => 
      m.results.meanPower > 0 && 
      m.results.snr > 0.5 &&
      m.results.peakTimeMs > 2 && 
      m.results.peakTimeMs < 15
    );

    // Sort by score (descending)
    valid.sort((a, b) => b.score - a.score);

    // Group by frequency and channel to see patterns
    const byFreqChannel = {};
    valid.forEach(m => {
      const key = `${m.params.frequency}_${m.params.channel}`;
      if (!byFreqChannel[key] || m.score > byFreqChannel[key].score) {
        byFreqChannel[key] = m;
      }
    });

    const result = {
      deviceInfo: data.deviceInfo,
      totalMeasurements: data.measurements.length,
      validMeasurements: valid.length,
      topResults: valid.slice(0, 20),
      bestByFreqChannel: byFreqChannel,
      recommended: valid[0] || null
    };

    // Log results to console
    console.log('=== CALIBRATION ANALYSIS RESULTS ===');
    console.log(`Device: ${data.deviceInfo.userAgent}`);
    console.log(`Sample Rate: ${data.deviceInfo.sampleRate} Hz`);
    console.log(`Total measurements: ${data.measurements.length}`);
    console.log(`Valid measurements: ${valid.length}`);
    console.log('\n=== TOP 10 BEST PARAMETER COMBINATIONS ===');
    valid.slice(0, 10).forEach((m, i) => {
      const { params, results, score, tofError } = m;
      console.log(`${i + 1}. Score: ${score.toFixed(3)} | SNR: ${results.snr.toFixed(2)} | Power: ${results.meanPower.toFixed(6)}`);
      console.log(`   ${params.frequency}Hz, ${params.channel}, burst=${params.burstMs}ms, listen=${params.listenMs}ms, frame=${params.frameSize}, hop=${params.hopSize}`);
      console.log(`   Peak Time: ${results.peakTimeMs.toFixed(2)}ms (error: ${tofError.toFixed(2)}ms)`);
    });
    
    if (result.recommended) {
      console.log('\n=== RECOMMENDED PARAMETERS ===');
      console.log(JSON.stringify(result.recommended.params, null, 2));
      console.log(`SNR: ${result.recommended.results.snr.toFixed(2)}`);
      console.log(`Mean Power: ${result.recommended.results.meanPower.toFixed(6)}`);
      console.log(`Peak Time: ${result.recommended.results.peakTimeMs.toFixed(2)}ms`);
    }

    return result;
  }

  // Make function available globally for console access
  window.analyzeCalibrationData = analyzeCalibrationData;

  // Helper function to load and analyze JSON file
  window.loadAndAnalyzeCalibration = async (file) => {
    try {
      const text = await file.text();
      const data = JSON.parse(text);
      return analyzeCalibrationData(data);
    } catch (e) {
      console.error('Error loading calibration file:', e);
      return null;
    }
  };

  // File input handler for calibration analysis
  const calibrationFileInput = $("calibrationFileInput");
  if (calibrationFileInput) {
    calibrationFileInput.addEventListener('change', async (e) => {
      const file = e.target.files[0];
      if (file) {
        console.log('Loading calibration file:', file.name);
        await window.loadAndAnalyzeCalibration(file);
      }
      // Reset input so same file can be loaded again
      e.target.value = '';
    });
  }

  // Expose file input trigger for console access
  window.analyzeCalibrationFile = () => {
    if (calibrationFileInput) {
      calibrationFileInput.click();
    } else {
      console.error('Calibration file input not found');
    }
  };

  // init
  resetPolarData();
  resetCepstrumHistory();
  resetImage();
  clearInfoChart();
  setStatus("idle");
  headingEl.textContent = "‚Äî";
  bucketEl.textContent = "‚Äî";
  setupLiveParamsSync();
  syncParamsFromUI(); // initialize scanParams from current UI values
  
  if ('wakeLock' in navigator) {
    updateWakeLockStatus('inactive');
  } else {
    updateWakeLockStatus('unsupported');
  }
})();
</script>
</body>
</html>
