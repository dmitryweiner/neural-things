<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ultrasonic Tone Sonogram (19 kHz) ‚Äî prototype</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 16px; }
    .row { display: flex; gap: 12px; flex-wrap: wrap; align-items: end; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 12px; max-width: 1100px; }
    label { display: grid; gap: 4px; font-size: 12px; }
    input, select {
      padding: 6px 8px; border: 1px solid #ccc; border-radius: 8px; min-width: 140px;
      background: #fff;
    }
    button { padding: 8px 10px; border-radius: 10px; border: 1px solid #ccc; background: #fff; cursor: pointer; }
    button.primary { border-color: #888; font-weight: 600; }
    canvas { 
      width: 100%; 
      max-width: 520px; 
      height: auto; 
      border: 1px solid #ddd; 
      border-radius: 12px;
      aspect-ratio: 1;
    }
    .muted { color: #666; font-size: 12px; }
    .warn { color: #8a3b00; font-size: 12px; }
    code { background: #f6f6f6; padding: 1px 6px; border-radius: 6px; }
    .kpi { display:flex; gap:16px; flex-wrap:wrap; margin-top:8px; }
    .kpi div { font-size:12px; color:#333; }
    .kpi b { font-size:12px; }
    .wake-lock-status { 
      display: inline-flex; 
      align-items: center; 
      gap: 4px; 
      font-size: 12px; 
      padding: 2px 8px; 
      border-radius: 6px; 
      background: #f0f0f0;
    }
    .wake-lock-status.active { background: #d4edda; color: #155724; }
    .wake-lock-status.inactive { background: #f8d7da; color: #721c24; }
    .wake-lock-status.unsupported { background: #fff3cd; color: #856404; }
  </style>
</head>
<body>
  <h2>Ultrasonic "sonar" in browser (19 kHz, 1 channel, angle = orientation)</h2>
  <p class="muted">
    Prototype: Web Audio API ‚Üí emit 19 kHz short bursts ‚Üí record microphone ‚Üí compute energy at 19 kHz over time (Goertzel) ‚Üí draw polar sonogram.
  </p>

  <div class="card">
    <div class="row">
      <label>Frequency (Hz)
        <input id="freq" type="number" value="19000" min="16000" max="20000" step="10" />
      </label>

      <label>Burst duration (ms)
        <input id="burstMs" type="number" value="6" min="1" max="40" step="1" />
      </label>

      <label>Listen after (ms)
        <input id="listenMs" type="number" value="50" min="5" max="250" step="1" />
      </label>

      <label>Output channel
        <select id="channel">
          <option value="L">Left</option>
          <option value="R">Right</option>
        </select>
      </label>

      <label>Amplitude (0..1)
        <input id="amp" type="number" value="0.18" min="0.01" max="1" step="0.01" />
      </label>

      <label>Analysis window (samples)
        <input id="frame" type="number" value="512" min="128" max="4096" step="128" />
      </label>

      <label>Time step (samples)
        <input id="hop" type="number" value="128" min="32" max="2048" step="32" />
      </label>
    </div>

    <div class="row" style="margin-top:12px;">
      <button class="primary" id="btnStart">Start</button>
      <button id="btnStop" disabled>Stop</button>
      <button id="btnClear">Clear</button>
      <button id="btnPng">Export PNG</button>
      <span id="wakeLockStatus" class="wake-lock-status unsupported">Wake Lock: checking...</span>
    </div>

    <p class="warn">
      ‚ö†Ô∏è 19‚Äì20 kHz is often filtered by speakers/microphones and "enhancements" (AEC/NS/AGC) on many devices. For testing, a PC + external audio interface often works better.
      Don't crank up the volume: "can't hear it" ‚â† "safe".
    </p>

    <div class="muted" id="status">Status: idle</div>
    <div class="kpi">
      <div><b>sampleRate:</b> <span id="sr">‚Äî</span></div>
      <div><b>heading:</b> <span id="heading">‚Äî</span></div>
      <div><b>angle bucket:</b> <span id="bucket">‚Äî</span></div>
      <div><b>notes:</b> <span id="notes">‚Äî</span></div>
    </div>
  </div>

  <h3>Polar Sonogram</h3>
  <canvas id="canvas" width="520" height="520"></canvas>
  <p class="muted">
    Polar view: angle = heading (0¬∞ at top, clockwise), radius = time-of-flight (center = close, edge = far). 
    Brighter = more energy at 19 kHz. Green line = current device heading.
  </p>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const srEl = $("sr");
  const headingEl = $("heading");
  const bucketEl = $("bucket");
  const notesEl = $("notes");
  const wakeLockStatusEl = $("wakeLockStatus");

  const canvas = $("canvas");
  const g = canvas.getContext("2d", { alpha: false });

  function setStatus(s) { statusEl.textContent = "Status: " + s; }
  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

  // --- Polar data storage
  const ANGLE_BUCKETS = 360; // 1¬∞ resolution
  const RADIUS_BINS = 256;   // range bins
  let polarData = null;      // [angle][radius] -> 0..1 energy value

  function resetPolarData() {
    polarData = new Array(ANGLE_BUCKETS);
    for (let a = 0; a < ANGLE_BUCKETS; a++) {
      polarData[a] = new Float32Array(RADIUS_BINS);
    }
  }

  // --- Wake Lock API
  let wakeLock = null;

  function updateWakeLockStatus(status) {
    wakeLockStatusEl.className = 'wake-lock-status ' + status;
    switch (status) {
      case 'active':
        wakeLockStatusEl.textContent = 'üîí Wake Lock: active';
        break;
      case 'inactive':
        wakeLockStatusEl.textContent = 'üîì Wake Lock: inactive';
        break;
      case 'unsupported':
        wakeLockStatusEl.textContent = '‚ö†Ô∏è Wake Lock: unsupported';
        break;
      default:
        wakeLockStatusEl.textContent = 'Wake Lock: ' + status;
    }
  }

  async function enableWakeLock() {
    if (!('wakeLock' in navigator)) {
      updateWakeLockStatus('unsupported');
      return;
    }
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      updateWakeLockStatus('active');
      
      wakeLock.addEventListener('release', () => {
        updateWakeLockStatus('inactive');
        wakeLock = null;
      });
    } catch (e) {
      console.warn('Wake Lock failed:', e);
      updateWakeLockStatus('inactive');
    }
  }

  async function releaseWakeLock() {
    if (wakeLock) {
      try {
        await wakeLock.release();
      } catch (e) {
        console.warn('Wake Lock release failed:', e);
      }
      wakeLock = null;
      updateWakeLockStatus('inactive');
    }
  }

  // Re-acquire wake lock on visibility change (required by spec)
  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible' && running && !wakeLock) {
      await enableWakeLock();
    }
  });

  // --- Polar rendering
  function drawPolarSonogram(currentHeadingDeg) {
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const maxR = Math.min(cx, cy) - 2; // leave 2px margin

    const imgData = g.createImageData(w, h);
    const data = imgData.data;

    // Draw polar data
    for (let py = 0; py < h; py++) {
      for (let px = 0; px < w; px++) {
        const dx = px - cx;
        const dy = py - cy;
        const r = Math.sqrt(dx * dx + dy * dy);
        
        const i = (py * w + px) * 4;
        
        if (r > maxR) {
          // Outside the circle - dark background
          data[i] = 20;
          data[i + 1] = 20;
          data[i + 2] = 25;
          data[i + 3] = 255;
          continue;
        }

        // Convert to polar coordinates
        // atan2(dx, -dy) gives 0¬∞ at top, positive clockwise
        let angleDeg = Math.atan2(dx, -dy) * 180 / Math.PI;
        if (angleDeg < 0) angleDeg += 360;
        
        // Map radius to bin index (center = 0, edge = RADIUS_BINS-1)
        const radiusBin = Math.floor((r / maxR) * (RADIUS_BINS - 1));
        const angleBucket = Math.floor(angleDeg) % ANGLE_BUCKETS;
        
        // Get value from polar data
        const v = polarData[angleBucket][radiusBin];
        const c = Math.floor(clamp(v, 0, 1) * 255);
        
        data[i] = c;
        data[i + 1] = c;
        data[i + 2] = c;
        data[i + 3] = 255;
      }
    }

    g.putImageData(imgData, 0, 0);

    // Draw crosshairs / reference circles
    g.strokeStyle = 'rgba(80, 80, 90, 0.5)';
    g.lineWidth = 1;
    
    // Concentric circles at 25%, 50%, 75%
    for (const frac of [0.25, 0.5, 0.75]) {
      g.beginPath();
      g.arc(cx, cy, maxR * frac, 0, Math.PI * 2);
      g.stroke();
    }

    // Cardinal direction lines
    g.beginPath();
    g.moveTo(cx, cy - maxR);
    g.lineTo(cx, cy + maxR);
    g.moveTo(cx - maxR, cy);
    g.lineTo(cx + maxR, cy);
    g.stroke();

    // Draw current heading line (green)
    if (typeof currentHeadingDeg === 'number') {
      const headingRad = (currentHeadingDeg - 90) * Math.PI / 180;
      const hx = cx + Math.cos(headingRad + Math.PI / 2) * maxR;
      const hy = cy - Math.sin(headingRad + Math.PI / 2) * maxR;
      
      // Correct calculation: 0¬∞ at top, clockwise
      const rad = (currentHeadingDeg * Math.PI) / 180;
      const lineX = cx + Math.sin(rad) * maxR;
      const lineY = cy - Math.cos(rad) * maxR;

      g.strokeStyle = '#00ff00';
      g.lineWidth = 2;
      g.beginPath();
      g.moveTo(cx, cy);
      g.lineTo(lineX, lineY);
      g.stroke();

      // Small circle at tip
      g.fillStyle = '#00ff00';
      g.beginPath();
      g.arc(lineX, lineY, 4, 0, Math.PI * 2);
      g.fill();

      // Label
      g.fillStyle = '#00ff00';
      g.font = 'bold 12px system-ui';
      const labelX = cx + Math.sin(rad) * (maxR + 15);
      const labelY = cy - Math.cos(rad) * (maxR + 15);
      g.textAlign = 'center';
      g.textBaseline = 'middle';
      g.fillText(currentHeadingDeg.toFixed(0) + '¬∞', labelX, labelY);
    }

    // Center dot
    g.fillStyle = '#666';
    g.beginPath();
    g.arc(cx, cy, 3, 0, Math.PI * 2);
    g.fill();
  }

  function resetImage() {
    resetPolarData();
    drawPolarSonogram(null);
  }

  function updatePolarDataAtAngle(angleDeg, bins) {
    const bucket = Math.floor(normalizeDeg(angleDeg)) % ANGLE_BUCKETS;
    
    // Map bins to RADIUS_BINS
    for (let r = 0; r < RADIUS_BINS; r++) {
      const srcIdx = Math.floor((r / RADIUS_BINS) * bins.length);
      polarData[bucket][r] = bins[srcIdx] || 0;
    }
  }

  // --- Orientation / heading
  let headingDegrees = 0;
  let hasHeading = false;

  function normalizeDeg(d) {
    d = d % 360;
    if (d < 0) d += 360;
    return d;
  }

  async function enableSensors() {
    notesEl.textContent = "";
    try {
      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
        const p = await DeviceOrientationEvent.requestPermission();
        if (p !== "granted") throw new Error("DeviceOrientation permission not granted");
      }
    } catch (e) {
      notesEl.textContent = "DeviceOrientation permission failed: " + (e?.message || e);
    }

    window.addEventListener("deviceorientation", (ev) => {
      if (typeof ev.webkitCompassHeading === "number") {
        headingDegrees = normalizeDeg(ev.webkitCompassHeading);
        hasHeading = true;
      } else if (ev.absolute === true && typeof ev.alpha === "number") {
        headingDegrees = normalizeDeg(ev.alpha);
        hasHeading = true;
      } else if (typeof ev.alpha === "number") {
        headingDegrees = normalizeDeg(ev.alpha);
        hasHeading = true;
      }
      headingEl.textContent = hasHeading ? headingDegrees.toFixed(1) + "¬∞" : "‚Äî";
    }, { passive: true });

    notesEl.textContent = "Sensors enabled (if supported). Rotate the device to change heading.";
  }

  // --- Audio
  let audioCtx = null;
  let micStream = null;
  let micSource = null;
  let micTap = null;
  let running = false;

  async function ensureAudio() {
    if (audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)({
      latencyHint: "interactive"
    });

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    });

    micSource = audioCtx.createMediaStreamSource(micStream);

    const useWorklet = !!audioCtx.audioWorklet;
    if (useWorklet) {
      const workletCode = `
        class TapProcessor extends AudioWorkletProcessor {
          process(inputs) {
            const input = inputs[0];
            if (input && input[0]) this.port.postMessage(input[0].slice(0));
            return true;
          }
        }
        registerProcessor('tap-processor', TapProcessor);
      `;
      const blob = new Blob([workletCode], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      await audioCtx.audioWorklet.addModule(url);

      micTap = new AudioWorkletNode(audioCtx, "tap-processor");
      micSource.connect(micTap);
    } else {
      const bufSize = 2048;
      micTap = audioCtx.createScriptProcessor(bufSize, 1, 1);
      micSource.connect(micTap);
      micTap.connect(audioCtx.destination);
    }

    srEl.textContent = String(audioCtx.sampleRate);
  }

  function makeToneBurst(sr, freq, durationSec) {
    const N = Math.max(16, Math.floor(durationSec * sr));
    const x = new Float32Array(N);
    for (let n = 0; n < N; n++) {
      const t = n / sr;
      const w = 0.5 * (1 - Math.cos(2 * Math.PI * n / (N - 1)));
      x[n] = Math.sin(2 * Math.PI * freq * t) * w;
    }
    return x;
  }

  function playBurstOneChannel(burst, amp, channel) {
    const sr = audioCtx.sampleRate;
    const N = burst.length;
    const buf = audioCtx.createBuffer(2, N, sr);
    const L = buf.getChannelData(0);
    const R = buf.getChannelData(1);

    if (channel === "L") {
      for (let i = 0; i < N; i++) { L[i] = burst[i] * amp; R[i] = 0; }
    } else {
      for (let i = 0; i < N; i++) { L[i] = 0; R[i] = burst[i] * amp; }
    }

    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(audioCtx.destination);
    src.start();
    return N / sr;
  }

  async function recordWindow(durationSec) {
    const sr = audioCtx.sampleRate;
    const need = Math.floor(durationSec * sr);
    const chunks = [];
    let got = 0;

    return new Promise((resolve) => {
      const onData = (data) => {
        chunks.push(data);
        got += data.length;
        if (got >= need) {
          const out = new Float32Array(got);
          let o = 0;
          for (const c of chunks) { out.set(c, o); o += c.length; }
          cleanup();
          resolve(out.subarray(0, need));
        }
      };

      const cleanup = () => {
        if (micTap instanceof AudioWorkletNode) micTap.port.onmessage = null;
        else micTap.onaudioprocess = null;
      };

      if (micTap instanceof AudioWorkletNode) {
        micTap.port.onmessage = (ev) => onData(ev.data);
      } else {
        micTap.onaudioprocess = (ev) => onData(new Float32Array(ev.inputBuffer.getChannelData(0)));
      }
    });
  }

  function goertzelPower(frame, sr, freq) {
    const N = frame.length;
    const k = Math.round((N * freq) / sr);
    const w = (2 * Math.PI * k) / N;
    const cosw = Math.cos(w);
    const coeff = 2 * cosw;

    let s0 = 0, s1 = 0, s2 = 0;
    for (let n = 0; n < N; n++) {
      s0 = frame[n] + coeff * s1 - s2;
      s2 = s1;
      s1 = s0;
    }
    const power = s1 * s1 + s2 * s2 - coeff * s1 * s2;
    return Math.max(0, power);
  }

  function energyEnvelopeBins(recordedTail, sr, freq, frameSize, hopSize, numBins) {
    const powers = [];
    for (let i = 0; i + frameSize <= recordedTail.length; i += hopSize) {
      const frame = recordedTail.subarray(i, i + frameSize);
      powers.push(goertzelPower(frame, sr, freq));
    }
    
    if (powers.length === 0) return new Float32Array(numBins);

    const logPowers = powers.map(p => Math.log10(p + 1e-10));
    
    let minLog = logPowers[0], maxLog = logPowers[0];
    for (const lp of logPowers) {
      if (lp < minLog) minLog = lp;
      if (lp > maxLog) maxLog = lp;
    }
    const rangeLog = maxLog - minLog || 1;

    const out = new Float32Array(numBins);

    for (let b = 0; b < numBins; b++) {
      const pStart = (b / numBins) * powers.length;
      const pEnd = ((b + 1) / numBins) * powers.length;
      
      const iStart = Math.floor(pStart);
      const iEnd = Math.max(iStart + 1, Math.ceil(pEnd));
      
      let m = -Infinity;
      for (let i = iStart; i < iEnd && i < logPowers.length; i++) {
        m = Math.max(m, logPowers[i]);
      }
      
      const normalized = clamp((m - minLog) / rangeLog, 0, 1);
      out[b] = Math.pow(normalized, 0.5);
    }
    return out;
  }

  async function scanLoop() {
    const freq = Number($("freq").value);
    const burstMs = Number($("burstMs").value);
    const listenMs = Number($("listenMs").value);
    const channel = String($("channel").value);
    const amp = Number($("amp").value);
    const frameSize = Number($("frame").value);
    const hopSize = Number($("hop").value);

    const sr = audioCtx.sampleRate;
    const burst = makeToneBurst(sr, freq, burstMs / 1000);

    running = true;
    setStatus("running");

    while (running) {
      const deg = hasHeading ? headingDegrees : (performance.now() / 50) % 360;
      const bucket = Math.floor(normalizeDeg(deg));
      bucketEl.textContent = bucket + "¬∞ / " + ANGLE_BUCKETS;

      // 1) play burst
      const burstSec = playBurstOneChannel(burst, amp, channel);

      // 2) record burst + listen
      const recSec = burstSec + (listenMs / 1000);
      const recorded = await recordWindow(recSec);

      // 3) take tail AFTER most of the emitted burst
      const skip = Math.floor(burstSec * sr * 0.9);
      const tail = recorded.subarray(skip);

      // 4) energy envelope at freq -> bins
      const bins = energyEnvelopeBins(tail, sr, freq, frameSize, hopSize, RADIUS_BINS);

      // 5) update polar data and redraw
      updatePolarDataAtAngle(deg, bins);
      drawPolarSonogram(deg);

      // yield
      await new Promise(r => setTimeout(r, 0));
    }

    setStatus("stopped");
  }

  // --- UI wiring
  $("btnStart").onclick = async () => {
    try {
      $("btnStart").disabled = true;
      $("btnStop").disabled = false;

      await enableSensors();
      await enableWakeLock();
      await ensureAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();

      scanLoop();
    } catch (e) {
      console.error(e);
      setStatus("error: " + (e?.message || e));
      $("btnStart").disabled = false;
      $("btnStop").disabled = true;
    }
  };

  $("btnStop").onclick = async () => {
    running = false;
    await releaseWakeLock();
    $("btnStop").disabled = true;
    $("btnStart").disabled = false;
  };

  $("btnClear").onclick = () => resetImage();

  $("btnPng").onclick = () => {
    const a = document.createElement("a");
    a.download = "sonogram_19k_polar.png";
    a.href = canvas.toDataURL("image/png");
    a.click();
  };

  // init
  resetPolarData();
  resetImage();
  setStatus("idle");
  headingEl.textContent = "‚Äî";
  bucketEl.textContent = "‚Äî";
  
  // Check Wake Lock support on load
  if ('wakeLock' in navigator) {
    updateWakeLockStatus('inactive');
  } else {
    updateWakeLockStatus('unsupported');
  }
})();
</script>
</body>
</html>
