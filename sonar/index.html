<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ultrasonic Sonogram</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 16px; }
    
    /* Top bar with controls */
    .topbar {
      position: sticky;
      top: 0;
      z-index: 20;
      background: #fff;
      border-bottom: 1px solid #ddd;
      padding: 12px 0;
      margin: -16px -16px 16px -16px;
      padding: 12px 16px;
    }
    .topbar h2 { margin: 0 0 10px; font-size: 18px; font-weight: 700; }
    .topbar-desc { color: #666; font-size: 12px; margin-bottom: 12px; }
    
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .btn-group { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
    
    button {
      padding: 8px 12px;
      border-radius: 10px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
      font-weight: 600;
    }
    button:disabled { opacity: 0.5; cursor: not-allowed; }
    
    #toggleBtn {
      background: #27ae60;
      color: #fff;
      border-color: #27ae60;
      box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
    }
    #toggleBtn:hover:not(:disabled) {
      background: #2ecc71;
      border-color: #2ecc71;
    }
    #toggleBtn.running {
      background: #e67e22;
      border-color: #e67e22;
      box-shadow: 0 2px 8px rgba(230, 126, 34, 0.3);
    }
    #toggleBtn.running:hover {
      background: #f39c12;
      border-color: #f39c12;
    }
    
    .collapseBtn {
      background: #f5f5f5;
      border: 1px solid #ddd;
      color: #333;
      padding: 6px 10px;
      border-radius: 999px;
      font-weight: 600;
      cursor: pointer;
    }
    .collapseBtn:hover { background: #eee; }
    .collapseBtn.active {
      background: #e3f2fd;
      border-color: #2196f3;
      color: #1976d2;
    }
    
    /* Settings panel */
    .settingsPanel {
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px;
      max-width: 700px;
      margin-top: 12px;
      display: none;
      background: #fafafa;
    }
    .settingsPanel.open { display: block; }
    
    /* Slider controls */
    .ctrl {
      display: grid;
      grid-template-columns: 140px 1fr 60px;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }
    .ctrl.with-adj {
      grid-template-columns: 140px auto 1fr auto 60px;
      gap: 6px;
    }
    .ctrl:first-child { margin-top: 0; }
    .ctrl label { font-size: 12px; color: #333; font-weight: 500; }
    input[type="range"] { width: 100%; }
    
    select {
      padding: 8px 10px;
      border: 1px solid #ccc;
      border-radius: 8px;
      background: #fff;
      min-width: 120px;
    }
    
    .small { font-size: 12px; color: #666; text-align: right; }
    
    .adj-btn {
      width: 28px;
      height: 28px;
      padding: 0;
      background: #fff;
      border: 1px solid #ddd;
      border-radius: 6px;
      color: #333;
      font-size: 16px;
      font-weight: 700;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      line-height: 1;
      touch-action: manipulation;
      user-select: none;
    }
    .adj-btn:hover { background: #f0f0f0; border-color: #bbb; }
    .adj-btn:active { background: #27ae60; color: #fff; border-color: #27ae60; }
    
    /* System info panel */
    .infoPanel {
      border: 1px solid #ddd;
      border-radius: 12px;
      padding: 14px;
      max-width: 700px;
      margin-top: 12px;
      display: none;
      background: #fafafa;
    }
    .infoPanel.open { display: block; }
    
    .kpi { display: flex; gap: 16px; flex-wrap: wrap; }
    .kpi div { font-size: 12px; color: #333; }
    .kpi b { font-size: 12px; }
    
    .wake-lock-status { 
      display: inline-flex; 
      align-items: center; 
      gap: 4px; 
      font-size: 12px; 
      padding: 2px 8px; 
      border-radius: 6px; 
      background: #f0f0f0;
    }
    .wake-lock-status.active { background: #d4edda; color: #155724; }
    .wake-lock-status.inactive { background: #f8d7da; color: #721c24; }
    .wake-lock-status.unsupported { background: #fff3cd; color: #856404; }
    
    /* Info chart */
    .infoChartSection { margin-top: 4px; }
    .infoChartLabel { font-size: 11px; color: #666; margin-bottom: 6px; }
    #infoChart {
      width: 100%;
      max-width: 400px;
      height: 100px;
      border: 1px solid #ddd;
      border-radius: 8px;
      background: #1a1a1f;
    }
    
    /* Canvas area */
    .canvas-section { max-width: 600px; margin-top: 16px; }
    .canvas-section h3 { margin: 0 0 10px; font-size: 14px; }
    
    .canvas-container {
      position: relative;
      display: inline-block;
    }
    
    .canvas-btn {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(4px);
      padding: 6px 12px;
      border-radius: 8px;
      border: 1px solid rgba(0, 0, 0, 0.15);
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: background 0.15s, border-color 0.15s;
    }
    .canvas-btn:hover {
      background: rgba(255, 255, 255, 0.95);
      border-color: rgba(0, 0, 0, 0.25);
    }
    .canvas-btn:active {
      background: rgba(230, 230, 230, 0.95);
    }
    
    canvas { 
      width: 100%; 
      max-width: 520px; 
      height: auto; 
      border: 1px solid #ddd; 
      border-radius: 12px;
      aspect-ratio: 1;
    }
    
    .muted { color: #666; font-size: 12px; }
    .warn { color: #8a3b00; font-size: 12px; margin-top: 10px; }
    code { background: #f6f6f6; padding: 1px 6px; border-radius: 6px; }
    
    .sep { height: 1px; background: #eee; margin: 12px 0; }
    
    @media (max-width: 600px) {
      .ctrl { grid-template-columns: 100px 1fr 50px; }
      .ctrl.with-adj { grid-template-columns: 100px auto 1fr auto 50px; }
    }
  </style>
</head>
<body>

<section class="topbar">
  <h2>Ultrasonic Sonogram</h2>

  <div class="row">
    <div class="btn-group">
      <button id="toggleBtn">‚ñ∂ Start</button>
      <button id="btnPng">Export PNG</button>
    </div>

    <div class="btn-group">
      <button id="settingsBtn" class="collapseBtn" type="button">‚öôÔ∏è Settings</button>
      <button id="infoBtn" class="collapseBtn" type="button">üìä Info</button>
    </div>
  </div>

  <div id="settingsPanel" class="settingsPanel">
    <div class="ctrl with-adj">
      <label for="freq">Frequency (Hz)</label>
      <button class="adj-btn" data-slider="freq" data-dir="-1">‚àí</button>
      <input id="freq" type="range" min="16000" max="20000" step="10" value="19000">
      <button class="adj-btn" data-slider="freq" data-dir="1">+</button>
      <div class="small" id="freqVal">19000</div>
    </div>

    <div class="ctrl with-adj">
      <label for="burstMs">Burst duration (ms)</label>
      <button class="adj-btn" data-slider="burstMs" data-dir="-1">‚àí</button>
      <input id="burstMs" type="range" min="1" max="40" step="1" value="6">
      <button class="adj-btn" data-slider="burstMs" data-dir="1">+</button>
      <div class="small" id="burstMsVal">6</div>
    </div>

    <div class="ctrl with-adj">
      <label for="listenMs">Listen after (ms)</label>
      <button class="adj-btn" data-slider="listenMs" data-dir="-1">‚àí</button>
      <input id="listenMs" type="range" min="5" max="250" step="1" value="50">
      <button class="adj-btn" data-slider="listenMs" data-dir="1">+</button>
      <div class="small" id="listenMsVal">50</div>
    </div>

    <div class="ctrl">
      <label for="channel">Output channel</label>
      <select id="channel">
        <option value="L">Left</option>
        <option value="R">Right</option>
      </select>
      <div></div>
    </div>

    <div class="ctrl with-adj">
      <label for="amp">Amplitude (0..1)</label>
      <button class="adj-btn" data-slider="amp" data-dir="-1">‚àí</button>
      <input id="amp" type="range" min="0.01" max="1" step="0.01" value="0.18">
      <button class="adj-btn" data-slider="amp" data-dir="1">+</button>
      <div class="small" id="ampVal">0.18</div>
    </div>

    <div class="ctrl with-adj">
      <label for="frame">Frame size (samples)</label>
      <button class="adj-btn" data-slider="frame" data-dir="-1">‚àí</button>
      <input id="frame" type="range" min="128" max="4096" step="128" value="512">
      <button class="adj-btn" data-slider="frame" data-dir="1">+</button>
      <div class="small" id="frameVal">512</div>
    </div>

    <div class="ctrl with-adj">
      <label for="hop">Hop (samples)</label>
      <button class="adj-btn" data-slider="hop" data-dir="-1">‚àí</button>
      <input id="hop" type="range" min="32" max="2048" step="32" value="128">
      <button class="adj-btn" data-slider="hop" data-dir="1">+</button>
      <div class="small" id="hopVal">128</div>
    </div>

    <p class="warn">
      ‚ö†Ô∏è 19‚Äì20 kHz is often filtered by speakers/microphones and "enhancements" (AEC/NS/AGC) on many devices. For testing, a PC + external audio interface often works better.
      Don't crank up the volume: "can't hear it" ‚â† "safe".
    </p>
  </div>

  <div id="infoPanel" class="infoPanel">
    <div class="muted" id="status">Status: idle</div>
    <div class="sep"></div>
    <div class="kpi">
      <div><b>sampleRate:</b> <span id="sr">‚Äî</span></div>
      <div><b>heading:</b> <span id="heading">‚Äî</span></div>
      <div><b>angle bucket:</b> <span id="bucket">‚Äî</span></div>
      <div><b>notes:</b> <span id="notes">‚Äî</span></div>
    </div>
    <div class="sep"></div>
    <span id="wakeLockStatus" class="wake-lock-status unsupported">Wake Lock: checking...</span>
    <div class="sep"></div>
    <div class="infoChartSection">
      <div class="infoChartLabel">Intensity vs Time (current angle)</div>
      <canvas id="infoChart" width="400" height="100"></canvas>
    </div>
  </div>
</section>

<section class="canvas-section">
  <h3>Polar Sonogram</h3>
  <div class="canvas-container">
    <canvas id="canvas" width="520" height="520"></canvas>
    <button id="btnClear" class="canvas-btn">Clear</button>
  </div>
  <p class="muted">
    Polar view: angle = heading (0¬∞ at top, clockwise), radius = time-of-flight (center = close, edge = far). 
    Brighter = more energy. Green line = current device heading.
  </p>
</section>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
  const statusEl = $("status");
  const srEl = $("sr");
  const headingEl = $("heading");
  const bucketEl = $("bucket");
  const notesEl = $("notes");
  const wakeLockStatusEl = $("wakeLockStatus");

  const canvas = $("canvas");
  const g = canvas.getContext("2d", { alpha: false });

  const infoChart = $("infoChart");
  const chartCtx = infoChart.getContext("2d", { alpha: false });

  function setStatus(s) { statusEl.textContent = "Status: " + s; }
  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }

  // --- Slider value formatting
  function fmt(v, decimals = 0) {
    v = Number(v);
    if (decimals === 0) return String(Math.round(v));
    return v.toFixed(decimals);
  }

  // --- +/- Adjustment buttons (with hold-to-repeat)
  let adjRepeatInterval = null;
  const ADJ_REPEAT_DELAY = 150;

  function adjustSlider(btn) {
    const sliderId = btn.dataset.slider;
    const dir = Number(btn.dataset.dir);
    const slider = document.getElementById(sliderId);
    if (!slider) return;
    
    const step = Number(slider.step) || 1;
    const min = Number(slider.min);
    const max = Number(slider.max);
    let newVal = Number(slider.value) + dir * step;
    newVal = Math.max(min, Math.min(max, newVal));
    
    slider.value = newVal;
    slider.dispatchEvent(new Event('input', { bubbles: true }));
  }

  function stopAdjRepeat() {
    if (adjRepeatInterval) {
      clearInterval(adjRepeatInterval);
      adjRepeatInterval = null;
    }
  }

  function setupAdjustmentButtons(container) {
    container.addEventListener('pointerdown', (e) => {
      const btn = e.target.closest('.adj-btn');
      if (!btn) return;
      
      e.preventDefault();
      stopAdjRepeat();
      
      adjustSlider(btn);
      adjRepeatInterval = setInterval(() => adjustSlider(btn), ADJ_REPEAT_DELAY);
    });

    container.addEventListener('pointerup', stopAdjRepeat);
    container.addEventListener('pointerleave', stopAdjRepeat);
    container.addEventListener('pointercancel', stopAdjRepeat);
  }

  document.addEventListener('pointerup', stopAdjRepeat);

  // --- Slider value display updates
  const sliderConfigs = {
    freq: { decimals: 0 },
    burstMs: { decimals: 0 },
    listenMs: { decimals: 0 },
    amp: { decimals: 2 },
    frame: { decimals: 0 },
    hop: { decimals: 0 }
  };

  for (const [id, cfg] of Object.entries(sliderConfigs)) {
    const slider = $(id);
    const valEl = $(id + 'Val');
    if (slider && valEl) {
      slider.addEventListener('input', () => {
        valEl.textContent = fmt(slider.value, cfg.decimals);
      });
    }
  }

  // --- Settings panel
  setupAdjustmentButtons($("settingsPanel"));

  // --- Panel toggles
  const settingsPanel = $("settingsPanel");
  const infoPanel = $("infoPanel");
  const settingsBtn = $("settingsBtn");
  const infoBtn = $("infoBtn");

  settingsBtn.addEventListener('click', () => {
    const open = !settingsPanel.classList.contains('open');
    settingsPanel.classList.toggle('open', open);
    settingsBtn.classList.toggle('active', open);
  });

  infoBtn.addEventListener('click', () => {
    const open = !infoPanel.classList.contains('open');
    infoPanel.classList.toggle('open', open);
    infoBtn.classList.toggle('active', open);
  });

  // --- Polar data storage
  const ANGLE_BUCKETS = 360;
  const RADIUS_BINS = 256;
  let polarData = null;

  function resetPolarData() {
    polarData = new Array(ANGLE_BUCKETS);
    for (let a = 0; a < ANGLE_BUCKETS; a++) {
      polarData[a] = new Float32Array(RADIUS_BINS);
    }
  }

  // --- Wake Lock API
  let wakeLock = null;

  function updateWakeLockStatus(status) {
    wakeLockStatusEl.className = 'wake-lock-status ' + status;
    switch (status) {
      case 'active':
        wakeLockStatusEl.textContent = 'üîí Wake Lock: active';
        break;
      case 'inactive':
        wakeLockStatusEl.textContent = 'üîì Wake Lock: inactive';
        break;
      case 'unsupported':
        wakeLockStatusEl.textContent = '‚ö†Ô∏è Wake Lock: unsupported';
        break;
      default:
        wakeLockStatusEl.textContent = 'Wake Lock: ' + status;
    }
  }

  async function enableWakeLock() {
    if (!('wakeLock' in navigator)) {
      updateWakeLockStatus('unsupported');
      return;
    }
    try {
      wakeLock = await navigator.wakeLock.request('screen');
      updateWakeLockStatus('active');
      
      wakeLock.addEventListener('release', () => {
        updateWakeLockStatus('inactive');
        wakeLock = null;
      });
    } catch (e) {
      console.warn('Wake Lock failed:', e);
      updateWakeLockStatus('inactive');
    }
  }

  async function releaseWakeLock() {
    if (wakeLock) {
      try {
        await wakeLock.release();
      } catch (e) {
        console.warn('Wake Lock release failed:', e);
      }
      wakeLock = null;
      updateWakeLockStatus('inactive');
    }
  }

  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible' && running && !wakeLock) {
      await enableWakeLock();
    }
  });

  // --- Polar rendering
  function drawPolarSonogram(currentHeadingDeg) {
    const w = canvas.width;
    const h = canvas.height;
    const cx = w / 2;
    const cy = h / 2;
    const maxR = Math.min(cx, cy) - 2;

    const imgData = g.createImageData(w, h);
    const data = imgData.data;

    for (let py = 0; py < h; py++) {
      for (let px = 0; px < w; px++) {
        const dx = px - cx;
        const dy = py - cy;
        const r = Math.sqrt(dx * dx + dy * dy);
        
        const i = (py * w + px) * 4;
        
        if (r > maxR) {
          data[i] = 20;
          data[i + 1] = 20;
          data[i + 2] = 25;
          data[i + 3] = 255;
          continue;
        }

        let angleDeg = Math.atan2(dx, -dy) * 180 / Math.PI;
        if (angleDeg < 0) angleDeg += 360;
        
        const radiusBin = Math.floor((r / maxR) * (RADIUS_BINS - 1));
        const angleBucket = Math.floor(angleDeg) % ANGLE_BUCKETS;
        
        const v = polarData[angleBucket][radiusBin];
        const c = Math.floor(clamp(v, 0, 1) * 255);
        
        data[i] = c;
        data[i + 1] = c;
        data[i + 2] = c;
        data[i + 3] = 255;
      }
    }

    g.putImageData(imgData, 0, 0);

    g.strokeStyle = 'rgba(80, 80, 90, 0.5)';
    g.lineWidth = 1;
    
    for (const frac of [0.25, 0.5, 0.75]) {
      g.beginPath();
      g.arc(cx, cy, maxR * frac, 0, Math.PI * 2);
      g.stroke();
    }

    g.beginPath();
    g.moveTo(cx, cy - maxR);
    g.lineTo(cx, cy + maxR);
    g.moveTo(cx - maxR, cy);
    g.lineTo(cx + maxR, cy);
    g.stroke();

    if (typeof currentHeadingDeg === 'number') {
      const rad = (currentHeadingDeg * Math.PI) / 180;
      const lineX = cx + Math.sin(rad) * maxR;
      const lineY = cy - Math.cos(rad) * maxR;

      g.strokeStyle = '#00ff00';
      g.lineWidth = 2;
      g.beginPath();
      g.moveTo(cx, cy);
      g.lineTo(lineX, lineY);
      g.stroke();

      g.fillStyle = '#00ff00';
      g.beginPath();
      g.arc(lineX, lineY, 4, 0, Math.PI * 2);
      g.fill();

      g.fillStyle = '#00ff00';
      g.font = 'bold 12px system-ui';
      const labelX = cx + Math.sin(rad) * (maxR + 15);
      const labelY = cy - Math.cos(rad) * (maxR + 15);
      g.textAlign = 'center';
      g.textBaseline = 'middle';
      g.fillText(currentHeadingDeg.toFixed(0) + '¬∞', labelX, labelY);
    }

    g.fillStyle = '#666';
    g.beginPath();
    g.arc(cx, cy, 3, 0, Math.PI * 2);
    g.fill();
  }

  function resetImage() {
    resetPolarData();
    drawPolarSonogram(null);
  }

  // --- Info chart drawing
  function drawInfoChart(bins) {
    const w = infoChart.width;
    const h = infoChart.height;
    const padding = { top: 8, right: 8, bottom: 20, left: 32 };
    const plotW = w - padding.left - padding.right;
    const plotH = h - padding.top - padding.bottom;

    // Clear with dark background
    chartCtx.fillStyle = "#1a1a1f";
    chartCtx.fillRect(0, 0, w, h);

    if (!bins || bins.length === 0) return;

    // Draw grid lines
    chartCtx.strokeStyle = "rgba(255, 255, 255, 0.1)";
    chartCtx.lineWidth = 1;
    
    // Horizontal grid (intensity levels)
    for (let i = 0; i <= 4; i++) {
      const y = padding.top + (i / 4) * plotH;
      chartCtx.beginPath();
      chartCtx.moveTo(padding.left, y);
      chartCtx.lineTo(w - padding.right, y);
      chartCtx.stroke();
    }

    // Y-axis labels
    chartCtx.fillStyle = "#666";
    chartCtx.font = "9px system-ui";
    chartCtx.textAlign = "right";
    chartCtx.textBaseline = "middle";
    for (let i = 0; i <= 4; i++) {
      const val = 1 - i / 4;
      const y = padding.top + (i / 4) * plotH;
      chartCtx.fillText(val.toFixed(1), padding.left - 4, y);
    }

    // X-axis label
    chartCtx.fillStyle = "#666";
    chartCtx.font = "9px system-ui";
    chartCtx.textAlign = "center";
    chartCtx.textBaseline = "top";
    chartCtx.fillText("time ‚Üí", w / 2, h - 12);

    // Draw the intensity line
    chartCtx.strokeStyle = "#00ff00";
    chartCtx.lineWidth = 1.5;
    chartCtx.beginPath();

    for (let i = 0; i < bins.length; i++) {
      const x = padding.left + (i / (bins.length - 1)) * plotW;
      const y = padding.top + (1 - bins[i]) * plotH;
      
      if (i === 0) {
        chartCtx.moveTo(x, y);
      } else {
        chartCtx.lineTo(x, y);
      }
    }
    chartCtx.stroke();

    // Draw filled area under the line
    chartCtx.fillStyle = "rgba(0, 255, 0, 0.15)";
    chartCtx.beginPath();
    chartCtx.moveTo(padding.left, padding.top + plotH);
    for (let i = 0; i < bins.length; i++) {
      const x = padding.left + (i / (bins.length - 1)) * plotW;
      const y = padding.top + (1 - bins[i]) * plotH;
      chartCtx.lineTo(x, y);
    }
    chartCtx.lineTo(padding.left + plotW, padding.top + plotH);
    chartCtx.closePath();
    chartCtx.fill();
  }

  function clearInfoChart() {
    const w = infoChart.width;
    const h = infoChart.height;
    chartCtx.fillStyle = "#1a1a1f";
    chartCtx.fillRect(0, 0, w, h);
    
    // Draw "no data" text
    chartCtx.fillStyle = "#444";
    chartCtx.font = "11px system-ui";
    chartCtx.textAlign = "center";
    chartCtx.textBaseline = "middle";
    chartCtx.fillText("No data ‚Äî start scanning", w / 2, h / 2);
  }

  function updatePolarDataAtAngle(angleDeg, bins) {
    const bucket = Math.floor(normalizeDeg(angleDeg)) % ANGLE_BUCKETS;
    
    for (let r = 0; r < RADIUS_BINS; r++) {
      const srcIdx = Math.floor((r / RADIUS_BINS) * bins.length);
      polarData[bucket][r] = bins[srcIdx] || 0;
    }
  }

  // --- Orientation / heading
  let headingDegrees = 0;
  let hasHeading = false;

  function normalizeDeg(d) {
    d = d % 360;
    if (d < 0) d += 360;
    return d;
  }

  async function enableSensors() {
    notesEl.textContent = "";
    try {
      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
        const p = await DeviceOrientationEvent.requestPermission();
        if (p !== "granted") throw new Error("DeviceOrientation permission not granted");
      }
    } catch (e) {
      notesEl.textContent = "DeviceOrientation permission failed: " + (e?.message || e);
    }

    window.addEventListener("deviceorientation", (ev) => {
      if (typeof ev.webkitCompassHeading === "number") {
        headingDegrees = normalizeDeg(ev.webkitCompassHeading);
        hasHeading = true;
      } else if (ev.absolute === true && typeof ev.alpha === "number") {
        headingDegrees = normalizeDeg(ev.alpha);
        hasHeading = true;
      } else if (typeof ev.alpha === "number") {
        headingDegrees = normalizeDeg(ev.alpha);
        hasHeading = true;
      }
      headingEl.textContent = hasHeading ? headingDegrees.toFixed(1) + "¬∞" : "‚Äî";
    }, { passive: true });

    notesEl.textContent = "Sensors enabled (if supported). Rotate the device to change heading.";
  }

  // --- Audio
  let audioCtx = null;
  let micStream = null;
  let micSource = null;
  let micTap = null;
  let running = false;

  async function ensureAudio() {
    if (audioCtx) return;

    audioCtx = new (window.AudioContext || window.webkitAudioContext)({
      latencyHint: "interactive"
    });

    micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false
      }
    });

    micSource = audioCtx.createMediaStreamSource(micStream);

    const useWorklet = !!audioCtx.audioWorklet;
    if (useWorklet) {
      const workletCode = `
        class TapProcessor extends AudioWorkletProcessor {
          process(inputs) {
            const input = inputs[0];
            if (input && input[0]) this.port.postMessage(input[0].slice(0));
            return true;
          }
        }
        registerProcessor('tap-processor', TapProcessor);
      `;
      const blob = new Blob([workletCode], { type: "application/javascript" });
      const url = URL.createObjectURL(blob);
      await audioCtx.audioWorklet.addModule(url);

      micTap = new AudioWorkletNode(audioCtx, "tap-processor");
      micSource.connect(micTap);
    } else {
      const bufSize = 2048;
      micTap = audioCtx.createScriptProcessor(bufSize, 1, 1);
      micSource.connect(micTap);
      micTap.connect(audioCtx.destination);
    }

    srEl.textContent = String(audioCtx.sampleRate);
  }

  function makeToneBurst(sr, freq, durationSec) {
    const N = Math.max(16, Math.floor(durationSec * sr));
    const x = new Float32Array(N);
    for (let n = 0; n < N; n++) {
      const t = n / sr;
      const w = 0.5 * (1 - Math.cos(2 * Math.PI * n / (N - 1)));
      x[n] = Math.sin(2 * Math.PI * freq * t) * w;
    }
    return x;
  }

  function playBurstOneChannel(burst, amp, channel) {
    const sr = audioCtx.sampleRate;
    const N = burst.length;
    const buf = audioCtx.createBuffer(2, N, sr);
    const L = buf.getChannelData(0);
    const R = buf.getChannelData(1);

    if (channel === "L") {
      for (let i = 0; i < N; i++) { L[i] = burst[i] * amp; R[i] = 0; }
    } else {
      for (let i = 0; i < N; i++) { L[i] = 0; R[i] = burst[i] * amp; }
    }

    const src = audioCtx.createBufferSource();
    src.buffer = buf;
    src.connect(audioCtx.destination);
    src.start();
    return N / sr;
  }

  async function recordWindow(durationSec) {
    const sr = audioCtx.sampleRate;
    const need = Math.floor(durationSec * sr);
    const chunks = [];
    let got = 0;

    return new Promise((resolve) => {
      const onData = (data) => {
        chunks.push(data);
        got += data.length;
        if (got >= need) {
          const out = new Float32Array(got);
          let o = 0;
          for (const c of chunks) { out.set(c, o); o += c.length; }
          cleanup();
          resolve(out.subarray(0, need));
        }
      };

      const cleanup = () => {
        if (micTap instanceof AudioWorkletNode) micTap.port.onmessage = null;
        else micTap.onaudioprocess = null;
      };

      if (micTap instanceof AudioWorkletNode) {
        micTap.port.onmessage = (ev) => onData(ev.data);
      } else {
        micTap.onaudioprocess = (ev) => onData(new Float32Array(ev.inputBuffer.getChannelData(0)));
      }
    });
  }

  function goertzelPower(frame, sr, freq) {
    const N = frame.length;
    const k = Math.round((N * freq) / sr);
    const w = (2 * Math.PI * k) / N;
    const cosw = Math.cos(w);
    const coeff = 2 * cosw;

    let s0 = 0, s1 = 0, s2 = 0;
    for (let n = 0; n < N; n++) {
      s0 = frame[n] + coeff * s1 - s2;
      s2 = s1;
      s1 = s0;
    }
    const power = s1 * s1 + s2 * s2 - coeff * s1 * s2;
    return Math.max(0, power);
  }

  function energyEnvelopeBins(recordedTail, sr, freq, frameSize, hopSize, numBins) {
    const powers = [];
    for (let i = 0; i + frameSize <= recordedTail.length; i += hopSize) {
      const frame = recordedTail.subarray(i, i + frameSize);
      powers.push(goertzelPower(frame, sr, freq));
    }
    
    if (powers.length === 0) return new Float32Array(numBins);

    const logPowers = powers.map(p => Math.log10(p + 1e-10));
    
    let minLog = logPowers[0], maxLog = logPowers[0];
    for (const lp of logPowers) {
      if (lp < minLog) minLog = lp;
      if (lp > maxLog) maxLog = lp;
    }
    const rangeLog = maxLog - minLog || 1;

    const out = new Float32Array(numBins);

    for (let b = 0; b < numBins; b++) {
      const pStart = (b / numBins) * powers.length;
      const pEnd = ((b + 1) / numBins) * powers.length;
      
      const iStart = Math.floor(pStart);
      const iEnd = Math.max(iStart + 1, Math.ceil(pEnd));
      
      let m = -Infinity;
      for (let i = iStart; i < iEnd && i < logPowers.length; i++) {
        m = Math.max(m, logPowers[i]);
      }
      
      const normalized = clamp((m - minLog) / rangeLog, 0, 1);
      out[b] = Math.pow(normalized, 0.5);
    }
    return out;
  }

  async function scanLoop() {
    const freq = Number($("freq").value);
    const burstMs = Number($("burstMs").value);
    const listenMs = Number($("listenMs").value);
    const channel = String($("channel").value);
    const amp = Number($("amp").value);
    const frameSize = Number($("frame").value);
    const hopSize = Number($("hop").value);

    const sr = audioCtx.sampleRate;
    const burst = makeToneBurst(sr, freq, burstMs / 1000);

    running = true;
    setStatus("running");

    while (running) {
      const deg = hasHeading ? headingDegrees : (performance.now() / 50) % 360;
      const bucket = Math.floor(normalizeDeg(deg));
      bucketEl.textContent = bucket + "¬∞ / " + ANGLE_BUCKETS;

      const burstSec = playBurstOneChannel(burst, amp, channel);

      const recSec = burstSec + (listenMs / 1000);
      const recorded = await recordWindow(recSec);

      const skip = Math.floor(burstSec * sr * 0.9);
      const tail = recorded.subarray(skip);

      const bins = energyEnvelopeBins(tail, sr, freq, frameSize, hopSize, RADIUS_BINS);

      updatePolarDataAtAngle(deg, bins);
      drawPolarSonogram(deg);

      // Update info chart only if panel is open
      if (infoPanel.classList.contains('open')) {
        drawInfoChart(bins);
      }

      await new Promise(r => setTimeout(r, 0));
    }

    setStatus("stopped");
  }

  // --- UI wiring
  const toggleBtn = $("toggleBtn");

  async function startScan() {
    try {
      toggleBtn.disabled = true;

      await enableSensors();
      await enableWakeLock();
      await ensureAudio();
      if (audioCtx.state !== "running") await audioCtx.resume();

      toggleBtn.disabled = false;
      toggleBtn.textContent = "‚èπ Stop";
      toggleBtn.classList.add("running");

      scanLoop();
    } catch (e) {
      console.error(e);
      setStatus("error: " + (e?.message || e));
      toggleBtn.disabled = false;
      toggleBtn.textContent = "‚ñ∂ Start";
      toggleBtn.classList.remove("running");
    }
  }

  async function stopScan() {
    running = false;
    await releaseWakeLock();
    toggleBtn.textContent = "‚ñ∂ Start";
    toggleBtn.classList.remove("running");
  }

  toggleBtn.onclick = async () => {
    if (running) {
      await stopScan();
    } else {
      await startScan();
    }
  };

  $("btnClear").onclick = () => resetImage();

  $("btnPng").onclick = () => {
    const a = document.createElement("a");
    a.download = "sonogram_19k_polar.png";
    a.href = canvas.toDataURL("image/png");
    a.click();
  };

  // init
  resetPolarData();
  resetImage();
  clearInfoChart();
  setStatus("idle");
  headingEl.textContent = "‚Äî";
  bucketEl.textContent = "‚Äî";
  
  if ('wakeLock' in navigator) {
    updateWakeLockStatus('inactive');
  } else {
    updateWakeLockStatus('unsupported');
  }
})();
</script>
</body>
</html>
