<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Uzumaki (from formula)</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden; }
    canvas { display:block; width:100vw; height:100vh; }
    .ui{
      position:fixed; left:12px; top:12px;
      color:#eee; font:14px/1.2 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      background:rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.12);
      border-radius:12px;
      padding:12px;
      min-width: 300px;
      backdrop-filter: blur(6px);
    }
    .row{ display:flex; align-items:center; gap:10px; margin:8px 0; }
    .row label{ width:72px; opacity:.9; }
    .row input[type="range"]{ flex:1; }
    .val{ width:84px; text-align:right; opacity:.9; font-variant-numeric: tabular-nums; }
    button{
      cursor:pointer; user-select:none;
      padding:6px 10px; border-radius:10px;
      border:1px solid rgba(255,255,255,.15);
      background:rgba(255,255,255,.06);
      color:#eee;
    }
    .hint{ opacity:.7; font-size:12px; margin-top:8px; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div class="ui">
  <div class="row">
    <label for="T">time T</label>
    <input id="T" type="range" min="0.001" max="60" step="0.001" value="8">
    <div class="val" id="TVal"></div>
  </div>

  <div class="row">
    <label for="N">n max</label>
    <input id="N" type="range" min="50" max="2000" step="1" value="900">
    <div class="val" id="NVal"></div>
  </div>

  <div class="row">
    <label for="nStep">n step</label>
    <input id="nStep" type="range" min="1" max="20" step="1" value="3">
    <div class="val" id="nStepVal"></div>
  </div>

  <div class="row">
    <label for="samples">samples</label>
    <input id="samples" type="range" min="200" max="4000" step="1" value="1400">
    <div class="val" id="SVal"></div>
  </div>

  <div class="row">
    <label for="gain">gain</label>
    <input id="gain" type="range" min="5" max="2000" step="1" value="350">
    <div class="val" id="GVal"></div>
  </div>

  <div class="row" style="justify-content:space-between;">
    <button id="fit">Fit</button>
    <button id="play">Play</button>
  </div>

  <div class="hint">
    Если снова “круг” — уменьши прозрачность (alpha) в коде или увеличь n step.<br/>
    Если “ничего” — нажми Fit или увеличь gain.
  </div>
</div>

<script>
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false });

  const TInp = document.getElementById('T');
  const NInp = document.getElementById('N');
  const stepInp = document.getElementById('nStep');
  const SInp = document.getElementById('samples');
  const GInp = document.getElementById('gain');

  const TVal = document.getElementById('TVal');
  const NVal = document.getElementById('NVal');
  const stepVal = document.getElementById('nStepVal');
  const SVal = document.getElementById('SVal');
  const GVal = document.getElementById('GVal');

  const fitBtn = document.getElementById('fit');
  const playBtn = document.getElementById('play');

  let W=0, H=0, dpr=1;
  let playing = false;
  let lastTs = 0;

  function resize(){
    dpr = Math.max(1, Math.min(2.5, devicePixelRatio || 1));
    W = Math.floor(innerWidth * dpr);
    H = Math.floor(innerHeight * dpr);
    canvas.width = W;
    canvas.height = H;
    draw();
  }
  addEventListener('resize', resize);

  // F(n,t) = (n^(3/2)/(n+1000)) * sin(0.1 n sin(83.3333 t)) / (0.1 n t)
  // Стабилизация при t->0: sin(k t) / t -> k, но нам важнее чтобы не взрывалось,
  // поэтому используем sinc-подобный вариант: sin(x)/x, где x=0.1 n t,
  // а "модуляция" остаётся sin(83.3333 t).
  function F(n, t){
    const a = Math.pow(n, 1.5) / (n + 1000.0);
    const num = Math.sin(0.1 * n * Math.sin(83.3333 * t));
    const den = 0.1 * n * t;
    if (Math.abs(den) < 1e-8) return a * num; // t почти 0
    return a * (num / den);
  }

  function polarPoint(n, t){
    const theta = 0.1 * n * t;
    const r = F(n, t);
    return [r * Math.cos(theta), r * Math.sin(theta)];
  }

  function draw(){
    const T = parseFloat(TInp.value);
    const N = parseInt(NInp.value, 10);
    const nStep = parseInt(stepInp.value, 10);
    const samples = parseInt(SInp.value, 10);
    const gain = parseFloat(GInp.value);

    TVal.textContent = T.toFixed(3);
    NVal.textContent = String(N);
    stepVal.textContent = String(nStep);
    SVal.textContent = String(samples);
    GVal.textContent = String(gain);

    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,W,H);

    const cx = W/2, cy = H/2;

    // ВАЖНО: низкая непрозрачность, иначе всё закрасит.
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 0.8 * dpr;
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';

    // Рисуем траекторию по t от 0..T для каждого n
    for(let n=1; n<=N; n+=nStep){
      ctx.beginPath();
      let t = 0;
      let [x, y] = polarPoint(n, t);
      ctx.moveTo(cx + x * gain * dpr, cy + y * gain * dpr);

      for(let i=1; i<samples; i++){
        t = (T * i) / (samples - 1);
        [x, y] = polarPoint(n, t);
        ctx.lineTo(cx + x * gain * dpr, cy + y * gain * dpr);
      }
      ctx.stroke();
    }
  }

  function fit(){
    const T = parseFloat(TInp.value);
    const N = parseInt(NInp.value, 10);
    const nStep = parseInt(stepInp.value, 10);

    // прикинем максимальный |r| на грубой сетке
    let rMax = 0;
    const probeSamples = 600;
    for(let n=1; n<=N; n+=Math.max(nStep, Math.floor(N/300))){
      for(let i=0; i<probeSamples; i++){
        const t = (T * i) / (probeSamples - 1);
        rMax = Math.max(rMax, Math.abs(F(n, t)));
      }
    }
    const target = 0.42 * Math.min(W, H) / dpr;
    const newGain = (rMax > 1e-9) ? (target / rMax) : 350;
    GInp.value = String(Math.max(5, Math.min(2000, newGain)));
    draw();
  }

  let raf=0;
  function scheduleDraw(){
    cancelAnimationFrame(raf);
    raf = requestAnimationFrame(draw);
  }

  TInp.addEventListener('input', scheduleDraw);
  NInp.addEventListener('input', scheduleDraw);
  stepInp.addEventListener('input', scheduleDraw);
  SInp.addEventListener('input', scheduleDraw);
  GInp.addEventListener('input', scheduleDraw);

  fitBtn.addEventListener('click', fit);

  playBtn.addEventListener('click', ()=>{
    playing = !playing;
    playBtn.textContent = playing ? 'Pause' : 'Play';
    lastTs = performance.now();
    if (playing) requestAnimationFrame(tick);
  });

  function tick(ts){
    if (!playing) return;
    const dt = (ts - lastTs)/1000;
    lastTs = ts;

    let T = parseFloat(TInp.value);
    T += dt * 0.6;
    if (T > parseFloat(TInp.max)) T = parseFloat(TInp.min);
    TInp.value = String(T);
    draw();
    requestAnimationFrame(tick);
  }

  resize();
  // сразу автоподбор, чтобы не было "чёрного"
  fit();
</script>
</body>
</html>
