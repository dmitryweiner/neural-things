<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Formula Audio Lab</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color-scheme: dark; }
    body { margin: 0; background:#0b0f14; color:#e8eef6; }
    header { padding: 16px 18px; border-bottom: 1px solid #1d2a3a; background:#0d131b; position: sticky; top:0; z-index: 5;}
    h1 { margin: 0 0 8px; font-size: 18px; font-weight: 700;}
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items:center; }
    button { background:#1d3557; color:#fff; border:0; padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600;}
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { padding:6px 10px; border-radius:999px; background:#0f1b29; border:1px solid #1d2a3a; font-size:12px; color:#bcd0e6; }
    main { padding: 16px 18px 28px; display:grid; grid-template-columns: 420px 1fr; gap: 16px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }

    .card { background:#0d131b; border: 1px solid #1d2a3a; border-radius: 14px; padding: 14px; box-shadow: 0 10px 24px rgba(0,0,0,.25); }
    .card h2 { margin:0 0 10px; font-size:14px; color:#d9e7ff;}
    .muted { color:#9fb6d3; font-size: 12px; line-height: 1.3; }

    .scope { display:flex; flex-direction: column; gap: 10px; }
    canvas { width:100%; height: 220px; border-radius: 12px; border:1px solid #1d2a3a; background:#060a0f; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .formula { border-top:1px solid #1d2a3a; padding-top: 12px; margin-top: 12px; }
    .formula:first-child { border-top:0; padding-top:0; margin-top:0; }
    .fhead { display:flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    .fhead h3 { margin:0; font-size: 13px; }
    .fhead .tag { font-size: 11px; color:#bcd0e6; background:#0f1b29; border:1px solid #1d2a3a; padding:3px 8px; border-radius: 999px; }
    .ctrl { display:grid; grid-template-columns: 140px 1fr 70px; gap: 10px; align-items: center; margin-top: 8px;}
    .ctrl label { font-size: 12px; color:#cfe1ff; }
    input[type="range"] { width: 100%; }
    input[type="checkbox"] { transform: scale(1.15); }
    .small { font-size: 11px; color:#9fb6d3; }
    .sep { height:1px; background:#1d2a3a; margin: 10px 0; }
  </style>
</head>
<body>
<header>
  <h1>Formula Audio Lab — формулы как звук</h1>
  <div class="row">
    <button id="startBtn">Start Audio</button>
    <button id="stopBtn" disabled>Stop</button>
    <span class="pill" id="status">Status: not started</span>
    <span class="pill">Tip: включай несколько формул и крути параметры во время звучания</span>
  </div>
</header>

<main>
  <section class="card">
    <h2>Осциллограф (выходной сигнал)</h2>
    <div class="scope">
      <canvas id="scope"></canvas>
      <div class="grid2">
        <div>
          <div class="ctrl">
            <label>Master volume</label>
            <input id="masterGain" type="range" min="0" max="1" step="0.001" value="0.25">
            <div class="small" id="masterGainVal">0.25</div>
          </div>
          <div class="ctrl">
            <label>Oscilloscope gain</label>
            <input id="scopeGain" type="range" min="0.2" max="6" step="0.01" value="1.2">
            <div class="small" id="scopeGainVal">1.20</div>
          </div>
        </div>
        <div class="muted">
          Осциллограф показывает time-domain waveform. Если “плющит” в прямоугольник — уменьши master volume или громкости отдельных формул.
        </div>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Формулы (можно включать одновременно)</h2>
    <div id="formulas"></div>
  </section>
</main>

<script>
(async function(){
  // ---------- AudioWorklet code (inline module) ----------
  const workletCode = `
  class FormulaGeneratorProcessor extends AudioWorkletProcessor {
    constructor(options){
      super();
      const o = (options && options.processorOptions) || {};
      this.formula = o.formula || 'fm';

      this.sr = sampleRate;
      this.t = 0;
      this.phase = 0;
      this.phase2 = 0;

      // for logistic
      this.logi = 0.33;

      // for Lorenz
      this.lx = 0.1; this.ly = 0.0; this.lz = 0.0;

      // default params
      this.p = Object.assign({
        // common
        gain: 0.2,

        // fm
        fc: 220, fm: 2, I: 2,

        // am
        f1: 220, f2: 221,

        // logistic
        base: 110, depth: 330, r: 3.86, lfoHz: 40,

        // gliss
        f0: 55, k: 0.15,

        // additive
        fund: 110, N: 12, move: 0.35,

        // phase modulation
        f: 220, f2pm: 3,

        // beats
        fbeat: 220, df: 0.8,

        // distortion
        fd: 110, alpha: 3.0,

        // quasi LFO
        fq: 120, Aq: 220, wq: 0.8,

        // lorenz
        sigma: 10, rho: 28, beta: 2.6667,
        lBase: 120, lFreqScale: 40, lAmp: 0.25
      }, o.params || {});

      this.port.onmessage = (e) => {
        const msg = e.data || {};
        if (msg.type === 'set') {
          for (const [k,v] of Object.entries(msg.params || {})) {
            this.p[k] = v;
          }
        } else if (msg.type === 'reset') {
          this.t = 0; this.phase = 0; this.phase2 = 0;
          this.logi = 0.33;
          this.lx = 0.1; this.ly = 0.0; this.lz = 0.0;
        }
      };
    }

    // helpers
    sin(x){ return Math.sin(x); }
    tanh(x){ return Math.tanh(x); }
    clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    process(inputs, outputs){
      const out = outputs[0];
      const ch0 = out[0];
      const n = ch0.length;
      const sr = this.sr;
      const twoPi = 2*Math.PI;

      let p = this.p;
      let phase = this.phase;
      let phase2 = this.phase2;
      let t = this.t;
      let logi = this.logi;
      let lx = this.lx, ly = this.ly, lz = this.lz;

      for (let i=0;i<n;i++){
        let x = 0;

        switch(this.formula){
          case 'fm': {
            // x(t)=sin(2π fc t + I sin(2π fm t))
            const fc = p.fc, fm = p.fm, I = p.I;
            x = Math.sin(twoPi*fc*t + I*Math.sin(twoPi*fm*t));
            break;
          }
          case 'am': {
            // x(t)=sin(2π f1 t)*sin(2π f2 t)
            x = Math.sin(twoPi*p.f1*t) * Math.sin(twoPi*p.f2*t);
            break;
          }
          case 'logistic': {
            // logistic map as fast-changing mod source; used to modulate frequency of a sine
            // x_{n+1} = r x_n (1-x_n)
            // update at lfoHz rate (control-ish)
            const lfoStep = Math.max(1, Math.floor(sr / Math.max(1e-3, p.lfoHz)));
            if ((i % lfoStep) === 0){
              const r = p.r;
              logi = r * logi * (1 - logi);
              logi = this.clamp(logi, 0, 1);
            }
            const freq = p.base + p.depth * (logi - 0.5);
            phase += twoPi * (Math.max(0, freq) / sr);
            x = Math.sin(phase);
            break;
          }
          case 'gliss': {
            // f(t)=f0*e^{k t}
            const f = p.f0 * Math.exp(p.k * t);
            phase += twoPi * (f / sr);
            x = Math.sin(phase);
            break;
          }
          case 'additive': {
            // x(t)=sum_{n=1..N} a_n(t) sin(2π n fund t), a_n(t)=(1/n)*sin(move*t + n)
            const fund = p.fund;
            const N = Math.max(1, Math.floor(p.N));
            const move = p.move;
            let s = 0;
            for (let k=1;k<=N;k++){
              const ak = (1/k) * Math.sin(twoPi*move*t + k);
              s += ak * Math.sin(twoPi*(k*fund)*t);
            }
            // normalize a bit
            x = s * (1.0 / Math.log2(N+1));
            break;
          }
          case 'pm': {
            // x(t)=sin(2π f t + phi(t)), phi(t)=sin(sin(2π f2 t))
            const phi = Math.sin(Math.sin(twoPi*p.f2pm*t));
            x = Math.sin(twoPi*p.f*t + phi*5.0);
            break;
          }
          case 'beats': {
            // x(t)=sin(2π f t)+sin(2π (f+df) t)
            x = 0.5*(Math.sin(twoPi*p.fbeat*t) + Math.sin(twoPi*(p.fbeat + p.df)*t));
            break;
          }
          case 'dist': {
            // x(t)=tanh(alpha*sin(2π f t))
            x = Math.tanh(p.alpha * Math.sin(twoPi*p.fd*t));
            break;
          }
          case 'quasi': {
            // f(t)=fq + Aq*sin(sin(sin(wq*t)))
            const mod = Math.sin(Math.sin(Math.sin(p.wq * t)));
            const f = Math.max(0, p.fq + p.Aq*mod);
            phase += twoPi * (f / sr);
            x = Math.sin(phase);
            break;
          }
          case 'lorenz': {
            // Lorenz attractor integration at audio rate (simple Euler)
            const sigma = p.sigma, rho = p.rho, beta = p.beta;
            const dt = 1/sr;

            const dx = sigma * (ly - lx);
            const dy = lx * (rho - lz) - ly;
            const dz = lx * ly - beta * lz;

            lx += dx * dt;
            ly += dy * dt;
            lz += dz * dt;

            // Map x/y into audio
            const freq = Math.max(0, p.lBase + p.lFreqScale * Math.abs(lx));
            const amp = this.clamp(p.lAmp * (0.3 + 0.7 * (0.5 + 0.5*Math.tanh(ly))), 0, 1);

            phase += twoPi * (freq / sr);
            x = amp * Math.sin(phase);
            break;
          }
          default:
            x = 0;
        }

        ch0[i] = x * (p.gain ?? 0.2);
        t += 1/sr;

        // keep phases bounded
        if (phase > 1e9) phase %= twoPi;
        if (phase2 > 1e9) phase2 %= twoPi;
      }

      this.phase = phase;
      this.phase2 = phase2;
      this.t = t;
      this.logi = logi;
      this.lx = lx; this.ly = ly; this.lz = lz;
      return true;
    }
  }
  registerProcessor('formula-generator', FormulaGeneratorProcessor);
  `;

  // ---------- UI schema ----------
  const FORMULAS = [
    {
      id:'fm', title:'FM-синус', tag:'частотная модуляция',
      desc:'sin(2π f_c t + I sin(2π f_m t)) → от вибрато до “колоколов”.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.15},
        {k:'fc', name:'f_c (Hz)', min:20, max:2000, step:1, value:220},
        {k:'fm', name:'f_m (Hz)', min:0.1, max:60, step:0.1, value:2.0},
        {k:'I', name:'Index I', min:0, max:20, step:0.01, value:3.0},
      ]
    },
    {
      id:'am', title:'AM / биения (умножение)', tag:'амплитудная модуляция',
      desc:'sin(2π f1 t)·sin(2π f2 t) → пульсации и биения.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.15},
        {k:'f1', name:'f1 (Hz)', min:20, max:2000, step:1, value:220},
        {k:'f2', name:'f2 (Hz)', min:20, max:2000, step:1, value:221},
      ]
    },
    {
      id:'logistic', title:'Логистическое отображение', tag:'детерминированный хаос',
      desc:'xₙ₊₁ = r xₙ(1−xₙ) → используем x как модулятор частоты.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'base', name:'Base f (Hz)', min:20, max:800, step:1, value:110},
        {k:'depth', name:'Depth (Hz)', min:0, max:1200, step:1, value:330},
        {k:'r', name:'r', min:2.8, max:4.0, step:0.0001, value:3.86},
        {k:'lfoHz', name:'Update rate (Hz)', min:1, max:400, step:1, value:40},
      ]
    },
    {
      id:'gliss', title:'Экспоненциальный глиссандо', tag:'сирена / подъём',
      desc:'f(t)=f0·e^{k t} → непрерывный рост/падение высоты.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'f0', name:'f0 (Hz)', min:10, max:400, step:1, value:55},
        {k:'k', name:'k', min:-2.0, max:2.0, step:0.001, value:0.15},
      ]
    },
    {
      id:'additive', title:'Сумма гармоник', tag:'“дышащий” тембр',
      desc:'Σ aₙ(t) sin(2π n f t), aₙ(t)=(1/n)·sin(move·t+n).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'fund', name:'Fund (Hz)', min:20, max:500, step:1, value:110},
        {k:'N', name:'Harmonics N', min:1, max:40, step:1, value:12},
        {k:'move', name:'Move (Hz)', min:0.01, max:5, step:0.01, value:0.35},
      ]
    },
    {
      id:'pm', title:'Фазовая модуляция', tag:'шевелящийся спектр',
      desc:'sin(2π f t + 5·sin(sin(2π f2 t))).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'f', name:'f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'f2pm', name:'f2 (Hz)', min:0.1, max:40, step:0.1, value:3},
      ]
    },
    {
      id:'beats', title:'Два синуса (биения)', tag:'пульс/дыхание',
      desc:'sin(2π f t)+sin(2π(f+Δf)t).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'fbeat', name:'f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'df', name:'Δf (Hz)', min:0, max:20, step:0.01, value:0.8},
      ]
    },
    {
      id:'dist', title:'Нелинейная сатурация', tag:'tanh-дисторшн',
      desc:'tanh(α·sin(2π f t)) → тёплые гармоники.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'fd', name:'f (Hz)', min:20, max:2000, step:1, value:110},
        {k:'alpha', name:'α', min:0, max:10, step:0.01, value:3.0},
      ]
    },
    {
      id:'quasi', title:'Квазислучайный LFO', tag:'почти-органика',
      desc:'f(t)=fq + Aq·sin(sin(sin(w·t))).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'fq', name:'Base f (Hz)', min:20, max:500, step:1, value:120},
        {k:'Aq', name:'Depth (Hz)', min:0, max:1200, step:1, value:220},
        {k:'wq', name:'w', min:0.05, max:6, step:0.01, value:0.8},
      ]
    },
    {
      id:'lorenz', title:'Аттрактор Лоренца', tag:'хаос, но “погодный”',
      desc:'Система ОДУ (Lorenz), x→частота, y→амплитуда.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'sigma', name:'σ', min:0, max:30, step:0.01, value:10},
        {k:'rho', name:'ρ', min:0, max:60, step:0.01, value:28},
        {k:'beta', name:'β', min:0.1, max:10, step:0.0001, value:2.6667},
        {k:'lBase', name:'Base f (Hz)', min:20, max:400, step:1, value:120},
        {k:'lFreqScale', name:'Freq scale', min:0, max:200, step:0.1, value:40},
        {k:'lAmp', name:'Amp scale', min:0, max:1, step:0.001, value:0.25},
      ]
    },
  ];

  // ---------- DOM helpers ----------
  const $ = (s) => document.querySelector(s);
  const formulasRoot = $('#formulas');

  function fmt(v){
    if (Math.abs(v) >= 100) return String(Math.round(v));
    if (Math.abs(v) >= 10) return v.toFixed(2);
    return v.toFixed(3);
  }

  function makeFormulaUI(f){
    const wrap = document.createElement('div');
    wrap.className = 'formula';

    wrap.innerHTML = `
      <div class="fhead">
        <div>
          <h3><input type="checkbox" id="en_${f.id}"> ${f.title}</h3>
          <div class="muted">${f.desc}</div>
        </div>
        <div class="tag">${f.tag}</div>
      </div>
      <div id="sl_${f.id}"></div>
      <div class="sep"></div>
      <div class="row">
        <button id="reset_${f.id}" disabled>Reset state</button>
        <span class="small">Reset полезен для gliss / Lorenz / логистики, чтобы начать “сначала”.</span>
      </div>
    `;
    formulasRoot.appendChild(wrap);

    const slidersHost = wrap.querySelector(`#sl_${f.id}`);

    for (const s of f.sliders){
      const line = document.createElement('div');
      line.className = 'ctrl';
      line.innerHTML = `
        <label for="${f.id}_${s.k}">${s.name}</label>
        <input id="${f.id}_${s.k}" type="range" min="${s.min}" max="${s.max}" step="${s.step}" value="${s.value}">
        <div class="small" id="${f.id}_${s.k}_v">${fmt(Number(s.value))}</div>
      `;
      slidersHost.appendChild(line);
    }
    return wrap;
  }

  // ---------- Audio graph ----------
  let ctx = null;
  let analyser = null;
  let masterGain = null;
  let scopeRAF = null;

  const nodes = new Map(); // id -> {node, gain, params}

  function buildWorkletURL(){
    const blob = new Blob([workletCode], {type:'application/javascript'});
    return URL.createObjectURL(blob);
  }

  async function startAudio(){
    if (ctx) return;

    ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
    const url = buildWorkletURL();
    await ctx.audioWorklet.addModule(url);

    masterGain = ctx.createGain();
    masterGain.gain.value = Number($('#masterGain').value);

    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;

    // connect: masterGain -> analyser -> destination
    masterGain.connect(analyser);
    analyser.connect(ctx.destination);

    // Create generator nodes (one per formula) but initially muted/unconnected
    for (const f of FORMULAS){
      const initParams = {};
      for (const s of f.sliders) initParams[s.k] = Number(s.value);

      const aw = new AudioWorkletNode(ctx, 'formula-generator', {
        numberOfInputs: 0,
        numberOfOutputs: 1,
        outputChannelCount: [1],
        processorOptions: { formula: f.id, params: initParams }
      });

      // each formula has its own gain before master mix
      const g = ctx.createGain();
      g.gain.value = 0; // off by default

      aw.connect(g);
      g.connect(masterGain);

      nodes.set(f.id, { aw, g, params: initParams });
    }

    $('#status').textContent = 'Status: running';
    $('#stopBtn').disabled = false;
    $('#startBtn').disabled = true;

    // start scope
    startScope();
  }

  function stopAudio(){
    if (!ctx) return;
    cancelAnimationFrame(scopeRAF);
    scopeRAF = null;

    // fade out quickly to avoid clicks
    const now = ctx.currentTime;
    masterGain.gain.setTargetAtTime(0, now, 0.01);

    setTimeout(() => {
      ctx.close();
      ctx = null; analyser = null; masterGain = null;
      nodes.clear();
      $('#status').textContent = 'Status: stopped';
      $('#stopBtn').disabled = true;
      $('#startBtn').disabled = false;
    }, 80);
  }

  // ---------- Oscilloscope ----------
  const canvas = $('#scope');
  const c2d = canvas.getContext('2d');

  function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
  }
  window.addEventListener('resize', resizeCanvas);

  function startScope(){
    resizeCanvas();
    const buf = new Uint8Array(analyser.fftSize);

    const draw = () => {
      scopeRAF = requestAnimationFrame(draw);
      if (!analyser) return;

      analyser.getByteTimeDomainData(buf);

      const w = canvas.width, h = canvas.height;
      c2d.clearRect(0,0,w,h);

      // background grid
      c2d.globalAlpha = 1;
      c2d.fillStyle = '#060a0f';
      c2d.fillRect(0,0,w,h);

      c2d.strokeStyle = '#122033';
      c2d.lineWidth = 1;
      c2d.beginPath();
      for (let i=1;i<10;i++){
        const x = (w*i)/10;
        c2d.moveTo(x,0); c2d.lineTo(x,h);
      }
      for (let i=1;i<6;i++){
        const y = (h*i)/6;
        c2d.moveTo(0,y); c2d.lineTo(w,y);
      }
      c2d.stroke();

      // waveform
      const gain = Number($('#scopeGain').value);
      const mid = h/2;

      c2d.strokeStyle = '#8ab4ff';
      c2d.lineWidth = 2;
      c2d.beginPath();

      for (let i=0;i<buf.length;i++){
        const v = (buf[i] - 128) / 128; // -1..1
        const y = mid - v * (mid * 0.9) * gain;
        const x = (w * i) / (buf.length - 1);
        if (i===0) c2d.moveTo(x,y);
        else c2d.lineTo(x,y);
      }
      c2d.stroke();
    };
    draw();
  }

  // ---------- Wire up global controls ----------
  $('#startBtn').addEventListener('click', startAudio);
  $('#stopBtn').addEventListener('click', stopAudio);

  $('#masterGain').addEventListener('input', (e)=>{
    const v = Number(e.target.value);
    $('#masterGainVal').textContent = v.toFixed(3);
    if (masterGain) masterGain.gain.value = v;
  });
  $('#scopeGain').addEventListener('input', (e)=>{
    const v = Number(e.target.value);
    $('#scopeGainVal').textContent = v.toFixed(2);
  });

  // ---------- Build formula UIs + connect to audio nodes ----------
  for (const f of FORMULAS){
    makeFormulaUI(f);

    const en = document.getElementById(`en_${f.id}`);
    const resetBtn = document.getElementById(`reset_${f.id}`);

    en.addEventListener('change', () => {
      if (!ctx) { en.checked = false; return; }
      const st = nodes.get(f.id);
      const on = en.checked;

      // Smooth fade
      const now = ctx.currentTime;
      st.g.gain.cancelScheduledValues(now);
      st.g.gain.setTargetAtTime(on ? (st.params.gain ?? 0.15) : 0, now, 0.02);

      resetBtn.disabled = !on;
    });

    resetBtn.addEventListener('click', () => {
      if (!ctx) return;
      const st = nodes.get(f.id);
      st.aw.port.postMessage({type:'reset'});
    });

    for (const s of f.sliders){
      const slider = document.getElementById(`${f.id}_${s.k}`);
      const val = document.getElementById(`${f.id}_${s.k}_v`);

      slider.addEventListener('input', () => {
        const v = Number(slider.value);
        val.textContent = fmt(v);

        if (!ctx) return;
        const st = nodes.get(f.id);

        st.params[s.k] = v;

        // If gain changes, also update the gain node target (so UI gain immediately affects loudness)
        if (s.k === 'gain'){
          const now = ctx.currentTime;
          if (document.getElementById(`en_${f.id}`).checked){
            st.g.gain.cancelScheduledValues(now);
            st.g.gain.setTargetAtTime(v, now, 0.02);
          }
        }

        // Send to worklet
        st.aw.port.postMessage({type:'set', params: {[s.k]: v}});
      });
    }
  }

})();
</script>
</body>
</html>
