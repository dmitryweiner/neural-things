<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Formula Audio Lab</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color-scheme: dark; }
    body { margin: 0; background:#0b0f14; color:#e8eef6; }

    /* --- Sticky top panel --- */
    .topbar {
      position: sticky;
      top: 0;
      z-index: 20;
      background:#0d131b;
      border-bottom: 1px solid #1d2a3a;
      padding: 12px 14px;
    }
    .topbar h1 { margin: 0 0 8px; font-size: 16px; font-weight: 750; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items:center; }
    button {
      background:#1d3557; color:#fff; border:0; padding:9px 11px;
      border-radius:10px; cursor:pointer; font-weight:650;
    }
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill {
      padding:6px 10px; border-radius:999px; background:#0f1b29;
      border:1px solid #1d2a3a; font-size:12px; color:#bcd0e6;
      white-space: nowrap;
    }

    .topgrid{
      display:grid;
      grid-template-columns: 1fr 320px;
      gap: 12px;
      align-items: center;
      margin-top: 8px;
    }
    @media (max-width: 980px){
      .topgrid{ grid-template-columns: 1fr; }
    }

    .scopeWrap{
      border:1px solid #1d2a3a;
      border-radius: 12px;
      background:#060a0f;
      padding: 8px;
    }
    canvas { width:100%; height: 120px; display:block; border-radius: 10px; }
    .ctrl { display:grid; grid-template-columns: 130px 1fr 70px; gap: 10px; align-items: center; margin-top: 8px;}
    .ctrl label { font-size: 12px; color:#cfe1ff; }
    input[type="range"] { width: 100%; }
    input[type="checkbox"] { transform: scale(1.15); }
    select {
      background:#0f1b29; color:#e8eef6;
      border:1px solid #1d2a3a; border-radius:10px;
      padding: 8px 10px;
    }
    .small { font-size: 11px; color:#9fb6d3; }
    .muted { color:#9fb6d3; font-size: 12px; line-height: 1.35; }

    /* Effects panel */
    .effectsToggleRow{ margin-top: 8px; }
    .effectsPanel{
      margin-top: 10px;
      border:1px solid #1d2a3a;
      border-radius: 14px;
      padding: 12px;
      background:#0b1119;
      display:none;
    }
    .effectsPanel.open{ display:block; }
    .effectsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 980px){
      .effectsGrid{ grid-template-columns: 1fr; }
    }
    .fxCard{
      background:#0d131b;
      border:1px solid #1d2a3a;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
    }
    .fxCard h2 { margin: 0 0 8px; font-size: 13px; color:#d9e7ff; display:flex; justify-content:space-between; align-items:center; }
    .sep { height:1px; background:#1d2a3a; margin: 10px 0; }

    /* Main layout */
    main { padding: 14px; max-width: 1200px; margin: 0 auto; }
    .card {
      background:#0d131b; border: 1px solid #1d2a3a; border-radius: 14px;
      padding: 14px; box-shadow: 0 10px 24px rgba(0,0,0,.25);
      margin-top: 14px;
    }
    .card h2 { margin:0 0 10px; font-size:14px; color:#d9e7ff;}

    .formula { border-top:1px solid #1d2a3a; padding-top: 12px; margin-top: 12px; }
    .formula:first-child { border-top:0; padding-top:0; margin-top:0; }
    .fhead { display:flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    .fhead h3 { margin:0; font-size: 13px; display:flex; align-items:center; gap:10px; }
    .tag { font-size: 11px; color:#bcd0e6; background:#0f1b29; border:1px solid #1d2a3a; padding:3px 8px; border-radius: 999px; }
    .factions{ display:flex; gap: 8px; align-items:center; flex-wrap:wrap; }
    .collapseBtn{
      background:#0f1b29;
      border:1px solid #1d2a3a;
      color:#cfe1ff;
      padding:6px 10px;
      border-radius: 999px;
      font-weight:650;
      cursor:pointer;
    }
    .fbody{ margin-top: 10px; }
    .fbody.collapsed{ display:none; }
  </style>
</head>

<body>

<!-- Sticky top panel with oscilloscope + global effects -->
<section class="topbar">
  <h1>Formula Audio Lab — формулы как звук</h1>

  <div class="row">
    <button id="startBtn">Start Audio</button>
    <button id="stopBtn" disabled>Stop</button>
    <span class="pill" id="status">Status: not started</span>
    <span class="pill" id="scopeInfo">Scope: auto</span>
    <button id="effectsBtn" class="collapseBtn" type="button">Effects ▾</button>
  </div>

  <div class="topgrid">
    <div class="scopeWrap">
      <canvas id="scope"></canvas>
      <div class="ctrl">
        <label>Master volume</label>
        <input id="masterGain" type="range" min="0" max="1" step="0.001" value="0.25">
        <div class="small" id="masterGainVal">0.25</div>
      </div>
      <div class="muted">
        Осциллограф всегда сверху и сам подбирает масштаб по Y. Если слышен клиппинг — включи Limiter в Effects или убавь громкости.
      </div>
    </div>

    <div class="muted">
      Подсказка: включай несколько формул одновременно. Для “Экспоненциального глиссандо” и “Лоренца” кнопка Reset даёт классные перезапуски.
      <div class="sep"></div>
      <div class="small">Лучшие сочетания: <b>Lorenz + Reverb</b>, <b>Additive + Chorus</b>, <b>Karplus + Filter</b>.</div>
    </div>
  </div>

  <!-- Collapsible effects panel -->
  <div id="effectsPanel" class="effectsPanel">
    <div class="effectsGrid">

      <div class="fxCard">
        <h2>
          <span>Filter (Biquad)</span>
          <label class="small"><input id="fxFilterOn" type="checkbox"> ON</label>
        </h2>
        <div class="ctrl">
          <label>Type</label>
          <select id="fxFilterType">
            <option value="lowpass">Low-pass</option>
            <option value="highpass">High-pass</option>
            <option value="bandpass">Band-pass</option>
          </select>
          <div></div>
        </div>
        <div class="ctrl">
          <label>Cutoff (Hz)</label>
          <input id="fxFilterFreq" type="range" min="20" max="18000" step="1" value="12000">
          <div class="small" id="fxFilterFreqVal">12000</div>
        </div>
        <div class="ctrl">
          <label>Q</label>
          <input id="fxFilterQ" type="range" min="0.1" max="30" step="0.1" value="0.7">
          <div class="small" id="fxFilterQVal">0.7</div>
        </div>
      </div>

      <div class="fxCard">
        <h2>
          <span>Chorus / Flanger</span>
          <label class="small"><input id="fxChorusOn" type="checkbox"> ON</label>
        </h2>
        <div class="ctrl">
          <label>Mode</label>
          <select id="fxChorusMode">
            <option value="chorus">Chorus</option>
            <option value="flanger">Flanger</option>
          </select>
          <div></div>
        </div>
        <div class="ctrl">
          <label>Rate (Hz)</label>
          <input id="fxChorusRate" type="range" min="0.01" max="8" step="0.01" value="0.35">
          <div class="small" id="fxChorusRateVal">0.35</div>
        </div>
        <div class="ctrl">
          <label>Depth (ms)</label>
          <input id="fxChorusDepth" type="range" min="0" max="20" step="0.1" value="6">
          <div class="small" id="fxChorusDepthVal">6.0</div>
        </div>
        <div class="ctrl">
          <label>Mix (dry↔wet)</label>
          <input id="fxChorusMix" type="range" min="0" max="1" step="0.001" value="0.35">
          <div class="small" id="fxChorusMixVal">0.35</div>
        </div>
        <div class="ctrl">
          <label>Feedback</label>
          <input id="fxChorusFb" type="range" min="0" max="0.95" step="0.001" value="0.15">
          <div class="small" id="fxChorusFbVal">0.15</div>
        </div>
      </div>

      <div class="fxCard">
        <h2>
          <span>Reverb (Convolver)</span>
          <label class="small"><input id="fxReverbOn" type="checkbox"> ON</label>
        </h2>
        <div class="ctrl">
          <label>Decay (s)</label>
          <input id="fxReverbDecay" type="range" min="0.1" max="8" step="0.1" value="2.8">
          <div class="small" id="fxReverbDecayVal">2.8</div>
        </div>
        <div class="ctrl">
          <label>Mix (dry↔wet)</label>
          <input id="fxReverbMix" type="range" min="0" max="1" step="0.001" value="0.25">
          <div class="small" id="fxReverbMixVal">0.25</div>
        </div>
        <div class="small muted">Импульс генерируется на лету (шум с экспоненциальным спадом) — быстро и довольно музыкально.</div>
      </div>

      <div class="fxCard">
        <h2>
          <span>Limiter (anti-clip)</span>
          <label class="small"><input id="fxLimiterOn" type="checkbox"> ON</label>
        </h2>
        <div class="ctrl">
          <label>Threshold (dB)</label>
          <input id="fxLimiterThr" type="range" min="-40" max="0" step="0.5" value="-12">
          <div class="small" id="fxLimiterThrVal">-12</div>
        </div>
        <div class="ctrl">
          <label>Release (s)</label>
          <input id="fxLimiterRel" type="range" min="0.02" max="1" step="0.01" value="0.15">
          <div class="small" id="fxLimiterRelVal">0.15</div>
        </div>
        <div class="small muted">Это DynamicsCompressor с большим ratio. Очень полезно, когда миксуешь 3–5 формул.</div>
      </div>

    </div>
  </div>
</section>

<main>
  <section class="card">
    <h2>Формулы (можно включать одновременно)</h2>
    <div id="formulas"></div>
  </section>
</main>

<script>
(async function(){
  // ---------- AudioWorklet code (inline module) ----------
  const workletCode = `
  class FormulaGeneratorProcessor extends AudioWorkletProcessor {
    constructor(options){
      super();
      const o = (options && options.processorOptions) || {};
      this.formula = o.formula || 'fm';

      this.sr = sampleRate;
      this.t = 0;
      this.phase = 0;

      // logistic
      this.logi = 0.33;

      // Lorenz
      this.lx = 0.1; this.ly = 0.0; this.lz = 0.0;

      // Karplus-Strong
      this.ksBuf = null;
      this.ksIdx = 0;
      this.ksN = 0;

      // Noise LP
      this.nlp = 0;

      // Bitcrusher
      this.bcHold = 0;
      this.bcCount = 0;

      this.p = Object.assign({
        gain: 0.2,

        // fm
        fc: 220, fm: 2, I: 2,

        // am
        f1: 220, f2: 221,

        // logistic
        base: 110, depth: 330, r: 3.86, lfoHz: 40,

        // gliss
        f0: 55, k: 0.15,

        // additive
        fund: 110, N: 12, move: 0.35,

        // phase modulation
        f: 220, f2pm: 3,

        // beats
        fbeat: 220, df: 0.8,

        // distortion
        fd: 110, alpha: 3.0,

        // quasi LFO
        fq: 120, Aq: 220, wq: 0.8,

        // lorenz
        sigma: 10, rho: 28, beta: 2.6667,
        lBase: 120, lFreqScale: 40, lAmp: 0.25,

        // karplus-strong
        ksFreq: 110,
        ksDamp: 0.985,
        ksBright: 0.5,

        // bitcrusher
        bcFreq: 220,
        bcBits: 6,
        bcDown: 8,

        // noise lowpass
        nCut: 800
      }, o.params || {});

      this.port.onmessage = (e) => {
        const msg = e.data || {};
        if (msg.type === 'set') {
          for (const [k,v] of Object.entries(msg.params || {})) {
            this.p[k] = v;
          }
        } else if (msg.type === 'reset') {
          this.t = 0; this.phase = 0;
          this.logi = 0.33;
          this.lx = 0.1; this.ly = 0.0; this.lz = 0.0;

          this.nlp = 0;
          this.bcHold = 0; this.bcCount = 0;

          this._initKS(true); // re-pluck
        }
      };

      this._initKS(true);
    }

    clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    _initKS(force){
      const p = this.p;
      const freq = Math.max(20, p.ksFreq || 110);
      const N = Math.max(2, Math.floor(this.sr / freq));
      if (!force && this.ksBuf && this.ksN === N) return;

      this.ksN = N;
      this.ksBuf = new Float32Array(N);
      this.ksIdx = 0;

      for (let i=0;i<N;i++){
        this.ksBuf[i] = (Math.random()*2 - 1);
      }
    }

    process(inputs, outputs){
      const out = outputs[0];
      const ch0 = out[0];
      const n = ch0.length;
      const sr = this.sr;
      const twoPi = 2*Math.PI;

      let p = this.p;
      let phase = this.phase;
      let t = this.t;
      let logi = this.logi;
      let lx = this.lx, ly = this.ly, lz = this.lz;

      let nlp = this.nlp;
      let bcHold = this.bcHold;
      let bcCount = this.bcCount;

      for (let i=0;i<n;i++){
        let x = 0;

        switch(this.formula){
          case 'fm': {
            x = Math.sin(twoPi*p.fc*t + (p.I)*Math.sin(twoPi*p.fm*t));
            break;
          }
          case 'am': {
            x = Math.sin(twoPi*p.f1*t) * Math.sin(twoPi*p.f2*t);
            break;
          }
          case 'logistic': {
            const lfoStep = Math.max(1, Math.floor(sr / Math.max(1e-3, p.lfoHz)));
            if ((i % lfoStep) === 0){
              logi = (p.r) * logi * (1 - logi);
              logi = this.clamp(logi, 0, 1);
            }
            const freq = p.base + p.depth * (logi - 0.5);
            phase += twoPi * (Math.max(0, freq) / sr);
            x = Math.sin(phase);
            break;
          }
          case 'gliss': {
            const f = p.f0 * Math.exp(p.k * t);
            phase += twoPi * (f / sr);
            x = Math.sin(phase);
            break;
          }
          case 'additive': {
            const fund = p.fund;
            const N = Math.max(1, Math.floor(p.N));
            const move = p.move;
            let s = 0;
            for (let k=1;k<=N;k++){
              const ak = (1/k) * Math.sin(twoPi*move*t + k);
              s += ak * Math.sin(twoPi*(k*fund)*t);
            }
            x = s * (1.0 / Math.log2(N+1));
            break;
          }
          case 'pm': {
            const phi = Math.sin(Math.sin(twoPi*p.f2pm*t));
            x = Math.sin(twoPi*p.f*t + phi*5.0);
            break;
          }
          case 'beats': {
            x = 0.5*(Math.sin(twoPi*p.fbeat*t) + Math.sin(twoPi*(p.fbeat + p.df)*t));
            break;
          }
          case 'dist': {
            x = Math.tanh(p.alpha * Math.sin(twoPi*p.fd*t));
            break;
          }
          case 'quasi': {
            const mod = Math.sin(Math.sin(Math.sin(p.wq * t)));
            const f = Math.max(0, p.fq + p.Aq*mod);
            phase += twoPi * (f / sr);
            x = Math.sin(phase);
            break;
          }
          case 'lorenz': {
            const sigma = p.sigma, rho = p.rho, beta = p.beta;
            const dt = 1/sr;

            const dx = sigma * (ly - lx);
            const dy = lx * (rho - lz) - ly;
            const dz = lx * ly - beta * lz;

            lx += dx * dt;
            ly += dy * dt;
            lz += dz * dt;

            const freq = Math.max(0, p.lBase + p.lFreqScale * Math.abs(lx));
            const amp = this.clamp(p.lAmp * (0.3 + 0.7 * (0.5 + 0.5*Math.tanh(ly))), 0, 1);

            phase += twoPi * (freq / sr);
            x = amp * Math.sin(phase);
            break;
          }
          case 'karplus': {
            this._initKS(false);
            const buf = this.ksBuf;
            const N = this.ksN;
            let idx = this.ksIdx;

            const y0 = buf[idx];
            const y1 = buf[(idx + 1) % N];

            const damp = this.clamp(p.ksDamp, 0.8, 0.99999);
            const bright = this.clamp(p.ksBright, 0, 1);

            const avg = 0.5 * (y0 + y1);
            const next = damp * (bright * y0 + (1 - bright) * avg);

            buf[idx] = next;
            this.ksIdx = (idx + 1) % N;
            x = y0;
            break;
          }
          case 'bitcrush': {
            const f = Math.max(0, p.bcFreq);
            phase += twoPi * (f / sr);
            const raw = Math.sin(phase);

            const down = Math.max(1, Math.floor(p.bcDown));
            if (bcCount <= 0) {
              bcCount = down;
              const bits = this.clamp(Math.floor(p.bcBits), 1, 16);
              const levels = Math.pow(2, bits - 1);
              bcHold = Math.round(raw * levels) / levels;
            }
            bcCount--;
            x = bcHold;
            break;
          }
          case 'noiselp': {
            const white = (Math.random()*2 - 1);
            const cut = this.clamp(p.nCut, 20, 18000);
            const a = 1 - Math.exp(-2*Math.PI*cut/sr);
            nlp = nlp + a * (white - nlp);
            x = nlp;
            break;
          }
          default:
            x = 0;
        }

        ch0[i] = x * (p.gain ?? 0.2);
        t += 1/sr;
        if (phase > 1e9) phase %= twoPi;
      }

      this.phase = phase;
      this.t = t;
      this.logi = logi;
      this.lx = lx; this.ly = ly; this.lz = lz;
      this.nlp = nlp;
      this.bcHold = bcHold; this.bcCount = bcCount;

      return true;
    }
  }
  registerProcessor('formula-generator', FormulaGeneratorProcessor);
  `;

  // ---------- UI schema ----------
  const FORMULAS = [
    {
      id:'fm', title:'FM-синус', tag:'частотная модуляция',
      desc:'sin(2π f_c t + I sin(2π f_m t)) → от вибрато до “колоколов”.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.15},
        {k:'fc', name:'f_c (Hz)', min:20, max:2000, step:1, value:220},
        {k:'fm', name:'f_m (Hz)', min:0.1, max:60, step:0.1, value:2.0},
        {k:'I', name:'Index I', min:0, max:20, step:0.01, value:3.0},
      ]
    },
    {
      id:'am', title:'AM / биения (умножение)', tag:'амплитудная модуляция',
      desc:'sin(2π f1 t)·sin(2π f2 t) → пульсации и биения.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.15},
        {k:'f1', name:'f1 (Hz)', min:20, max:2000, step:1, value:220},
        {k:'f2', name:'f2 (Hz)', min:20, max:2000, step:1, value:221},
      ]
    },
    {
      id:'logistic', title:'Логистическое отображение', tag:'детерминированный хаос',
      desc:'xₙ₊₁ = r xₙ(1−xₙ) → используем x как модулятор частоты.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'base', name:'Base f (Hz)', min:20, max:800, step:1, value:110},
        {k:'depth', name:'Depth (Hz)', min:0, max:1200, step:1, value:330},
        {k:'r', name:'r', min:2.8, max:4.0, step:0.0001, value:3.86},
        {k:'lfoHz', name:'Update rate (Hz)', min:1, max:400, step:1, value:40},
      ]
    },
    {
      id:'gliss', title:'Экспоненциальный глиссандо', tag:'сирена / подъём',
      desc:'f(t)=f0·e^{k t} → непрерывный рост/падение высоты.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'f0', name:'f0 (Hz)', min:10, max:400, step:1, value:55},
        {k:'k', name:'k', min:-2.0, max:2.0, step:0.001, value:0.15},
      ]
    },
    {
      id:'additive', title:'Сумма гармоник', tag:'“дышащий” тембр',
      desc:'Σ aₙ(t) sin(2π n f t), aₙ(t)=(1/n)·sin(move·t+n).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'fund', name:'Fund (Hz)', min:20, max:500, step:1, value:110},
        {k:'N', name:'Harmonics N', min:1, max:40, step:1, value:12},
        {k:'move', name:'Move (Hz)', min:0.01, max:5, step:0.01, value:0.35},
      ]
    },
    {
      id:'pm', title:'Фазовая модуляция', tag:'шевелящийся спектр',
      desc:'sin(2π f t + 5·sin(sin(2π f2 t))).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'f', name:'f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'f2pm', name:'f2 (Hz)', min:0.1, max:40, step:0.1, value:3},
      ]
    },
    {
      id:'beats', title:'Два синуса (биения)', tag:'пульс/дыхание',
      desc:'sin(2π f t)+sin(2π(f+Δf)t).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'fbeat', name:'f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'df', name:'Δf (Hz)', min:0, max:20, step:0.01, value:0.8},
      ]
    },
    {
      id:'dist', title:'Нелинейная сатурация', tag:'tanh-дисторшн',
      desc:'tanh(α·sin(2π f t)) → тёплые гармоники.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'fd', name:'f (Hz)', min:20, max:2000, step:1, value:110},
        {k:'alpha', name:'α', min:0, max:10, step:0.01, value:3.0},
      ]
    },
    {
      id:'quasi', title:'Квазислучайный LFO', tag:'почти-органика',
      desc:'f(t)=fq + Aq·sin(sin(sin(w·t))).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'fq', name:'Base f (Hz)', min:20, max:500, step:1, value:120},
        {k:'Aq', name:'Depth (Hz)', min:0, max:1200, step:1, value:220},
        {k:'wq', name:'w', min:0.05, max:6, step:0.01, value:0.8},
      ]
    },
    {
      id:'lorenz', title:'Аттрактор Лоренца', tag:'хаос, но “погодный”',
      desc:'Система ОДУ (Lorenz), x→частота, y→амплитуда.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'sigma', name:'σ', min:0, max:30, step:0.01, value:10},
        {k:'rho', name:'ρ', min:0, max:60, step:0.01, value:28},
        {k:'beta', name:'β', min:0.1, max:10, step:0.0001, value:2.6667},
        {k:'lBase', name:'Base f (Hz)', min:20, max:400, step:1, value:120},
        {k:'lFreqScale', name:'Freq scale', min:0, max:200, step:0.1, value:40},
        {k:'lAmp', name:'Amp scale', min:0, max:1, step:0.001, value:0.25},
      ]
    },
    {
      id:'karplus', title:'Karplus–Strong (струна)', tag:'физ. моделирование',
      desc:'Шум в delay-линии + усреднение + затухание → “щипок струны”. Reset = “пере-щипнуть”.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.14},
        {k:'ksFreq', name:'Freq (Hz)', min:40, max:880, step:1, value:110},
        {k:'ksDamp', name:'Damping', min:0.90, max:0.9999, step:0.0001, value:0.985},
        {k:'ksBright', name:'Brightness', min:0, max:1, step:0.001, value:0.5},
      ]
    },
    {
      id:'bitcrush', title:'Bitcrusher / Downsample', tag:'lo-fi цифровая грязь',
      desc:'Квантизация по битам + удержание сэмпла N раз → “8-bit / gameboy”.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'bcFreq', name:'Input f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'bcBits', name:'Bits', min:1, max:16, step:1, value:6},
        {k:'bcDown', name:'Downsample', min:1, max:64, step:1, value:8},
      ]
    },
    {
      id:'noiselp', title:'Noise → Low-pass', tag:'шум/ветер/океан',
      desc:'Белый шум через 1-pole LPF: y += a(x−y), a=1−e^{−2πfc/sr}.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'nCut', name:'Cutoff (Hz)', min:20, max:18000, step:1, value:800},
      ]
    },
  ];

  // ---------- DOM helpers ----------
  const $ = (s) => document.querySelector(s);
  const formulasRoot = $('#formulas');

  function fmt(v){
    if (Math.abs(v) >= 100) return String(Math.round(v));
    if (Math.abs(v) >= 10) return v.toFixed(2);
    return v.toFixed(3);
  }

  function makeFormulaUI(f){
    const wrap = document.createElement('div');
    wrap.className = 'formula';

    wrap.innerHTML = `
      <div class="fhead">
        <div>
          <h3>
            <input type="checkbox" id="en_${f.id}">
            ${f.title}
          </h3>
          <div class="muted">${f.desc}</div>
        </div>
        <div class="factions">
          <span class="tag">${f.tag}</span>
          <button class="collapseBtn" id="col_${f.id}" type="button">Свернуть</button>
        </div>
      </div>

      <div class="fbody" id="body_${f.id}">
        <div id="sl_${f.id}"></div>
        <div class="sep"></div>
        <div class="row">
          <button id="reset_${f.id}" disabled>Reset state</button>
          <span class="small">Reset полезен для gliss / Lorenz / логистики / Karplus.</span>
        </div>
      </div>
    `;
    formulasRoot.appendChild(wrap);

    const slidersHost = wrap.querySelector(`#sl_${f.id}`);
    for (const s of f.sliders){
      const line = document.createElement('div');
      line.className = 'ctrl';
      line.innerHTML = `
        <label for="${f.id}_${s.k}">${s.name}</label>
        <input id="${f.id}_${s.k}" type="range" min="${s.min}" max="${s.max}" step="${s.step}" value="${s.value}">
        <div class="small" id="${f.id}_${s.k}_v">${fmt(Number(s.value))}</div>
      `;
      slidersHost.appendChild(line);
    }
    return wrap;
  }

  // ---------- Audio graph ----------
  let ctx = null;
  let analyser = null;

  let mixBus = null;        // sum of formulas
  let masterGain = null;    // master volume

  // FX nodes
  let fxInput = null;
  let filterNode = null;

  let chorusDelay = null;
  let chorusLFO = null;
  let chorusLFOGain = null;
  let chorusDry = null;
  let chorusWet = null;
  let chorusFb = null;

  let reverbConv = null;
  let reverbDry = null;
  let reverbWet = null;

  let limiter = null;

  let scopeRAF = null;
  const nodes = new Map(); // id -> {aw, g, params}

  function buildWorkletURL(){
    const blob = new Blob([workletCode], {type:'application/javascript'});
    return URL.createObjectURL(blob);
  }

  function makeImpulseResponse(ctx, seconds, decay){
    const sr = ctx.sampleRate;
    const len = Math.max(1, Math.floor(sr * seconds));
    const buf = ctx.createBuffer(2, len, sr);
    for (let ch=0; ch<2; ch++){
      const data = buf.getChannelData(ch);
      for (let i=0; i<len; i++){
        const t = i / sr;
        const env = Math.exp(-t / Math.max(1e-3, decay));
        data[i] = (Math.random()*2 - 1) * env;
      }
    }
    return buf;
  }

  function setFXEnabled(){
    if (!ctx) return;

    const filterOn = $('#fxFilterOn').checked;
    const chorusOn = $('#fxChorusOn').checked;
    const reverbOn = $('#fxReverbOn').checked;
    const limiterOn = $('#fxLimiterOn').checked;

    // We rebuild routing cheaply by disconnecting and reconnecting a known chain.
    // Base: fxInput -> ... -> masterGain -> analyser -> destination
    fxInput.disconnect();
    filterNode.disconnect();
    chorusDry.disconnect(); chorusWet.disconnect();
    chorusDelay.disconnect(); chorusFb.disconnect();
    reverbDry.disconnect(); reverbWet.disconnect(); reverbConv.disconnect();
    limiter.disconnect();
    masterGain.disconnect();
    analyser.disconnect();

    // Always end with analyser->destination
    analyser.connect(ctx.destination);

    let node = fxInput;

    // Filter
    if (filterOn) {
      node.connect(filterNode);
      node = filterNode;
    }

    // Chorus/Flanger (parallel dry/wet with feedback)
    if (chorusOn) {
      node.connect(chorusDry);
      node.connect(chorusDelay);

      // feedback loop: delay -> fbGain -> delay
      chorusDelay.connect(chorusFb);
      chorusFb.connect(chorusDelay);

      // wet path
      chorusDelay.connect(chorusWet);

      // sum: dry+wet into "chorusSum" (we'll use masterGain as sum input by connecting both into it later)
      // Route: dry/wet -> (reverb stage input) or to next
      // We'll create a temporary gain as sum point:
      const chorusSum = ctx.createGain();
      chorusSum.gain.value = 1;
      chorusDry.connect(chorusSum);
      chorusWet.connect(chorusSum);
      node = chorusSum;

      // store so we can GC later (simple: keep reference on node)
      node.__tmpChorusSum = chorusSum;
    } else {
      // ensure no stray connections
      // (already disconnected above)
    }

    // Reverb (parallel dry/wet)
    if (reverbOn) {
      node.connect(reverbDry);
      node.connect(reverbConv);

      reverbConv.connect(reverbWet);

      const revSum = ctx.createGain();
      revSum.gain.value = 1;

      reverbDry.connect(revSum);
      reverbWet.connect(revSum);

      node = revSum;
      node.__tmpRevSum = revSum;
    }

    // Limiter
    if (limiterOn) {
      node.connect(limiter);
      node = limiter;
    }

    // Master
    node.connect(masterGain);
    masterGain.connect(analyser);
  }

  function updateFXParams(){
    if (!ctx) return;
    // Filter params
    filterNode.type = $('#fxFilterType').value;
    const ff = Number($('#fxFilterFreq').value);
    const fq = Number($('#fxFilterQ').value);
    filterNode.frequency.setValueAtTime(ff, ctx.currentTime);
    filterNode.Q.setValueAtTime(fq, ctx.currentTime);
    $('#fxFilterFreqVal').textContent = String(ff);
    $('#fxFilterQVal').textContent = fq.toFixed(1);

    // Chorus/flanger params
    const mode = $('#fxChorusMode').value;
    const rate = Number($('#fxChorusRate').value);
    const depthMs = Number($('#fxChorusDepth').value);
    const mix = Number($('#fxChorusMix').value);
    const fb = Number($('#fxChorusFb').value);

    // Base delay differs by mode:
    const baseMs = (mode === 'flanger') ? 2.0 : 12.0; // chorus feels wider with larger base
    chorusDelay.delayTime.setValueAtTime(baseMs / 1000, ctx.currentTime);

    // LFO depth in seconds
    chorusLFO.frequency.setValueAtTime(rate, ctx.currentTime);
    chorusLFOGain.gain.setValueAtTime(depthMs / 1000, ctx.currentTime);

    // Dry/wet
    chorusDry.gain.setValueAtTime(1 - mix, ctx.currentTime);
    chorusWet.gain.setValueAtTime(mix, ctx.currentTime);

    // Feedback
    chorusFb.gain.setValueAtTime(fb, ctx.currentTime);

    $('#fxChorusRateVal').textContent = rate.toFixed(2);
    $('#fxChorusDepthVal').textContent = depthMs.toFixed(1);
    $('#fxChorusMixVal').textContent = mix.toFixed(2);
    $('#fxChorusFbVal').textContent = fb.toFixed(2);

    // Reverb
    const decay = Number($('#fxReverbDecay').value);
    const rMix = Number($('#fxReverbMix').value);
    $('#fxReverbDecayVal').textContent = decay.toFixed(1);
    $('#fxReverbMixVal').textContent = rMix.toFixed(2);

    reverbDry.gain.setValueAtTime(1 - rMix, ctx.currentTime);
    reverbWet.gain.setValueAtTime(rMix, ctx.currentTime);

    // Regenerate impulse (cheap enough for this UI)
    // Use length proportional to decay but clamp
    const seconds = Math.min(6.0, Math.max(0.3, decay * 1.4));
    reverbConv.buffer = makeImpulseResponse(ctx, seconds, decay);

    // Limiter
    const thr = Number($('#fxLimiterThr').value);
    const rel = Number($('#fxLimiterRel').value);
    $('#fxLimiterThrVal').textContent = thr.toFixed(1);
    $('#fxLimiterRelVal').textContent = rel.toFixed(2);

    limiter.threshold.setValueAtTime(thr, ctx.currentTime);
    limiter.ratio.setValueAtTime(20, ctx.currentTime);
    limiter.attack.setValueAtTime(0.003, ctx.currentTime);
    limiter.release.setValueAtTime(rel, ctx.currentTime);
    limiter.knee.setValueAtTime(0, ctx.currentTime);
  }

  async function startAudio(){
    if (ctx) return;

    ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
    const url = buildWorkletURL();
    await ctx.audioWorklet.addModule(url);

    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;

    // Mix bus for formulas
    mixBus = ctx.createGain();
    mixBus.gain.value = 1;

    // FX input is mixBus
    fxInput = mixBus;

    // Create FX nodes (always exist; routing toggles connect/disconnect)
    filterNode = ctx.createBiquadFilter();
    filterNode.type = 'lowpass';

    // Chorus/flanger building blocks
    chorusDelay = ctx.createDelay(0.2);
    chorusDry = ctx.createGain();
    chorusWet = ctx.createGain();
    chorusFb = ctx.createGain();
    chorusFb.gain.value = 0;

    // LFO -> delayTime
    chorusLFO = ctx.createOscillator();
    chorusLFOGain = ctx.createGain();
    chorusLFO.connect(chorusLFOGain);
    chorusLFOGain.connect(chorusDelay.delayTime);
    chorusLFO.start();

    // Reverb
    reverbConv = ctx.createConvolver();
    reverbDry = ctx.createGain();
    reverbWet = ctx.createGain();

    // Limiter
    limiter = ctx.createDynamicsCompressor();

    // Master gain -> analyser -> destination
    masterGain = ctx.createGain();
    masterGain.gain.value = Number($('#masterGain').value);

    // Connect default chain once (based on UI toggles)
    setFXEnabled();
    updateFXParams();

    // Create generator nodes
    for (const f of FORMULAS){
      const initParams = {};
      for (const s of f.sliders) initParams[s.k] = Number(s.value);

      const aw = new AudioWorkletNode(ctx, 'formula-generator', {
        numberOfInputs: 0,
        numberOfOutputs: 1,
        outputChannelCount: [1],
        processorOptions: { formula: f.id, params: initParams }
      });

      const g = ctx.createGain();
      g.gain.value = 0;

      aw.connect(g);
      g.connect(mixBus);

      nodes.set(f.id, { aw, g, params: initParams });
    }

    $('#status').textContent = 'Status: running';
    $('#stopBtn').disabled = false;
    $('#startBtn').disabled = true;

    startScope();
  }

  function stopAudio(){
    if (!ctx) return;

    cancelAnimationFrame(scopeRAF);
    scopeRAF = null;

    const now = ctx.currentTime;
    masterGain.gain.setTargetAtTime(0, now, 0.01);

    setTimeout(() => {
      try { chorusLFO.stop(); } catch {}
      ctx.close();
      ctx = null;
      nodes.clear();
      analyser = null;
      $('#status').textContent = 'Status: stopped';
      $('#stopBtn').disabled = true;
      $('#startBtn').disabled = false;
      $('#scopeInfo').textContent = 'Scope: auto';
    }, 80);
  }

  // ---------- Oscilloscope (auto Y scale) ----------
  const canvas = $('#scope');
  const c2d = canvas.getContext('2d');
  let scopeAutoGain = 1.0;

  function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
  }
  window.addEventListener('resize', resizeCanvas);

  function startScope(){
    resizeCanvas();
    const buf = new Uint8Array(analyser.fftSize);

    const draw = () => {
      scopeRAF = requestAnimationFrame(draw);
      if (!analyser) return;

      analyser.getByteTimeDomainData(buf);

      let peak = 1e-4;
      for (let i=0;i<buf.length;i++){
        const v = (buf[i] - 128) / 128;
        const a = Math.abs(v);
        if (a > peak) peak = a;
      }

      let target = 0.85 / peak;
      target = Math.max(0.25, Math.min(12.0, target));
      scopeAutoGain += (target - scopeAutoGain) * 0.08;

      $('#scopeInfo').textContent = `Scope: auto ×${scopeAutoGain.toFixed(2)} (peak ${peak.toFixed(3)})`;

      const w = canvas.width, h = canvas.height;
      c2d.clearRect(0,0,w,h);

      c2d.fillStyle = '#060a0f';
      c2d.fillRect(0,0,w,h);

      // grid
      c2d.strokeStyle = '#122033';
      c2d.lineWidth = 1;
      c2d.beginPath();
      for (let i=1;i<10;i++){
        const x = (w*i)/10;
        c2d.moveTo(x,0); c2d.lineTo(x,h);
      }
      for (let i=1;i<5;i++){
        const y = (h*i)/5;
        c2d.moveTo(0,y); c2d.lineTo(w,y);
      }
      c2d.stroke();

      // waveform
      const mid = h/2;
      c2d.strokeStyle = '#8ab4ff';
      c2d.lineWidth = 2;
      c2d.beginPath();

      const gain = scopeAutoGain;
      for (let i=0;i<buf.length;i++){
        const v = (buf[i] - 128) / 128;
        const y = mid - v * (mid * 0.9) * gain;
        const x = (w * i) / (buf.length - 1);
        if (i===0) c2d.moveTo(x,y); else c2d.lineTo(x,y);
      }
      c2d.stroke();
    };

    draw();
  }

  // ---------- Top-level UI wiring ----------
  $('#startBtn').addEventListener('click', startAudio);
  $('#stopBtn').addEventListener('click', stopAudio);

  $('#masterGain').addEventListener('input', (e)=>{
    const v = Number(e.target.value);
    $('#masterGainVal').textContent = v.toFixed(3);
    if (masterGain) masterGain.gain.value = v;
  });

  // Effects panel toggle
  const effectsPanel = $('#effectsPanel');
  $('#effectsBtn').addEventListener('click', () => {
    const open = !effectsPanel.classList.contains('open');
    effectsPanel.classList.toggle('open', open);
    $('#effectsBtn').textContent = open ? 'Effects ▴' : 'Effects ▾';
    // resize scope after layout change
    resizeCanvas();
  });

  // FX controls: any change updates routing/params
  const fxRoutingInputs = ['fxFilterOn','fxChorusOn','fxReverbOn','fxLimiterOn'];
  for (const id of fxRoutingInputs){
    $('#'+id).addEventListener('change', () => {
      if (!ctx) return;
      setFXEnabled();
      updateFXParams();
    });
  }
  const fxParamInputs = [
    'fxFilterType','fxFilterFreq','fxFilterQ',
    'fxChorusMode','fxChorusRate','fxChorusDepth','fxChorusMix','fxChorusFb',
    'fxReverbDecay','fxReverbMix',
    'fxLimiterThr','fxLimiterRel'
  ];
  for (const id of fxParamInputs){
    $('#'+id).addEventListener('input', () => {
      if (!ctx) return;
      updateFXParams();
    });
  }

  // ---------- Build formula UIs ----------
  for (const f of FORMULAS){
    makeFormulaUI(f);

    const en = document.getElementById(`en_${f.id}`);
    const resetBtn = document.getElementById(`reset_${f.id}`);
    const body = document.getElementById(`body_${f.id}`);
    const col = document.getElementById(`col_${f.id}`);

    col.addEventListener('click', () => {
      const collapsed = !body.classList.contains('collapsed');
      body.classList.toggle('collapsed', collapsed);
      col.textContent = collapsed ? 'Развернуть' : 'Свернуть';
    });

    en.addEventListener('change', () => {
      if (!ctx) { en.checked = false; return; }
      const st = nodes.get(f.id);
      const on = en.checked;

      const now = ctx.currentTime;
      st.g.gain.cancelScheduledValues(now);
      st.g.gain.setTargetAtTime(on ? (st.params.gain ?? 0.15) : 0, now, 0.02);

      resetBtn.disabled = !on;
    });

    resetBtn.addEventListener('click', () => {
      if (!ctx) return;
      const st = nodes.get(f.id);
      st.aw.port.postMessage({type:'reset'});
    });

    for (const s of f.sliders){
      const slider = document.getElementById(`${f.id}_${s.k}`);
      const val = document.getElementById(`${f.id}_${s.k}_v`);

      slider.addEventListener('input', () => {
        const v = Number(slider.value);
        val.textContent = fmt(v);

        if (!ctx) return;
        const st = nodes.get(f.id);
        st.params[s.k] = v;

        // Gain slider also controls the mix gain node
        if (s.k === 'gain'){
          const now = ctx.currentTime;
          if (document.getElementById(`en_${f.id}`).checked){
            st.g.gain.cancelScheduledValues(now);
            st.g.gain.setTargetAtTime(v, now, 0.02);
          }
        }
        st.aw.port.postMessage({type:'set', params: {[s.k]: v}});
      });
    }
  }

  // Initialize FX labels even before audio starts
  $('#fxFilterFreqVal').textContent = $('#fxFilterFreq').value;
  $('#fxFilterQVal').textContent = Number($('#fxFilterQ').value).toFixed(1);
  $('#fxChorusRateVal').textContent = Number($('#fxChorusRate').value).toFixed(2);
  $('#fxChorusDepthVal').textContent = Number($('#fxChorusDepth').value).toFixed(1);
  $('#fxChorusMixVal').textContent = Number($('#fxChorusMix').value).toFixed(2);
  $('#fxChorusFbVal').textContent = Number($('#fxChorusFb').value).toFixed(2);
  $('#fxReverbDecayVal').textContent = Number($('#fxReverbDecay').value).toFixed(1);
  $('#fxReverbMixVal').textContent = Number($('#fxReverbMix').value).toFixed(2);
  $('#fxLimiterThrVal').textContent = Number($('#fxLimiterThr').value).toFixed(1);
  $('#fxLimiterRelVal').textContent = Number($('#fxLimiterRel').value).toFixed(2);

})();
</script>
</body>
</html>
