<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Formula Audio Lab</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color-scheme: dark; }
    body { margin: 0; background:#0b0f14; color:#e8eef6; }
    header { padding: 16px 18px; border-bottom: 1px solid #1d2a3a; background:#0d131b; position: sticky; top:0; z-index: 5;}
    h1 { margin: 0 0 8px; font-size: 18px; font-weight: 700;}
    .row { display:flex; gap:12px; flex-wrap: wrap; align-items:center; }
    button { background:#1d3557; color:#fff; border:0; padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600;}
    button:disabled { opacity:.5; cursor:not-allowed; }
    .pill { padding:6px 10px; border-radius:999px; background:#0f1b29; border:1px solid #1d2a3a; font-size:12px; color:#bcd0e6; }
    main { padding: 16px 18px 28px; display:grid; grid-template-columns: 420px 1fr; gap: 16px; }
    @media (max-width: 980px) { main { grid-template-columns: 1fr; } }

    .card { background:#0d131b; border: 1px solid #1d2a3a; border-radius: 14px; padding: 14px; box-shadow: 0 10px 24px rgba(0,0,0,.25); }
    .card h2 { margin:0 0 10px; font-size:14px; color:#d9e7ff;}
    .muted { color:#9fb6d3; font-size: 12px; line-height: 1.3; }

    .scope { display:flex; flex-direction: column; gap: 10px; }
    canvas { width:100%; height: 220px; border-radius: 12px; border:1px solid #1d2a3a; background:#060a0f; }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .formula { border-top:1px solid #1d2a3a; padding-top: 12px; margin-top: 12px; }
    .formula:first-child { border-top:0; padding-top:0; margin-top:0; }
    .fhead { display:flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    .fhead h3 { margin:0; font-size: 13px; display:flex; align-items:center; gap:10px; }
    .fhead .tag { font-size: 11px; color:#bcd0e6; background:#0f1b29; border:1px solid #1d2a3a; padding:3px 8px; border-radius: 999px; }
    .ctrl { display:grid; grid-template-columns: 160px 1fr 70px; gap: 10px; align-items: center; margin-top: 8px;}
    .ctrl label { font-size: 12px; color:#cfe1ff; }
    input[type="range"] { width: 100%; }
    input[type="checkbox"] { transform: scale(1.15); }
    .small { font-size: 11px; color:#9fb6d3; }
    .sep { height:1px; background:#1d2a3a; margin: 10px 0; }
  </style>
</head>
<body>
<header>
  <h1>Formula Audio Lab — формулы как звук</h1>
  <div class="row">
    <button id="startBtn">Start Audio</button>
    <button id="stopBtn" disabled>Stop</button>
    <span class="pill" id="status">Status: not started</span>
    <span class="pill" id="scopeInfo">Scope: auto</span>
  </div>
</header>

<main>
  <section class="card">
    <h2>Осциллограф (выходной сигнал)</h2>
    <div class="scope">
      <canvas id="scope"></canvas>
      <div class="grid2">
        <div>
          <div class="ctrl">
            <label>Master volume</label>
            <input id="masterGain" type="range" min="0" max="1" step="0.001" value="0.25">
            <div class="small" id="masterGainVal">0.25</div>
          </div>
        </div>
        <div class="muted">
          Осциллограф теперь сам подбирает масштаб по Y (авто-усиление с плавной адаптацией).
          Если звук клиппит — уменьши Master volume или Gain у отдельных формул.
        </div>
      </div>
    </div>
  </section>

  <section class="card">
    <h2>Формулы (можно включать одновременно)</h2>
    <div id="formulas"></div>
  </section>
</main>

<script>
(async function(){
  // ---------- AudioWorklet code (inline module) ----------
  const workletCode = `
  class FormulaGeneratorProcessor extends AudioWorkletProcessor {
    constructor(options){
      super();
      const o = (options && options.processorOptions) || {};
      this.formula = o.formula || 'fm';

      this.sr = sampleRate;
      this.t = 0;
      this.phase = 0;

      // logistic
      this.logi = 0.33;

      // Lorenz
      this.lx = 0.1; this.ly = 0.0; this.lz = 0.0;

      // Karplus-Strong
      this.ksBuf = null;
      this.ksIdx = 0;
      this.ksN = 0;
      this.ksLp = 0;

      // Noise LP
      this.nlp = 0;

      // Bitcrusher
      this.bcHold = 0;
      this.bcCount = 0;

      this.p = Object.assign({
        gain: 0.2,

        // fm
        fc: 220, fm: 2, I: 2,

        // am
        f1: 220, f2: 221,

        // logistic
        base: 110, depth: 330, r: 3.86, lfoHz: 40,

        // gliss
        f0: 55, k: 0.15,

        // additive
        fund: 110, N: 12, move: 0.35,

        // phase modulation
        f: 220, f2pm: 3,

        // beats
        fbeat: 220, df: 0.8,

        // distortion
        fd: 110, alpha: 3.0,

        // quasi LFO
        fq: 120, Aq: 220, wq: 0.8,

        // lorenz
        sigma: 10, rho: 28, beta: 2.6667,
        lBase: 120, lFreqScale: 40, lAmp: 0.25,

        // karplus-strong
        ksFreq: 110,
        ksDamp: 0.985,  // ближе к 1 = дольше звучит
        ksBright: 0.5,  // 0..1 (0 = мягче, 1 = ярче)

        // bitcrusher
        bcFreq: 220,
        bcBits: 6,
        bcDown: 8,

        // noise lowpass
        nCut: 800
      }, o.params || {});

      this.port.onmessage = (e) => {
        const msg = e.data || {};
        if (msg.type === 'set') {
          for (const [k,v] of Object.entries(msg.params || {})) {
            this.p[k] = v;
          }
        } else if (msg.type === 'reset') {
          this.t = 0; this.phase = 0;
          this.logi = 0.33;
          this.lx = 0.1; this.ly = 0.0; this.lz = 0.0;

          this.nlp = 0;
          this.bcHold = 0; this.bcCount = 0;

          // reset KS buffer (re-pluck)
          this._initKS(true);
        }
      };

      this._initKS(true);
    }

    clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }

    _initKS(force){
      const p = this.p;
      const freq = Math.max(20, p.ksFreq || 110);
      const N = Math.max(2, Math.floor(this.sr / freq));
      if (!force && this.ksBuf && this.ksN === N) return;

      this.ksN = N;
      this.ksBuf = new Float32Array(N);
      this.ksIdx = 0;
      this.ksLp = 0;

      // fill with noise
      for (let i=0;i<N;i++){
        this.ksBuf[i] = (Math.random()*2 - 1);
      }
    }

    process(inputs, outputs){
      const out = outputs[0];
      const ch0 = out[0];
      const n = ch0.length;
      const sr = this.sr;
      const twoPi = 2*Math.PI;

      let p = this.p;
      let phase = this.phase;
      let t = this.t;
      let logi = this.logi;
      let lx = this.lx, ly = this.ly, lz = this.lz;

      let nlp = this.nlp;
      let bcHold = this.bcHold;
      let bcCount = this.bcCount;

      for (let i=0;i<n;i++){
        let x = 0;

        switch(this.formula){
          case 'fm': {
            x = Math.sin(twoPi*p.fc*t + (p.I)*Math.sin(twoPi*p.fm*t));
            break;
          }
          case 'am': {
            x = Math.sin(twoPi*p.f1*t) * Math.sin(twoPi*p.f2*t);
            break;
          }
          case 'logistic': {
            const lfoStep = Math.max(1, Math.floor(sr / Math.max(1e-3, p.lfoHz)));
            if ((i % lfoStep) === 0){
              logi = (p.r) * logi * (1 - logi);
              logi = this.clamp(logi, 0, 1);
            }
            const freq = p.base + p.depth * (logi - 0.5);
            phase += twoPi * (Math.max(0, freq) / sr);
            x = Math.sin(phase);
            break;
          }
          case 'gliss': {
            const f = p.f0 * Math.exp(p.k * t);
            phase += twoPi * (f / sr);
            x = Math.sin(phase);
            break;
          }
          case 'additive': {
            const fund = p.fund;
            const N = Math.max(1, Math.floor(p.N));
            const move = p.move;
            let s = 0;
            for (let k=1;k<=N;k++){
              const ak = (1/k) * Math.sin(twoPi*move*t + k);
              s += ak * Math.sin(twoPi*(k*fund)*t);
            }
            x = s * (1.0 / Math.log2(N+1));
            break;
          }
          case 'pm': {
            const phi = Math.sin(Math.sin(twoPi*p.f2pm*t));
            x = Math.sin(twoPi*p.f*t + phi*5.0);
            break;
          }
          case 'beats': {
            x = 0.5*(Math.sin(twoPi*p.fbeat*t) + Math.sin(twoPi*(p.fbeat + p.df)*t));
            break;
          }
          case 'dist': {
            x = Math.tanh(p.alpha * Math.sin(twoPi*p.fd*t));
            break;
          }
          case 'quasi': {
            const mod = Math.sin(Math.sin(Math.sin(p.wq * t)));
            const f = Math.max(0, p.fq + p.Aq*mod);
            phase += twoPi * (f / sr);
            x = Math.sin(phase);
            break;
          }
          case 'lorenz': {
            const sigma = p.sigma, rho = p.rho, beta = p.beta;
            const dt = 1/sr;

            const dx = sigma * (ly - lx);
            const dy = lx * (rho - lz) - ly;
            const dz = lx * ly - beta * lz;

            lx += dx * dt;
            ly += dy * dt;
            lz += dz * dt;

            const freq = Math.max(0, p.lBase + p.lFreqScale * Math.abs(lx));
            const amp = this.clamp(p.lAmp * (0.3 + 0.7 * (0.5 + 0.5*Math.tanh(ly))), 0, 1);

            phase += twoPi * (freq / sr);
            x = amp * Math.sin(phase);
            break;
          }

          // --- NEW: Karplus-Strong plucked string ---
          case 'karplus': {
            this._initKS(false);

            const buf = this.ksBuf;
            const N = this.ksN;
            let idx = this.ksIdx;

            const y0 = buf[idx];
            const y1 = buf[(idx + 1) % N];

            // simple averaging + damping
            const damp = this.clamp(p.ksDamp, 0.8, 0.99999);
            const bright = this.clamp(p.ksBright, 0, 1);

            // "bright" = how much we keep raw vs smoothed
            const avg = 0.5 * (y0 + y1);
            const next = damp * (bright * y0 + (1 - bright) * avg);

            buf[idx] = next;
            idx = (idx + 1) % N;
            this.ksIdx = idx;

            x = y0;
            break;
          }

          // --- NEW: Bitcrusher / Downsampler ---
          case 'bitcrush': {
            const f = Math.max(0, p.bcFreq);
            phase += twoPi * (f / sr);
            const raw = Math.sin(phase);

            const down = Math.max(1, Math.floor(p.bcDown));
            if (bcCount <= 0) {
              bcCount = down;
              const bits = this.clamp(Math.floor(p.bcBits), 1, 16);
              const levels = Math.pow(2, bits - 1); // signed
              bcHold = Math.round(raw * levels) / levels;
            }
            bcCount--;

            x = bcHold;
            break;
          }

          // --- NEW: Noise -> 1-pole lowpass ---
          case 'noiselp': {
            const white = (Math.random()*2 - 1);

            const cut = this.clamp(p.nCut, 20, 18000);
            const a = 1 - Math.exp(-2*Math.PI*cut/sr); // 1-pole smoothing coefficient
            nlp = nlp + a * (white - nlp);

            x = nlp;
            break;
          }

          default:
            x = 0;
        }

        ch0[i] = x * (p.gain ?? 0.2);
        t += 1/sr;

        if (phase > 1e9) phase %= twoPi;
      }

      this.phase = phase;
      this.t = t;
      this.logi = logi;

      this.lx = lx; this.ly = ly; this.lz = lz;

      this.nlp = nlp;
      this.bcHold = bcHold; this.bcCount = bcCount;

      return true;
    }
  }
  registerProcessor('formula-generator', FormulaGeneratorProcessor);
  `;

  // ---------- UI schema ----------
  const FORMULAS = [
    {
      id:'fm', title:'FM-синус', tag:'частотная модуляция',
      desc:'sin(2π f_c t + I sin(2π f_m t)) → от вибрато до “колоколов”.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.15},
        {k:'fc', name:'f_c (Hz)', min:20, max:2000, step:1, value:220},
        {k:'fm', name:'f_m (Hz)', min:0.1, max:60, step:0.1, value:2.0},
        {k:'I', name:'Index I', min:0, max:20, step:0.01, value:3.0},
      ]
    },
    {
      id:'am', title:'AM / биения (умножение)', tag:'амплитудная модуляция',
      desc:'sin(2π f1 t)·sin(2π f2 t) → пульсации и биения.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.15},
        {k:'f1', name:'f1 (Hz)', min:20, max:2000, step:1, value:220},
        {k:'f2', name:'f2 (Hz)', min:20, max:2000, step:1, value:221},
      ]
    },
    {
      id:'logistic', title:'Логистическое отображение', tag:'детерминированный хаос',
      desc:'xₙ₊₁ = r xₙ(1−xₙ) → используем x как модулятор частоты.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'base', name:'Base f (Hz)', min:20, max:800, step:1, value:110},
        {k:'depth', name:'Depth (Hz)', min:0, max:1200, step:1, value:330},
        {k:'r', name:'r', min:2.8, max:4.0, step:0.0001, value:3.86},
        {k:'lfoHz', name:'Update rate (Hz)', min:1, max:400, step:1, value:40},
      ]
    },
    {
      id:'gliss', title:'Экспоненциальный глиссандо', tag:'сирена / подъём',
      desc:'f(t)=f0·e^{k t} → непрерывный рост/падение высоты.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'f0', name:'f0 (Hz)', min:10, max:400, step:1, value:55},
        {k:'k', name:'k', min:-2.0, max:2.0, step:0.001, value:0.15},
      ]
    },
    {
      id:'additive', title:'Сумма гармоник', tag:'“дышащий” тембр',
      desc:'Σ aₙ(t) sin(2π n f t), aₙ(t)=(1/n)·sin(move·t+n).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'fund', name:'Fund (Hz)', min:20, max:500, step:1, value:110},
        {k:'N', name:'Harmonics N', min:1, max:40, step:1, value:12},
        {k:'move', name:'Move (Hz)', min:0.01, max:5, step:0.01, value:0.35},
      ]
    },
    {
      id:'pm', title:'Фазовая модуляция', tag:'шевелящийся спектр',
      desc:'sin(2π f t + 5·sin(sin(2π f2 t))).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'f', name:'f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'f2pm', name:'f2 (Hz)', min:0.1, max:40, step:0.1, value:3},
      ]
    },
    {
      id:'beats', title:'Два синуса (биения)', tag:'пульс/дыхание',
      desc:'sin(2π f t)+sin(2π(f+Δf)t).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'fbeat', name:'f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'df', name:'Δf (Hz)', min:0, max:20, step:0.01, value:0.8},
      ]
    },
    {
      id:'dist', title:'Нелинейная сатурация', tag:'tanh-дисторшн',
      desc:'tanh(α·sin(2π f t)) → тёплые гармоники.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'fd', name:'f (Hz)', min:20, max:2000, step:1, value:110},
        {k:'alpha', name:'α', min:0, max:10, step:0.01, value:3.0},
      ]
    },
    {
      id:'quasi', title:'Квазислучайный LFO', tag:'почти-органика',
      desc:'f(t)=fq + Aq·sin(sin(sin(w·t))).',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'fq', name:'Base f (Hz)', min:20, max:500, step:1, value:120},
        {k:'Aq', name:'Depth (Hz)', min:0, max:1200, step:1, value:220},
        {k:'wq', name:'w', min:0.05, max:6, step:0.01, value:0.8},
      ]
    },
    {
      id:'lorenz', title:'Аттрактор Лоренца', tag:'хаос, но “погодный”',
      desc:'Система ОДУ (Lorenz), x→частота, y→амплитуда.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'sigma', name:'σ', min:0, max:30, step:0.01, value:10},
        {k:'rho', name:'ρ', min:0, max:60, step:0.01, value:28},
        {k:'beta', name:'β', min:0.1, max:10, step:0.0001, value:2.6667},
        {k:'lBase', name:'Base f (Hz)', min:20, max:400, step:1, value:120},
        {k:'lFreqScale', name:'Freq scale', min:0, max:200, step:0.1, value:40},
        {k:'lAmp', name:'Amp scale', min:0, max:1, step:0.001, value:0.25},
      ]
    },

    // --- NEW FORMULAS ---
    {
      id:'karplus', title:'Karplus–Strong (струна)', tag:'физ. моделирование',
      desc:'Короткий шум в delay-линии + усреднение + затухание → “щипок струны”. Reset = “пере-щипнуть”.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.14},
        {k:'ksFreq', name:'Freq (Hz)', min:40, max:880, step:1, value:110},
        {k:'ksDamp', name:'Damping', min:0.90, max:0.9999, step:0.0001, value:0.985},
        {k:'ksBright', name:'Brightness', min:0, max:1, step:0.001, value:0.5},
      ]
    },
    {
      id:'bitcrush', title:'Bitcrusher / Downsample', tag:'lo-fi цифровая грязь',
      desc:'Квантизация по битам + удержание сэмпла N раз → “8-bit / gameboy”.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'bcFreq', name:'Input f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'bcBits', name:'Bits', min:1, max:16, step:1, value:6},
        {k:'bcDown', name:'Downsample', min:1, max:64, step:1, value:8},
      ]
    },
    {
      id:'noiselp', title:'Noise → Low-pass', tag:'шум/ветер/океан',
      desc:'Белый шум через 1-pole LPF: y += a(x−y), a=1−e^{−2πfc/sr}.',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'nCut', name:'Cutoff (Hz)', min:20, max:18000, step:1, value:800},
      ]
    },
  ];

  // ---------- DOM helpers ----------
  const $ = (s) => document.querySelector(s);
  const formulasRoot = $('#formulas');

  function fmt(v){
    if (Math.abs(v) >= 100) return String(Math.round(v));
    if (Math.abs(v) >= 10) return v.toFixed(2);
    return v.toFixed(3);
  }

  function makeFormulaUI(f){
    const wrap = document.createElement('div');
    wrap.className = 'formula';

    wrap.innerHTML = `
      <div class="fhead">
        <div>
          <h3><input type="checkbox" id="en_${f.id}"> ${f.title}</h3>
          <div class="muted">${f.desc}</div>
        </div>
        <div class="tag">${f.tag}</div>
      </div>
      <div id="sl_${f.id}"></div>
      <div class="sep"></div>
      <div class="row">
        <button id="reset_${f.id}" disabled>Reset state</button>
        <span class="small">Reset полезен для gliss / Lorenz / логистики / Karplus (пере-щипнуть).</span>
      </div>
    `;
    formulasRoot.appendChild(wrap);

    const slidersHost = wrap.querySelector(`#sl_${f.id}`);

    for (const s of f.sliders){
      const line = document.createElement('div');
      line.className = 'ctrl';
      line.innerHTML = `
        <label for="${f.id}_${s.k}">${s.name}</label>
        <input id="${f.id}_${s.k}" type="range" min="${s.min}" max="${s.max}" step="${s.step}" value="${s.value}">
        <div class="small" id="${f.id}_${s.k}_v">${fmt(Number(s.value))}</div>
      `;
      slidersHost.appendChild(line);
    }
    return wrap;
  }

  // ---------- Audio graph ----------
  let ctx = null;
  let analyser = null;
  let masterGain = null;
  let scopeRAF = null;

  const nodes = new Map(); // id -> {aw, g, params}

  function buildWorkletURL(){
    const blob = new Blob([workletCode], {type:'application/javascript'});
    return URL.createObjectURL(blob);
  }

  async function startAudio(){
    if (ctx) return;

    ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
    const url = buildWorkletURL();
    await ctx.audioWorklet.addModule(url);

    masterGain = ctx.createGain();
    masterGain.gain.value = Number($('#masterGain').value);

    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;

    masterGain.connect(analyser);
    analyser.connect(ctx.destination);

    for (const f of FORMULAS){
      const initParams = {};
      for (const s of f.sliders) initParams[s.k] = Number(s.value);

      const aw = new AudioWorkletNode(ctx, 'formula-generator', {
        numberOfInputs: 0,
        numberOfOutputs: 1,
        outputChannelCount: [1],
        processorOptions: { formula: f.id, params: initParams }
      });

      const g = ctx.createGain();
      g.gain.value = 0; // off by default

      aw.connect(g);
      g.connect(masterGain);

      nodes.set(f.id, { aw, g, params: initParams });
    }

    $('#status').textContent = 'Status: running';
    $('#stopBtn').disabled = false;
    $('#startBtn').disabled = true;

    startScope();
  }

  function stopAudio(){
    if (!ctx) return;
    cancelAnimationFrame(scopeRAF);
    scopeRAF = null;

    const now = ctx.currentTime;
    masterGain.gain.setTargetAtTime(0, now, 0.01);

    setTimeout(() => {
      ctx.close();
      ctx = null; analyser = null; masterGain = null;
      nodes.clear();
      $('#status').textContent = 'Status: stopped';
      $('#stopBtn').disabled = true;
      $('#startBtn').disabled = false;
      $('#scopeInfo').textContent = 'Scope: auto';
    }, 80);
  }

  // ---------- Oscilloscope (auto Y scale) ----------
  const canvas = $('#scope');
  const c2d = canvas.getContext('2d');

  let scopeAutoGain = 1.0; // smooth-follow

  function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
  }
  window.addEventListener('resize', resizeCanvas);

  function startScope(){
    resizeCanvas();
    const buf = new Uint8Array(analyser.fftSize);

    const draw = () => {
      scopeRAF = requestAnimationFrame(draw);
      if (!analyser) return;

      analyser.getByteTimeDomainData(buf);

      // compute peak amplitude for auto-scale
      let peak = 1e-4;
      for (let i=0;i<buf.length;i++){
        const v = (buf[i] - 128) / 128;
        const a = Math.abs(v);
        if (a > peak) peak = a;
      }

      // target so that peak fits ~85% height
      let target = 0.85 / peak;
      target = Math.max(0.25, Math.min(12.0, target));

      // smooth follow to avoid jitter
      scopeAutoGain += (target - scopeAutoGain) * 0.08;

      $('#scopeInfo').textContent = `Scope: auto ×${scopeAutoGain.toFixed(2)} (peak ${peak.toFixed(3)})`;

      const w = canvas.width, h = canvas.height;
      c2d.clearRect(0,0,w,h);

      // background
      c2d.fillStyle = '#060a0f';
      c2d.fillRect(0,0,w,h);

      // grid
      c2d.strokeStyle = '#122033';
      c2d.lineWidth = 1;
      c2d.beginPath();
      for (let i=1;i<10;i++){
        const x = (w*i)/10;
        c2d.moveTo(x,0); c2d.lineTo(x,h);
      }
      for (let i=1;i<6;i++){
        const y = (h*i)/6;
        c2d.moveTo(0,y); c2d.lineTo(w,y);
      }
      c2d.stroke();

      // waveform
      const mid = h/2;

      c2d.strokeStyle = '#8ab4ff';
      c2d.lineWidth = 2;
      c2d.beginPath();

      const gain = scopeAutoGain;
      for (let i=0;i<buf.length;i++){
        const v = (buf[i] - 128) / 128; // -1..1
        const y = mid - v * (mid * 0.9) * gain;
        const x = (w * i) / (buf.length - 1);
        if (i===0) c2d.moveTo(x,y);
        else c2d.lineTo(x,y);
      }
      c2d.stroke();
    };
    draw();
  }

  // ---------- Wire up global controls ----------
  $('#startBtn').addEventListener('click', startAudio);
  $('#stopBtn').addEventListener('click', stopAudio);

  $('#masterGain').addEventListener('input', (e)=>{
    const v = Number(e.target.value);
    $('#masterGainVal').textContent = v.toFixed(3);
    if (masterGain) masterGain.gain.value = v;
  });

  // ---------- Build formula UIs + connect to audio nodes ----------
  for (const f of FORMULAS){
    makeFormulaUI(f);

    const en = document.getElementById(`en_${f.id}`);
    const resetBtn = document.getElementById(`reset_${f.id}`);

    en.addEventListener('change', () => {
      if (!ctx) { en.checked = false; return; }
      const st = nodes.get(f.id);
      const on = en.checked;

      const now = ctx.currentTime;
      st.g.gain.cancelScheduledValues(now);
      st.g.gain.setTargetAtTime(on ? (st.params.gain ?? 0.15) : 0, now, 0.02);

      resetBtn.disabled = !on;
    });

    resetBtn.addEventListener('click', () => {
      if (!ctx) return;
      const st = nodes.get(f.id);
      st.aw.port.postMessage({type:'reset'});
    });

    for (const s of f.sliders){
      const slider = document.getElementById(`${f.id}_${s.k}`);
      const val = document.getElementById(`${f.id}_${s.k}_v`);

      slider.addEventListener('input', () => {
        const v = Number(slider.value);
        val.textContent = fmt(v);

        if (!ctx) return;
        const st = nodes.get(f.id);

        st.params[s.k] = v;

        // if "gain" changes, update mix gain too
        if (s.k === 'gain'){
          const now = ctx.currentTime;
          if (document.getElementById(`en_${f.id}`).checked){
            st.g.gain.cancelScheduledValues(now);
            st.g.gain.setTargetAtTime(v, now, 0.02);
          }
        }

        st.aw.port.postMessage({type:'set', params: {[s.k]: v}});
      });
    }
  }

})();
</script>
</body>
</html>
