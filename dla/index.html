<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Pseudo-Fractal (DLA)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #0b0d10; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; touch-action: none; }
    #wrap { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; }
    #c { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; cursor: grab; touch-action: none; }
    #c:active { cursor: grabbing; }

    .panel {
      position: fixed;
      top: 12px; right: 12px;
      width: min(360px, calc(100vw - 24px));
      max-height: calc(100vh - 24px);
      overflow: auto;
      background: rgba(15, 18, 24, 0.92);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 12px 12px 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
    }
    .panel h2 {
      margin: 0 0 10px; font-size: 14px; font-weight: 700; letter-spacing: .3px;
    }
    .panel .sub { margin: 0 0 10px; font-size: 12px; opacity: .75; line-height: 1.25; }
    
    .top-btns { display: flex; gap: 8px; flex-wrap: wrap; }
    
    .settings-body { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.10); }
    .settings-body.collapsed { display: none; }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 8px 0; }
    .row > label { font-size: 12px; opacity: .9; }
    .row input[type="range"] { width: 180px; }
    .row input[type="number"] { width: 90px; }
    .row select, .row input[type="color"], .row input[type="number"] {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e8eefc;
      border-radius: 10px;
      padding: 6px 8px;
      font-size: 12px;
      outline: none;
    }
    .row .chk { display: flex; align-items: center; gap: 8px; }
    .row .chk input { transform: translateY(1px); }

    .btns { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
    button {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e8eefc;
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
    }
    button:hover { background: rgba(255,255,255,0.11); }
    button:active { transform: translateY(1px); }
    button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }
    button:disabled:hover { background: rgba(255,255,255,0.08); }
    button:disabled:active { transform: none; }

    /* Start button styling */
    #start {
      background: #27ae60;
      border-color: #27ae60;
      box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
    }
    #start:hover { background: #2ecc71; }
    #start.running {
      background: #e67e22;
      border-color: #e67e22;
      box-shadow: 0 2px 8px rgba(230, 126, 34, 0.3);
    }
    #start.running:hover { background: #f39c12; }

    .divider { height: 1px; background: rgba(255,255,255,0.10); margin: 10px 0; }

    .dir-editor-wrap {
      display: flex;
      justify-content: center;
      padding: 8px 0;
    }
    #dirCanvas {
      cursor: grab;
      touch-action: none;
      border-radius: 8px;
    }
    #dirCanvas:active { cursor: grabbing; }

    .hud {
      position: fixed;
      left: 12px; bottom: 12px;
      font-size: 12px;
      opacity: .75;
      background: rgba(15, 18, 24, 0.55);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 8px 10px;
      user-select: none;
    }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; opacity: .9; }

    @media (max-width: 600px) {
      .panel { 
        left: 12px; 
        right: 12px; 
        width: auto;
      }
      .hud { font-size: 11px; padding: 6px 8px; }
      .row input[type="range"] { width: 120px; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c"></canvas>

    <div class="panel" id="panel">
      <h2>Pseudo-Fractal (DLA)</h2>
      <p class="sub">
        A particle wanders randomly and sticks to the cluster on contact (<a href="https://en.wikipedia.org/wiki/Diffusion-limited_aggregation">see more</a>).
      </p>

      <div class="top-btns">
        <button id="start">Start</button>
        <button id="reset">Reset</button>
        <button id="center">Center</button>
        <button id="saveImage">Save image</button>
        <button id="settingsBtn">Settings ▶</button>
      </div>

      <div class="settings-body collapsed" id="settingsBody">
        <div class="row">
          <label for="colorMode">Particle color</label>
          <select id="colorMode">
            <option value="constant">Constant</option>
            <option value="rainbow" selected>Rainbow (by time)</option>
          </select>
        </div>

        <div class="row" id="constColorRow" style="display:none;">
          <label for="constColor">Constant color</label>
          <input id="constColor" type="color" value="#8ad1ff" />
        </div>

        <div class="divider"></div>

        <div class="row">
          <label>Sound</label>
          <div class="chk">
            <input type="checkbox" id="soundEnabled" checked />
          </div>
        </div>

        <div class="row" id="soundVolumeRow">
          <label for="soundVolume" style="display:flex; justify-content:space-between; align-items:center;">
            <span>Master volume</span>
            <span id="soundVolumeVal" style="opacity:0.7;">25%</span>
          </label>
          <input id="soundVolume" type="range" min="0" max="100" step="5" value="25" />
        </div>

        <div class="row" id="pitchCoeffRow">
          <label for="pitchCoeff" style="display:flex; justify-content:space-between; align-items:center;">
            <span>X → Pitch</span>
            <span id="pitchCoeffVal" style="opacity:0.7;">1.0</span>
          </label>
          <input id="pitchCoeff" type="range" min="0.1" max="3" step="0.1" value="1" />
        </div>

        <div class="row" id="volumeCoeffRow">
          <label for="volumeCoeff" style="display:flex; justify-content:space-between; align-items:center;">
            <span>Y → Volume</span>
            <span id="volumeCoeffVal" style="opacity:0.7;">1.0</span>
          </label>
          <input id="volumeCoeff" type="range" min="0.1" max="3" step="0.1" value="1" />
        </div>

        <div class="divider"></div>

        <div class="row" id="hueStepRow">
          <label for="hueStep" style="display:flex; justify-content:space-between; align-items:center;">
            <span>Rainbow step</span>
            <span id="hueStepVal" style="opacity:0.7;">0.1</span>
          </label>
          <input id="hueStep" type="range" min="0.01" max="0.5" step="0.01" value="0.1" />
        </div>

        <div class="divider"></div>

        <div class="row">
          <label for="baseAdh" style="display:flex; justify-content:space-between; align-items:center;">
            <span>Base adhesion</span>
            <span id="baseAdhVal" style="opacity:0.7;">0.35</span>
          </label>
          <input id="baseAdh" type="range" min="0" max="1" step="0.01" value="0.35" />
        </div>

        <div class="divider"></div>

        <div class="row">
          <label>Direction presets</label>
          <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
            <button id="presetIso">Isotropic</button>
            <button id="preset120">120°</button>
            <button id="preset60">60°</button>
          </div>
        </div>

        <div class="dir-editor-wrap">
          <canvas id="dirCanvas" width="180" height="180"></canvas>
        </div>
      </div>
    </div>

    <div class="hud" id="hud">
      <div><span class="kbd">Wheel/Pinch</span> — zoom, <span class="kbd">Drag</span> — pan</div>
      <div id="hudLine"></div>
    </div>
  </div>

  <script src="dla-sound.js"></script>
  <script>
    // No build step. Single page. Single canvas.

    // ====== Canvas / camera ======
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });

    let dpr = 1;

    function resize() {
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      camera.cx = window.innerWidth / 2;
      camera.cy = window.innerHeight / 2;
    }
    window.addEventListener('resize', resize);

    const camera = {
      x: 0, y: 0, // world coordinates (in world pixels)
      zoom: 1.0,  // scale
      cx: window.innerWidth / 2,
      cy: window.innerHeight / 2,
    };

    function screenToWorld(sx, sy) {
      return {
        x: (sx - camera.cx) / camera.zoom + camera.x,
        y: (sy - camera.cy) / camera.zoom + camera.y,
      };
    }

    // ====== Direction angles for adhesion (6 directions, 60° apart) ======
    const DIR_ANGLES = [0, 30, 60, 90, 120, 150, 180, 210, 240, 270, 300, 330];

    // ====== Settings ======
    const ui = {
      colorMode: document.getElementById('colorMode'),
      constColorRow: document.getElementById('constColorRow'),
      constColor: document.getElementById('constColor'),
      hueStepRow: document.getElementById('hueStepRow'),
      hueStep: document.getElementById('hueStep'),
      hueStepVal: document.getElementById('hueStepVal'),
      baseAdh: document.getElementById('baseAdh'),
      baseAdhVal: document.getElementById('baseAdhVal'),

      dirCanvas: document.getElementById('dirCanvas'),
      presetIso: document.getElementById('presetIso'),
      preset120: document.getElementById('preset120'),
      preset60: document.getElementById('preset60'),
      soundEnabled: document.getElementById('soundEnabled'),
      soundVolume: document.getElementById('soundVolume'),
      soundVolumeVal: document.getElementById('soundVolumeVal'),
      pitchCoeff: document.getElementById('pitchCoeff'),
      pitchCoeffVal: document.getElementById('pitchCoeffVal'),
      volumeCoeff: document.getElementById('volumeCoeff'),
      volumeCoeffVal: document.getElementById('volumeCoeffVal'),

      start: document.getElementById('start'),
      reset: document.getElementById('reset'),
      center: document.getElementById('center'),
      saveImage: document.getElementById('saveImage'),

      hudLine: document.getElementById('hudLine'),
      settingsBtn: document.getElementById('settingsBtn'),
      settingsBody: document.getElementById('settingsBody'),
    };

    const settings = {
      colorMode: 'rainbow', // 'constant' | 'rainbow'
      constantColor: '#8ad1ff',
      hueStep: 0.1,

      baseAdhesion: 0.35,   // 0..1
      dirMult: [1,1,1,1,1,1,1,1,1,1,1,1], // multipliers for 12 directions (30° step)
      
      // Sound settings (Karplus-Strong)
      soundEnabled: true,       // Enable/disable sound
      soundMasterVolume: 0.25,  // 0-1, overall volume
      soundPitchCoeff: 1.0,     // Multiplier for X->pitch mapping
      soundVolumeCoeff: 1.0,    // Multiplier for Y->volume mapping
    };

    const STORAGE_KEY = 'dla_settings';

    function syncUIFromSettings() {
      ui.colorMode.value = settings.colorMode;
      ui.constColor.value = settings.constantColor;
      ui.hueStep.value = String(settings.hueStep);
      ui.hueStepVal.textContent = settings.hueStep;

      ui.baseAdh.value = String(settings.baseAdhesion);
      ui.baseAdhVal.textContent = settings.baseAdhesion;

      // Sound settings
      ui.soundEnabled.checked = settings.soundEnabled;
      ui.soundVolume.value = String(Math.round(settings.soundMasterVolume * 100));
      ui.soundVolumeVal.textContent = Math.round(settings.soundMasterVolume * 100) + '%';
      ui.pitchCoeff.value = String(settings.soundPitchCoeff);
      ui.pitchCoeffVal.textContent = settings.soundPitchCoeff.toFixed(1);
      ui.volumeCoeff.value = String(settings.soundVolumeCoeff);
      ui.volumeCoeffVal.textContent = settings.soundVolumeCoeff.toFixed(1);

      ui.constColorRow.style.display = (settings.colorMode === 'constant') ? '' : 'none';
      ui.hueStepRow.style.display = (settings.colorMode === 'rainbow') ? '' : 'none';

      // Update settings button to show panel state
      const isCollapsed = ui.settingsBody.classList.contains('collapsed');
      ui.settingsBtn.textContent = isCollapsed ? 'Settings ▶' : 'Settings ▼';

      if (dirEditor.canvas) dirEditor.draw();
    }

    function saveSettings() {
      try {
        const data = {
          colorMode: settings.colorMode,
          constantColor: settings.constantColor,
          hueStep: settings.hueStep,
          baseAdhesion: settings.baseAdhesion,
          dirMult: settings.dirMult.slice(),
          soundEnabled: settings.soundEnabled,
          soundMasterVolume: settings.soundMasterVolume,
          soundPitchCoeff: settings.soundPitchCoeff,
          soundVolumeCoeff: settings.soundVolumeCoeff,
          settingsPanelOpen: !ui.settingsBody.classList.contains('collapsed'),
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
      } catch (e) {
        console.warn('Failed to save settings:', e);
      }
    }

    function loadSettings() {
      try {
        const saved = localStorage.getItem(STORAGE_KEY);
        if (!saved) return;
        
        const data = JSON.parse(saved);
        
        if (data.colorMode !== undefined) settings.colorMode = data.colorMode;
        if (data.constantColor !== undefined) settings.constantColor = data.constantColor;
        if (data.hueStep !== undefined) settings.hueStep = data.hueStep;
        if (data.baseAdhesion !== undefined) settings.baseAdhesion = data.baseAdhesion;
        if (data.dirMult !== undefined && Array.isArray(data.dirMult)) {
          settings.dirMult = data.dirMult.slice();
        }
        if (data.soundEnabled !== undefined) settings.soundEnabled = data.soundEnabled;
        if (data.soundMasterVolume !== undefined) settings.soundMasterVolume = data.soundMasterVolume;
        if (data.soundPitchCoeff !== undefined) settings.soundPitchCoeff = data.soundPitchCoeff;
        if (data.soundVolumeCoeff !== undefined) settings.soundVolumeCoeff = data.soundVolumeCoeff;
        
        // Restore settings panel state
        if (data.settingsPanelOpen === true) {
          ui.settingsBody.classList.remove('collapsed');
        } else {
          ui.settingsBody.classList.add('collapsed');
        }
      } catch (e) {
        console.warn('Failed to load settings:', e);
      }
    }

    // ====== Direction Editor (circular widget) ======
    const dirEditor = {
      canvas: null,
      ctx: null,
      cx: 90, cy: 90,       // center of canvas
      maxRadius: 70,        // max radius for handle (value=2)
      minRadius: 10,        // min radius for handle (value=0)
      handleRadius: 6,      // size of draggable point
      dragging: null,       // index (0-5) or null

      init() {
        this.canvas = ui.dirCanvas;
        this.ctx = this.canvas.getContext('2d');
        this.bindEvents();
        this.draw();
      },

      // Get angle for direction index (0° at top, clockwise)
      getAngle(i) {
        return (DIR_ANGLES[i] - 90) * Math.PI / 180;
      },

      // Get handle position for direction i
      getHandlePos(i) {
        const angle = this.getAngle(i);
        const value = settings.dirMult[i];
        const radius = this.minRadius + (value / 2) * (this.maxRadius - this.minRadius);
        return {
          x: this.cx + Math.cos(angle) * radius,
          y: this.cy + Math.sin(angle) * radius
        };
      },

      // Convert radius to value (0..2)
      radiusToValue(r) {
        const clamped = Math.max(this.minRadius, Math.min(this.maxRadius, r));
        return ((clamped - this.minRadius) / (this.maxRadius - this.minRadius)) * 2;
      },

      // Find which handle is at position (x, y), or null
      hitTest(x, y) {
        for (let i = 0; i < 12; i++) {
          const pos = this.getHandlePos(i);
          const dist = Math.hypot(x - pos.x, y - pos.y);
          if (dist <= this.handleRadius + 4) return i;
        }
        return null;
      },

      draw() {
        const ctx = this.ctx;
        const w = this.canvas.width;
        const h = this.canvas.height;

        // Clear
        ctx.clearRect(0, 0, w, h);

        // Background circle
        ctx.beginPath();
        ctx.arc(this.cx, this.cy, this.maxRadius, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.03)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        ctx.stroke();

        // Inner reference circle (value=1)
        const midRadius = this.minRadius + (this.maxRadius - this.minRadius) / 2;
        ctx.beginPath();
        ctx.arc(this.cx, this.cy, midRadius, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,255,255,0.08)';
        ctx.setLineDash([3, 3]);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw polygon fill
        ctx.beginPath();
        for (let i = 0; i < 12; i++) {
          const pos = this.getHandlePos(i);
          if (i === 0) ctx.moveTo(pos.x, pos.y);
          else ctx.lineTo(pos.x, pos.y);
        }
        ctx.closePath();
        ctx.fillStyle = 'rgba(100, 180, 255, 0.15)';
        ctx.fill();
        ctx.strokeStyle = 'rgba(100, 180, 255, 0.4)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Draw direction lines and handles
        for (let i = 0; i < 12; i++) {
          const angle = this.getAngle(i);
          const pos = this.getHandlePos(i);

          // Line from center to handle
          ctx.beginPath();
          ctx.moveTo(this.cx, this.cy);
          ctx.lineTo(pos.x, pos.y);
          ctx.strokeStyle = 'rgba(255,255,255,0.2)';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Handle circle
          ctx.beginPath();
          ctx.arc(pos.x, pos.y, this.handleRadius, 0, Math.PI * 2);
          ctx.fillStyle = this.dragging === i ? '#7cb3ff' : '#5a9cff';
          ctx.fill();
          ctx.strokeStyle = 'rgba(255,255,255,0.5)';
          ctx.lineWidth = 1.5;
          ctx.stroke();

          // Angle label (only show every 60° to avoid clutter)
          if (i % 2 === 0) {
            const labelRadius = this.maxRadius + 16;
            const labelX = this.cx + Math.cos(angle) * labelRadius;
            const labelY = this.cy + Math.sin(angle) * labelRadius;
            ctx.fillStyle = 'rgba(255,255,255,0.6)';
            ctx.font = '10px system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(DIR_ANGLES[i] + '°', labelX, labelY);
          }
        }

        // Center dot
        ctx.beginPath();
        ctx.arc(this.cx, this.cy, 3, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.fill();
      },

      getPointerPos(e) {
        const rect = this.canvas.getBoundingClientRect();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        return {
          x: clientX - rect.left,
          y: clientY - rect.top
        };
      },

      onPointerDown(e) {
        e.preventDefault();
        const pos = this.getPointerPos(e);
        const hit = this.hitTest(pos.x, pos.y);
        if (hit !== null) {
          this.dragging = hit;
          this.draw();
        }
      },

      onPointerMove(e) {
        if (this.dragging === null) return;
        e.preventDefault();
        
        const pos = this.getPointerPos(e);
        const dx = pos.x - this.cx;
        const dy = pos.y - this.cy;
        const radius = Math.hypot(dx, dy);
        
        settings.dirMult[this.dragging] = this.radiusToValue(radius);
        this.draw();
      },

      onPointerUp(e) {
        if (this.dragging !== null) {
          this.dragging = null;
          this.draw();
          sendSettingsToWorker();
          saveSettings();
        }
      },

      bindEvents() {
        // Mouse events
        this.canvas.addEventListener('mousedown', (e) => this.onPointerDown(e));
        window.addEventListener('mousemove', (e) => this.onPointerMove(e));
        window.addEventListener('mouseup', (e) => this.onPointerUp(e));

        // Touch events
        this.canvas.addEventListener('touchstart', (e) => this.onPointerDown(e), { passive: false });
        this.canvas.addEventListener('touchmove', (e) => this.onPointerMove(e), { passive: false });
        this.canvas.addEventListener('touchend', (e) => this.onPointerUp(e));
        this.canvas.addEventListener('touchcancel', (e) => this.onPointerUp(e));
      }
    };

    // UI handlers
    ui.colorMode.addEventListener('change', () => {
      settings.colorMode = ui.colorMode.value;
      syncUIFromSettings();
      saveSettings();
    });

    ui.constColor.addEventListener('change', () => {
      settings.constantColor = ui.constColor.value;
      saveSettings();
    });

    ui.hueStep.addEventListener('input', () => {
      settings.hueStep = parseFloat(ui.hueStep.value);
      ui.hueStepVal.textContent = settings.hueStep;
      saveSettings();
    });

    ui.soundEnabled.addEventListener('change', () => {
      settings.soundEnabled = ui.soundEnabled.checked;
      syncSoundSettings();
      saveSettings();
    });

    ui.soundVolume.addEventListener('input', () => {
      settings.soundMasterVolume = parseInt(ui.soundVolume.value) / 100;
      ui.soundVolumeVal.textContent = ui.soundVolume.value + '%';
      syncSoundSettings();
      saveSettings();
    });

    ui.pitchCoeff.addEventListener('input', () => {
      settings.soundPitchCoeff = parseFloat(ui.pitchCoeff.value);
      ui.pitchCoeffVal.textContent = settings.soundPitchCoeff.toFixed(1);
      syncSoundSettings();
      saveSettings();
    });

    ui.volumeCoeff.addEventListener('input', () => {
      settings.soundVolumeCoeff = parseFloat(ui.volumeCoeff.value);
      ui.volumeCoeffVal.textContent = settings.soundVolumeCoeff.toFixed(1);
      syncSoundSettings();
      saveSettings();
    });

    ui.baseAdh.addEventListener('input', () => {
      settings.baseAdhesion = parseFloat(ui.baseAdh.value);
      ui.baseAdhVal.textContent = settings.baseAdhesion;
      sendSettingsToWorker();
      saveSettings();
    });

    ui.presetIso.addEventListener('click', () => {
      settings.dirMult = [1,1,1,1,1,1,1,1,1,1,1,1];
      dirEditor.draw();
      sendSettingsToWorker();
      saveSettings();
    });

    ui.preset120.addEventListener('click', () => {
      // peaks at 120° intervals: 0°, 120°, 240° strong; others weaker
      // Indices: 0=0°, 4=120°, 8=240° are peaks
      settings.dirMult = [2, 0, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0];
      dirEditor.draw();
      sendSettingsToWorker();
      saveSettings();
    });

    ui.preset60.addEventListener('click', () => {
      // peaks at 60° intervals: 0°, 60°, 120°, 180°, 240°, 300° strong
      // Indices: 0, 2, 4, 6, 8, 10 are peaks
      settings.dirMult = [2, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 0];
      dirEditor.draw();
      sendSettingsToWorker();
      saveSettings();
    });

    // ====== Sound Settings Sync ======
    function syncSoundSettings() {
      DLASound.updateSettings({
        enabled: settings.soundEnabled,
        masterVolume: settings.soundMasterVolume,
        pitchCoeff: settings.soundPitchCoeff,
        volumeCoeff: settings.soundVolumeCoeff,
      });
    }

    // ====== Simulation State (render only) ======
    let points = [];          // stuck particles { x, y, c }
    let stuckCount = 0;
    let maxRadius = 0;

    // Particle radius for rendering
    const PARTICLE_RADIUS = 3;

    // ====== Web Worker for simulation ======
    const worker = new Worker('dla-worker.js');

    worker.onmessage = function(e) {
      const { type, data, stats } = e.data;
      if (type === 'particles') {
        // Add new particles with colors and play sounds
        for (const p of data) {
          points.push({ x: p.x, y: p.y, c: colorForIndex(p.index) });
          // Play Karplus-Strong sound for each particle
          DLASound.play(p.x, p.y, maxRadius);
        }
        stuckCount = stats.stuckCount;
        maxRadius = stats.maxRadius;
      }
    };

    function sendSettingsToWorker() {
      worker.postMessage({
        type: 'updateSettings',
        settings: {
          baseAdhesion: settings.baseAdhesion,
          dirMult: settings.dirMult.slice() // copy array
        }
      });
    }

    function resetWorld() {
      points = [];
      stuckCount = 0;
      maxRadius = 0;
      worker.postMessage({ type: 'reset' });
      // camera center
      camera.x = 0;
      camera.y = 0;
    }

    function colorForIndex(i) {
      if (settings.colorMode === 'constant') return settings.constantColor;
      const h = (i * settings.hueStep) % 360;
      return `hsl(${h} 95% 65%)`;
    }

    // ====== Render ======
    function render() {
      // background (in device pixels)
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#0b0d10';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // world transform (in CSS pixels, scaled by dpr)
      const scale = camera.zoom * dpr;
      ctx.setTransform(
        scale, 0, 0, scale,
        camera.cx * dpr - camera.x * scale,
        camera.cy * dpr - camera.y * scale
      );

      // draw stuck points with frustum culling
      const view = getWorldViewBounds();
      const pad = 40 / camera.zoom;
      const minX = view.minX - pad, maxX = view.maxX + pad;
      const minY = view.minY - pad, maxY = view.maxY + pad;

      const r = Math.max(0.5, PARTICLE_RADIUS * 0.5);
      const PI2 = Math.PI * 2;
      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) continue;
        ctx.fillStyle = p.c;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, PI2);
        ctx.fill();
      }

      // HUD text
      const radiusDisplay = Math.round(maxRadius);
      ui.hudLine.textContent =
        `Particles: ${stuckCount.toLocaleString()} | Radius: ${radiusDisplay} | Zoom: ${camera.zoom.toFixed(2)}` +
        (!running ? ' | STOPPED' : '');
    }

    function getWorldViewBounds() {
      const tl = screenToWorld(0, 0);
      const br = screenToWorld(window.innerWidth, window.innerHeight);
      return {
        minX: Math.min(tl.x, br.x),
        maxX: Math.max(tl.x, br.x),
        minY: Math.min(tl.y, br.y),
        maxY: Math.max(tl.y, br.y),
      };
    }

    // ====== Mouse: pan + zoom ======
    let dragging = false;
    let lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', (e) => {
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });
    window.addEventListener('mouseup', () => dragging = false);
    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      camera.x -= dx / camera.zoom;
      camera.y -= dy / camera.zoom;
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const mouse = { x: e.clientX, y: e.clientY };
      const before = screenToWorld(mouse.x, mouse.y);

      const zoomFactor = Math.exp((-e.deltaY) * 0.0015);
      const newZoom = Math.max(0.05, Math.min(40, camera.zoom * zoomFactor));
      camera.zoom = newZoom;

      const after = screenToWorld(mouse.x, mouse.y);
      camera.x += (before.x - after.x);
      camera.y += (before.y - after.y);
    }, { passive: false });

    // ====== Touch: pan + pinch zoom ======
    let touches = [];
    let lastTouchDist = 0;
    let lastTouchCenter = null;

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touches = Array.from(e.touches);
      
      if (touches.length === 1) {
        lastX = touches[0].clientX;
        lastY = touches[0].clientY;
        dragging = true;
      } else if (touches.length === 2) {
        dragging = false;
        lastTouchDist = Math.hypot(
          touches[1].clientX - touches[0].clientX,
          touches[1].clientY - touches[0].clientY
        );
        lastTouchCenter = {
          x: (touches[0].clientX + touches[1].clientX) / 2,
          y: (touches[0].clientY + touches[1].clientY) / 2
        };
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      touches = Array.from(e.touches);

      if (touches.length === 1 && dragging) {
        // Pan
        const dx = touches[0].clientX - lastX;
        const dy = touches[0].clientY - lastY;
        lastX = touches[0].clientX;
        lastY = touches[0].clientY;
        camera.x -= dx / camera.zoom;
        camera.y -= dy / camera.zoom;
      } else if (touches.length === 2) {
        // Pinch zoom
        const newDist = Math.hypot(
          touches[1].clientX - touches[0].clientX,
          touches[1].clientY - touches[0].clientY
        );
        const newCenter = {
          x: (touches[0].clientX + touches[1].clientX) / 2,
          y: (touches[0].clientY + touches[1].clientY) / 2
        };

        if (lastTouchDist > 0 && lastTouchCenter) {
          // Zoom
          const before = screenToWorld(newCenter.x, newCenter.y);
          const zoomFactor = newDist / lastTouchDist;
          camera.zoom = Math.max(0.05, Math.min(40, camera.zoom * zoomFactor));
          const after = screenToWorld(newCenter.x, newCenter.y);
          camera.x += (before.x - after.x);
          camera.y += (before.y - after.y);

          // Pan
          const dx = newCenter.x - lastTouchCenter.x;
          const dy = newCenter.y - lastTouchCenter.y;
          camera.x -= dx / camera.zoom;
          camera.y -= dy / camera.zoom;
        }

        lastTouchDist = newDist;
        lastTouchCenter = newCenter;
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      touches = Array.from(e.touches);
      if (touches.length < 2) {
        lastTouchDist = 0;
        lastTouchCenter = null;
      }
      if (touches.length === 0) {
        dragging = false;
      } else if (touches.length === 1) {
        lastX = touches[0].clientX;
        lastY = touches[0].clientY;
        dragging = true;
      }
    }, { passive: false });

    canvas.addEventListener('touchcancel', () => {
      touches = [];
      dragging = false;
      lastTouchDist = 0;
      lastTouchCenter = null;
    });

    // ====== Buttons ======
    let running = false;
    let renderRAF = null;

    function startSimulation() {
      if (running) return;
      running = true;
      ui.start.textContent = 'Stop';
      ui.start.classList.add('running');
      ui.reset.disabled = true;
      // Initialize audio on user interaction
      DLASound.init();
      syncSoundSettings();
      worker.postMessage({ type: 'start' });
      startRenderLoop();
    }

    function stopSimulation() {
      running = false;
      ui.start.textContent = 'Start';
      ui.start.classList.remove('running');
      ui.reset.disabled = false;
      worker.postMessage({ type: 'stop' });
    }

    function startRenderLoop() {
      if (renderRAF) return;
      function renderLoop() {
        render();
        renderRAF = requestAnimationFrame(renderLoop);
      }
      renderRAF = requestAnimationFrame(renderLoop);
    }

    ui.start.addEventListener('click', () => {
      if (running) {
        stopSimulation();
      } else {
        startSimulation();
      }
    });

    ui.reset.addEventListener('click', () => {
      resetWorld();
      render();
    });

    ui.center.addEventListener('click', () => {
      camera.x = 0;
      camera.y = 0;
      camera.zoom = 1.0;
    });

    ui.saveImage.addEventListener('click', () => {
      // Render one frame to ensure canvas is up to date
      render();
      const link = document.createElement('a');
      link.download = `dla-${Date.now()}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // Settings toggle
    ui.settingsBtn.addEventListener('click', () => {
      const isCollapsed = ui.settingsBody.classList.toggle('collapsed');
      ui.settingsBtn.textContent = isCollapsed ? 'Settings ▶' : 'Settings ▼';
      saveSettings();
    });

    // ====== Page visibility (background execution) ======
    // Simulation runs in Web Worker and continues even when page is hidden
    // Only rendering pauses (which is handled by rAF automatically)

    // ====== Init ======
    function init() {
      resize();
      loadSettings();
      dirEditor.init();
      syncUIFromSettings();
      syncSoundSettings();
      sendSettingsToWorker();
      resetWorld();
      startRenderLoop();
      render();
    }
    init();
  </script>
</body>
</html>
