<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Pseudo-Fractal (DLA)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { width: 100%; height: 100%; margin: 0; padding: 0; overflow: hidden; background: #0b0d10; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; touch-action: none; }
    #wrap { position: fixed; top: 0; left: 0; right: 0; bottom: 0; width: 100%; height: 100%; }
    canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; display: block; cursor: grab; touch-action: none; }
    canvas:active { cursor: grabbing; }

    .panel {
      position: fixed;
      top: 12px; right: 12px;
      width: min(360px, calc(100vw - 24px));
      max-height: calc(100vh - 24px);
      overflow: auto;
      background: rgba(15, 18, 24, 0.92);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 12px 12px 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
    }
    .panel h2 {
      margin: 0 0 10px; font-size: 14px; font-weight: 700; letter-spacing: .3px;
    }
    .panel .sub { margin: 0 0 10px; font-size: 12px; opacity: .75; line-height: 1.25; }
    
    .top-btns { display: flex; gap: 8px; flex-wrap: wrap; }
    
    .settings-body { margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255,255,255,0.10); }
    .settings-body.collapsed { display: none; }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 8px 0; }
    .row > label { font-size: 12px; opacity: .9; }
    .row input[type="range"] { width: 180px; }
    .row input[type="number"] { width: 90px; }
    .row select, .row input[type="color"], .row input[type="number"] {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e8eefc;
      border-radius: 10px;
      padding: 6px 8px;
      font-size: 12px;
      outline: none;
    }
    .row .chk { display: flex; align-items: center; gap: 8px; }
    .row .chk input { transform: translateY(1px); }

    .btns { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
    button {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e8eefc;
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
    }
    button:hover { background: rgba(255,255,255,0.11); }
    button:active { transform: translateY(1px); }

    /* Start button styling */
    #start {
      background: #27ae60;
      border-color: #27ae60;
      box-shadow: 0 2px 8px rgba(39, 174, 96, 0.3);
    }
    #start:hover { background: #2ecc71; }
    #start.running {
      background: #e67e22;
      border-color: #e67e22;
      box-shadow: 0 2px 8px rgba(230, 126, 34, 0.3);
    }
    #start.running:hover { background: #f39c12; }

    .divider { height: 1px; background: rgba(255,255,255,0.10); margin: 10px 0; }

    .dir-grid { display: grid; grid-template-columns: 1fr; gap: 8px; }
    .dir-item { display: grid; grid-template-columns: 72px 1fr 48px; gap: 8px; align-items: center; }
    .dir-item .tag { font-size: 11px; opacity: .9; }
    .dir-item input[type="range"] { width: 100%; }
    .dir-item .val { font-size: 11px; opacity: .85; text-align: right; }

    .hud {
      position: fixed;
      left: 12px; bottom: 12px;
      font-size: 12px;
      opacity: .75;
      background: rgba(15, 18, 24, 0.55);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 8px 10px;
      user-select: none;
    }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; opacity: .9; }

    @media (max-width: 600px) {
      .panel { 
        left: 12px; 
        right: 12px; 
        width: auto;
      }
      .hud { font-size: 11px; padding: 6px 8px; }
      .row input[type="range"] { width: 120px; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c"></canvas>

    <div class="panel" id="panel">
      <h2>Pseudo-Fractal (DLA)</h2>
      <p class="sub">
        A particle wanders randomly and sticks to the cluster on contact (<a href="https://en.wikipedia.org/wiki/Diffusion-limited_aggregation">see more</a>).
      </p>

      <div class="top-btns">
        <button id="start">Start</button>
        <button id="reset">Reset</button>
        <button id="center">Center</button>
        <button id="saveImage">Save image</button>
        <button id="settingsBtn">Settings</button>
      </div>

      <div class="settings-body collapsed" id="settingsBody">
        <div class="row">
          <label for="colorMode">Particle color</label>
          <select id="colorMode">
            <option value="constant">Constant</option>
            <option value="rainbow" selected>Rainbow (by time)</option>
          </select>
        </div>

        <div class="row" id="constColorRow" style="display:none;">
          <label for="constColor">Constant color</label>
          <input id="constColor" type="color" value="#8ad1ff" />
        </div>

        <div class="row" id="hueStepRow">
          <label for="hueStep">Rainbow step (hue degrees)</label>
          <input id="hueStep" type="number" min="1" max="90" step="1" value="3" />
        </div>

        <div class="divider"></div>

        <div class="row">
          <label for="baseAdh">Base adhesion</label>
          <input id="baseAdh" type="range" min="0" max="1" step="0.01" value="0.35" />
        </div>

        <div class="row">
          <label>Direction presets</label>
          <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
            <button id="presetIso">Isotropic</button>
            <button id="preset120">120°</button>
            <button id="preset60">60° (strict)</button>
          </div>
        </div>

        <div class="dir-grid" id="dirGrid"></div>
      </div>
    </div>

    <div class="hud" id="hud">
      <div><span class="kbd">Wheel/Pinch</span> — zoom, <span class="kbd">Drag</span> — pan</div>
      <div id="hudLine"></div>
    </div>
  </div>

  <script>
    // No build step. Single page. Single canvas.

    // ====== Canvas / camera ======
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });

    let dpr = 1;

    function resize() {
      dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      camera.cx = window.innerWidth / 2;
      camera.cy = window.innerHeight / 2;
    }
    window.addEventListener('resize', resize);

    const camera = {
      x: 0, y: 0, // world coordinates (in world pixels)
      zoom: 1.0,  // scale
      cx: window.innerWidth / 2,
      cy: window.innerHeight / 2,
    };

    function screenToWorld(sx, sy) {
      return {
        x: (sx - camera.cx) / camera.zoom + camera.x,
        y: (sy - camera.cy) / camera.zoom + camera.y,
      };
    }

    // ====== Direction angles for adhesion (6 directions, 60° apart) ======
    const DIR_ANGLES = [0, 60, 120, 180, 240, 300];

    // ====== Settings ======
    const ui = {
      colorMode: document.getElementById('colorMode'),
      constColorRow: document.getElementById('constColorRow'),
      constColor: document.getElementById('constColor'),
      hueStepRow: document.getElementById('hueStepRow'),
      hueStep: document.getElementById('hueStep'),
      baseAdh: document.getElementById('baseAdh'),

      dirGrid: document.getElementById('dirGrid'),
      presetIso: document.getElementById('presetIso'),
      preset120: document.getElementById('preset120'),
      preset60: document.getElementById('preset60'),

      start: document.getElementById('start'),
      reset: document.getElementById('reset'),
      center: document.getElementById('center'),
      saveImage: document.getElementById('saveImage'),

      hudLine: document.getElementById('hudLine'),
      settingsBtn: document.getElementById('settingsBtn'),
      settingsBody: document.getElementById('settingsBody'),
    };

    const settings = {
      targetFps: 60,

      colorMode: 'rainbow', // 'constant' | 'rainbow'
      constantColor: '#8ad1ff',
      hueStep: 3,

      baseAdhesion: 0.35,   // 0..1
      dirMult: [1,1,1,1,1,1], // multipliers for 6 directions (0°, 60°, 120°, 180°, 240°, 300°)
    };

    function syncUIFromSettings() {
      ui.colorMode.value = settings.colorMode;
      ui.constColor.value = settings.constantColor;
      ui.hueStep.value = String(settings.hueStep);

      ui.baseAdh.value = String(settings.baseAdhesion);

      ui.constColorRow.style.display = (settings.colorMode === 'constant') ? '' : 'none';
      ui.hueStepRow.style.display = (settings.colorMode === 'rainbow') ? '' : 'none';

      renderDirControls();
    }

    function renderDirControls() {
      ui.dirGrid.innerHTML = '';
      for (let i = 0; i < 6; i++) {
        const wrap = document.createElement('div');
        wrap.className = 'dir-item';

        const tag = document.createElement('div');
        tag.className = 'tag';
        tag.textContent = DIR_ANGLES[i] + '°';

        const rng = document.createElement('input');
        rng.type = 'range';
        rng.min = '0';
        rng.max = '2';
        rng.step = '0.01';
        rng.value = String(settings.dirMult[i]);

        const val = document.createElement('div');
        val.className = 'val';
        val.textContent = settings.dirMult[i].toFixed(2) + '×';

        rng.addEventListener('input', () => {
          settings.dirMult[i] = parseFloat(rng.value);
          val.textContent = settings.dirMult[i].toFixed(2) + '×';
        });

        wrap.appendChild(tag);
        wrap.appendChild(rng);
        wrap.appendChild(val);
        ui.dirGrid.appendChild(wrap);
      }
    }

    // UI handlers
    ui.colorMode.addEventListener('change', () => {
      settings.colorMode = ui.colorMode.value;
      syncUIFromSettings();
    });

    ui.constColor.addEventListener('change', () => {
      settings.constantColor = ui.constColor.value;
    });

    ui.hueStep.addEventListener('change', () => {
      const v = Math.max(1, Math.min(90, parseInt(ui.hueStep.value || '3', 10)));
      settings.hueStep = v;
      ui.hueStep.value = String(v);
    });

    ui.baseAdh.addEventListener('input', () => {
      settings.baseAdhesion = parseFloat(ui.baseAdh.value);
    });

    ui.presetIso.addEventListener('click', () => {
      settings.dirMult = [1,1,1,1,1,1];
      renderDirControls();
    });

    ui.preset120.addEventListener('click', () => {
      // peaks at 120° intervals: 0°, 120°, 240° strong; others weaker
      settings.dirMult = [1.8, 0.2, 1.8, 0.2, 1.8, 0.2];
      renderDirControls();
    });

    ui.preset60.addEventListener('click', () => {
      // "strict": sticks equally in all 6 directions with high multiplier
      settings.dirMult = [2,2,2,2,2,2];
      renderDirControls();
    });

    // ====== Simulation (continuous coordinates) ======
    let points = [];          // stuck particles { x, y, c }
    let walker = null;        // current moving particle { x, y }
    let stuckCount = 0;
    let maxRadius = 0;

    // Spatial hash for fast neighbor lookup
    const CELL_SIZE = 8;      // world pixels per cell
    let spatialHash = new Map();

    // World parameters
    const PARTICLE_RADIUS = 3;      // collision radius
    const SPAWN_MARGIN = 40;        // spawn distance from maxRadius
    const KILL_MARGIN = 80;         // kill distance beyond maxRadius
    const STEP_SIZE = 2;            // random walk step size
    const MOVES_PER_TICK = 200;     // how many random-walk steps we do per "world frame"

    function cellKey(x, y) {
      const cx = Math.floor(x / CELL_SIZE);
      const cy = Math.floor(y / CELL_SIZE);
      return cx + ',' + cy;
    }

    function addToSpatialHash(p) {
      const key = cellKey(p.x, p.y);
      if (!spatialHash.has(key)) spatialHash.set(key, []);
      spatialHash.get(key).push(p);
    }

    function getNearbyParticles(x, y, radius) {
      const result = [];
      const cellRadius = Math.ceil(radius / CELL_SIZE) + 1;
      const cx = Math.floor(x / CELL_SIZE);
      const cy = Math.floor(y / CELL_SIZE);

      for (let dx = -cellRadius; dx <= cellRadius; dx++) {
        for (let dy = -cellRadius; dy <= cellRadius; dy++) {
          const key = (cx + dx) + ',' + (cy + dy);
          const cell = spatialHash.get(key);
          if (cell) {
            for (const p of cell) {
              const dist = Math.hypot(p.x - x, p.y - y);
              if (dist <= radius) result.push({ particle: p, dist });
            }
          }
        }
      }
      return result;
    }

    function resetWorld() {
      points = [];
      spatialHash = new Map();
      walker = null;
      stuckCount = 0;
      maxRadius = 0;

      // First stuck particle at center
      stickParticle(0, 0);
      // camera center
      camera.x = 0;
      camera.y = 0;
    }

    function colorForIndex(i) {
      if (settings.colorMode === 'constant') return settings.constantColor;
      const h = (i * settings.hueStep) % 360;
      return `hsl(${h} 95% 65%)`;
    }

    function stickParticle(x, y) {
      const col = colorForIndex(stuckCount);
      const p = { x, y, c: col };
      points.push(p);
      addToSpatialHash(p);

      stuckCount++;
      const dist = Math.hypot(x, y);
      maxRadius = Math.max(maxRadius, dist);
      return true;
    }

    function spawnWalker() {
      // spawn on circle around current maxRadius
      const R = maxRadius + SPAWN_MARGIN;
      const angle = Math.random() * Math.PI * 2;
      walker = {
        x: Math.cos(angle) * R,
        y: Math.sin(angle) * R
      };
    }

    function getDirectionIndex(angle) {
      // Normalize angle to [0, 360)
      let a = ((angle * 180 / Math.PI) % 360 + 360) % 360;
      // Find closest direction (0°, 60°, 120°, 180°, 240°, 300°)
      return Math.round(a / 60) % 6;
    }

    function tryStickAt(x, y) {
      // Check nearby particles
      const nearby = getNearbyParticles(x, y, PARTICLE_RADIUS * 2.5);
      
      for (const { particle, dist } of nearby) {
        if (dist < PARTICLE_RADIUS * 2) {
          // Contact! Compute direction from particle to walker
          const angle = Math.atan2(y - particle.y, x - particle.x);
          const dirIndex = getDirectionIndex(angle);
          const p = clamp01(settings.baseAdhesion * settings.dirMult[dirIndex]);
          
          if (Math.random() < p) {
            // Stick at contact point (slightly away from the particle we touched)
            const stickDist = PARTICLE_RADIUS * 2;
            const stickX = particle.x + Math.cos(angle) * stickDist;
            const stickY = particle.y + Math.sin(angle) * stickDist;
            return stickParticle(stickX, stickY);
          }
        }
      }
      return false;
    }

    function stepSimulation() {
      if (!walker) spawnWalker();

      const killR = maxRadius + KILL_MARGIN;
      
      // Check if too far
      if (Math.hypot(walker.x, walker.y) > killR) {
        spawnWalker();
        return;
      }

      // Perform multiple random-walk moves per tick
      for (let m = 0; m < MOVES_PER_TICK; m++) {
        // Random direction
        const angle = Math.random() * Math.PI * 2;
        walker.x += Math.cos(angle) * STEP_SIZE;
        walker.y += Math.sin(angle) * STEP_SIZE;

        // Killed?
        if (Math.hypot(walker.x, walker.y) > killR) {
          spawnWalker();
          return;
        }

        // Attempt stick if near any particle
        if (tryStickAt(walker.x, walker.y)) {
          walker = null;
          return;
        }
      }
    }

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }

    // ====== Render ======
    function render() {
      // background (in device pixels)
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#0b0d10';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // world transform (in CSS pixels, scaled by dpr)
      const scale = camera.zoom * dpr;
      ctx.setTransform(
        scale, 0, 0, scale,
        camera.cx * dpr - camera.x * scale,
        camera.cy * dpr - camera.y * scale
      );

      // draw stuck points with frustum culling
      const view = getWorldViewBounds();
      const pad = 40 / camera.zoom;
      const minX = view.minX - pad, maxX = view.maxX + pad;
      const minY = view.minY - pad, maxY = view.maxY + pad;

      const r = Math.max(0.5, PARTICLE_RADIUS * 0.5);
      const PI2 = Math.PI * 2;
      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) continue;
        ctx.fillStyle = p.c;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, PI2);
        ctx.fill();
      }

      // HUD text
      const radiusDisplay = Math.round(maxRadius);
      ui.hudLine.textContent =
        `Particles: ${stuckCount.toLocaleString()} | Radius: ${radiusDisplay} | Zoom: ${camera.zoom.toFixed(2)}` +
        (!running ? ' | STOPPED' : '');
    }

    function getWorldViewBounds() {
      const tl = screenToWorld(0, 0);
      const br = screenToWorld(window.innerWidth, window.innerHeight);
      return {
        minX: Math.min(tl.x, br.x),
        maxX: Math.max(tl.x, br.x),
        minY: Math.min(tl.y, br.y),
        maxY: Math.max(tl.y, br.y),
      };
    }

    // ====== Mouse: pan + zoom ======
    let dragging = false;
    let lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', (e) => {
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });
    window.addEventListener('mouseup', () => dragging = false);
    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      camera.x -= dx / camera.zoom;
      camera.y -= dy / camera.zoom;
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const mouse = { x: e.clientX, y: e.clientY };
      const before = screenToWorld(mouse.x, mouse.y);

      const zoomFactor = Math.exp((-e.deltaY) * 0.0015);
      const newZoom = Math.max(0.05, Math.min(40, camera.zoom * zoomFactor));
      camera.zoom = newZoom;

      const after = screenToWorld(mouse.x, mouse.y);
      camera.x += (before.x - after.x);
      camera.y += (before.y - after.y);
    }, { passive: false });

    // ====== Touch: pan + pinch zoom ======
    let touches = [];
    let lastTouchDist = 0;
    let lastTouchCenter = null;

    canvas.addEventListener('touchstart', (e) => {
      e.preventDefault();
      touches = Array.from(e.touches);
      
      if (touches.length === 1) {
        lastX = touches[0].clientX;
        lastY = touches[0].clientY;
        dragging = true;
      } else if (touches.length === 2) {
        dragging = false;
        lastTouchDist = Math.hypot(
          touches[1].clientX - touches[0].clientX,
          touches[1].clientY - touches[0].clientY
        );
        lastTouchCenter = {
          x: (touches[0].clientX + touches[1].clientX) / 2,
          y: (touches[0].clientY + touches[1].clientY) / 2
        };
      }
    }, { passive: false });

    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      touches = Array.from(e.touches);

      if (touches.length === 1 && dragging) {
        // Pan
        const dx = touches[0].clientX - lastX;
        const dy = touches[0].clientY - lastY;
        lastX = touches[0].clientX;
        lastY = touches[0].clientY;
        camera.x -= dx / camera.zoom;
        camera.y -= dy / camera.zoom;
      } else if (touches.length === 2) {
        // Pinch zoom
        const newDist = Math.hypot(
          touches[1].clientX - touches[0].clientX,
          touches[1].clientY - touches[0].clientY
        );
        const newCenter = {
          x: (touches[0].clientX + touches[1].clientX) / 2,
          y: (touches[0].clientY + touches[1].clientY) / 2
        };

        if (lastTouchDist > 0 && lastTouchCenter) {
          // Zoom
          const before = screenToWorld(newCenter.x, newCenter.y);
          const zoomFactor = newDist / lastTouchDist;
          camera.zoom = Math.max(0.05, Math.min(40, camera.zoom * zoomFactor));
          const after = screenToWorld(newCenter.x, newCenter.y);
          camera.x += (before.x - after.x);
          camera.y += (before.y - after.y);

          // Pan
          const dx = newCenter.x - lastTouchCenter.x;
          const dy = newCenter.y - lastTouchCenter.y;
          camera.x -= dx / camera.zoom;
          camera.y -= dy / camera.zoom;
        }

        lastTouchDist = newDist;
        lastTouchCenter = newCenter;
      }
    }, { passive: false });

    canvas.addEventListener('touchend', (e) => {
      e.preventDefault();
      touches = Array.from(e.touches);
      if (touches.length < 2) {
        lastTouchDist = 0;
        lastTouchCenter = null;
      }
      if (touches.length === 0) {
        dragging = false;
      } else if (touches.length === 1) {
        lastX = touches[0].clientX;
        lastY = touches[0].clientY;
        dragging = true;
      }
    }, { passive: false });

    canvas.addEventListener('touchcancel', () => {
      touches = [];
      dragging = false;
      lastTouchDist = 0;
      lastTouchCenter = null;
    });

    // ====== Buttons ======
    let running = false;
    let simInterval = null;
    let renderRAF = null;

    function updateSimulationInterval() {
      if (simInterval) {
        clearInterval(simInterval);
        simInterval = null;
      }
      if (running) {
        const interval = 1000 / Math.max(1, settings.targetFps);
        simInterval = setInterval(stepSimulation, interval);
      }
    }

    function startSimulation() {
      if (running) return;
      running = true;
      ui.start.textContent = 'Stop';
      ui.start.classList.add('running');
      updateSimulationInterval();
      startRenderLoop();
    }

    function stopSimulation() {
      running = false;
      ui.start.textContent = 'Start';
      ui.start.classList.remove('running');
      if (simInterval) {
        clearInterval(simInterval);
        simInterval = null;
      }
    }

    function startRenderLoop() {
      if (renderRAF) return;
      function renderLoop() {
        render();
        renderRAF = requestAnimationFrame(renderLoop);
      }
      renderRAF = requestAnimationFrame(renderLoop);
    }

    ui.start.addEventListener('click', () => {
      if (running) {
        stopSimulation();
      } else {
        startSimulation();
      }
    });

    ui.reset.addEventListener('click', () => {
      resetWorld();
      render();
    });

    ui.center.addEventListener('click', () => {
      camera.x = 0;
      camera.y = 0;
      camera.zoom = 1.0;
    });

    ui.saveImage.addEventListener('click', () => {
      // Render one frame to ensure canvas is up to date
      render();
      const link = document.createElement('a');
      link.download = `dla-${Date.now()}.png`;
      link.href = canvas.toDataURL('image/png');
      link.click();
    });

    // Settings toggle
    ui.settingsBtn.addEventListener('click', () => {
      ui.settingsBody.classList.toggle('collapsed');
    });

    // ====== Page visibility (background execution) ======
    document.addEventListener('visibilitychange', () => {
      // Simulation continues via setInterval even when page is hidden
      // Only rendering pauses (which is handled by rAF automatically)
    });

    // ====== Init ======
    function init() {
      resize();
      syncUIFromSettings();
      resetWorld();
      startRenderLoop();
      render();
    }
    init();
  </script>
</body>
</html>
