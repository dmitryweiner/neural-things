<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pseudo-Fractal (DLA)</title>
  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; overflow: hidden; background: #0b0d10; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    #wrap { position: fixed; inset: 0; }
    canvas { width: 100%; height: 100%; display: block; cursor: grab; }
    canvas:active { cursor: grabbing; }

    .panel {
      position: fixed;
      top: 12px; right: 12px;
      width: min(360px, calc(100vw - 24px));
      max-height: calc(100vh - 24px);
      overflow: auto;
      background: rgba(15, 18, 24, 0.92);
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 14px;
      padding: 12px 12px 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
      backdrop-filter: blur(10px);
    }
    .panel-header {
      display: flex; align-items: center; justify-content: space-between; gap: 8px;
      cursor: pointer; user-select: none;
    }
    .panel h2 {
      margin: 0; font-size: 14px; font-weight: 700; letter-spacing: .3px;
      display: flex; align-items: center; gap: 8px;
    }
    .panel .sub { margin: 8px 0 10px; font-size: 12px; opacity: .75; line-height: 1.25; }
    .panel-body.collapsed { display: none; }
    .collapse-btn {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e8eefc;
      border-radius: 8px;
      width: 28px; height: 28px;
      font-size: 12px;
      cursor: pointer;
      display: flex; align-items: center; justify-content: center;
    }
    .collapse-btn:hover { background: rgba(255,255,255,0.10); }
    .row { display: grid; grid-template-columns: 1fr auto; gap: 10px; align-items: center; margin: 8px 0; }
    .row > label { font-size: 12px; opacity: .9; }
    .row input[type="range"] { width: 180px; }
    .row input[type="number"] { width: 90px; }
    .row select, .row input[type="color"], .row input[type="number"] {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e8eefc;
      border-radius: 10px;
      padding: 6px 8px;
      font-size: 12px;
      outline: none;
    }
    .row .chk { display: flex; align-items: center; gap: 8px; }
    .row .chk input { transform: translateY(1px); }

    .btns { display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap; }
    button {
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.12);
      color: #e8eefc;
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      cursor: pointer;
      user-select: none;
    }
    button:hover { background: rgba(255,255,255,0.11); }
    button:active { transform: translateY(1px); }

    .divider { height: 1px; background: rgba(255,255,255,0.10); margin: 10px 0; }

    .dir-grid { display: grid; grid-template-columns: 1fr; gap: 8px; }
    .dir-item { display: grid; grid-template-columns: 72px 1fr 48px; gap: 8px; align-items: center; }
    .dir-item .tag { font-size: 11px; opacity: .9; }
    .dir-item input[type="range"] { width: 100%; }
    .dir-item .val { font-size: 11px; opacity: .85; text-align: right; }

    .hud {
      position: fixed;
      left: 12px; bottom: 12px;
      font-size: 12px;
      opacity: .75;
      background: rgba(15, 18, 24, 0.55);
      border: 1px solid rgba(255,255,255,0.10);
      border-radius: 12px;
      padding: 8px 10px;
      user-select: none;
    }
    .kbd { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; opacity: .9; }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="c"></canvas>

    <div class="panel" id="panel">
      <div class="panel-header" id="panelHeader">
        <h2>Pseudo-Fractal (DLA)</h2>
        <button class="collapse-btn" id="collapseBtn">▼</button>
      </div>
      <div class="panel-body" id="panelBody">
      <p class="sub">
        A particle wanders on a hex grid and sticks to the cluster. Set unequal directional probabilities to create "snowflake" patterns.
      </p>

      <div class="row">
        <label for="fps">World speed (FPS)</label>
        <input id="fps" type="number" min="1" max="240" step="1" value="60" />
      </div>

      <div class="row">
        <label>Show moving particle</label>
        <div class="chk"><input id="showWalker" type="checkbox" checked /></div>
      </div>

      <div class="row">
        <label for="colorMode">Particle color</label>
        <select id="colorMode">
          <option value="constant">Constant</option>
          <option value="rainbow" selected>Rainbow (by time)</option>
        </select>
      </div>

      <div class="row" id="constColorRow" style="display:none;">
        <label for="constColor">Constant color</label>
        <input id="constColor" type="color" value="#8ad1ff" />
      </div>

      <div class="row" id="hueStepRow">
        <label for="hueStep">Rainbow step (hue degrees)</label>
        <input id="hueStep" type="number" min="1" max="90" step="1" value="3" />
      </div>

      <div class="divider"></div>

      <div class="row">
        <label for="baseAdh">Base adhesion</label>
        <input id="baseAdh" type="range" min="0" max="1" step="0.01" value="0.35" />
      </div>

      <div class="row">
        <label>Direction presets</label>
        <div style="display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end;">
          <button id="presetIso">Isotropic</button>
          <button id="preset120">120°</button>
          <button id="preset60">60° (strict)</button>
        </div>
      </div>

      <div class="dir-grid" id="dirGrid"></div>

      <div class="divider"></div>

      <div class="btns">
        <button id="reset">Reset</button>
        <button id="pause">Pause</button>
        <button id="step">Step</button>
        <button id="center">Center view</button>
      </div>
      </div>
    </div>

    <div class="hud" id="hud">
      <div><span class="kbd">Wheel</span> — zoom, <span class="kbd">Drag</span> — pan</div>
      <div id="hudLine"></div>
    </div>
  </div>

  <script>
    // No build step. Single page. Single canvas.

    // ====== Canvas / camera ======
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d', { alpha: false });

    function resize() {
      const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
      canvas.width = Math.floor(window.innerWidth * dpr);
      canvas.height = Math.floor(window.innerHeight * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // draw in CSS pixels
      camera.cx = window.innerWidth / 2;
      camera.cy = window.innerHeight / 2;
    }
    window.addEventListener('resize', resize);

    const camera = {
      x: 0, y: 0, // world coordinates (in world pixels)
      zoom: 1.0,  // scale
      cx: window.innerWidth / 2,
      cy: window.innerHeight / 2,
    };

    function screenToWorld(sx, sy) {
      return {
        x: (sx - camera.cx) / camera.zoom + camera.x,
        y: (sy - camera.cy) / camera.zoom + camera.y,
      };
    }

    // ====== Hex grid (axial coords) ======
    // axial (q,r). Directions correspond to angles 0°,60°,120°,180°,240°,300°
    const HEX_DIRS = [
      { q:  1, r:  0, ang: 0   },
      { q:  1, r: -1, ang: 60  },
      { q:  0, r: -1, ang: 120 },
      { q: -1, r:  0, ang: 180 },
      { q: -1, r:  1, ang: 240 },
      { q:  0, r:  1, ang: 300 },
    ];
    function hexOpp(i) { return (i + 3) % 6; }

    function hexKey(q, r) { return q + ',' + r; }

    function hexDist(q, r) {
      // cube coords: x=q, z=r, y=-x-z
      const x = q, z = r, y = -x - z;
      return Math.max(Math.abs(x), Math.abs(y), Math.abs(z));
    }

    // Hex to pixel (pointy-top). We'll treat this as "world pixels".
    let HEX_SIZE = 3; // size in world pixels; camera zoom scales it anyway
    function hexToPixel(q, r) {
      // pointy-top axial -> pixel
      // x = size * sqrt(3) * (q + r/2)
      // y = size * 3/2 * r
      const x = HEX_SIZE * Math.sqrt(3) * (q + r / 2);
      const y = HEX_SIZE * 1.5 * r;
      return { x, y };
    }

    // ====== Settings ======
    const ui = {
      fps: document.getElementById('fps'),
      showWalker: document.getElementById('showWalker'),
      colorMode: document.getElementById('colorMode'),
      constColorRow: document.getElementById('constColorRow'),
      constColor: document.getElementById('constColor'),
      hueStepRow: document.getElementById('hueStepRow'),
      hueStep: document.getElementById('hueStep'),
      baseAdh: document.getElementById('baseAdh'),

      dirGrid: document.getElementById('dirGrid'),
      presetIso: document.getElementById('presetIso'),
      preset120: document.getElementById('preset120'),
      preset60: document.getElementById('preset60'),

      reset: document.getElementById('reset'),
      pause: document.getElementById('pause'),
      step: document.getElementById('step'),
      center: document.getElementById('center'),

      hudLine: document.getElementById('hudLine'),
      panelHeader: document.getElementById('panelHeader'),
      panelBody: document.getElementById('panelBody'),
      collapseBtn: document.getElementById('collapseBtn'),
    };

    const settings = {
      targetFps: 60,
      showWalker: true,

      colorMode: 'rainbow', // 'constant' | 'rainbow'
      constantColor: '#8ad1ff',
      hueStep: 3,

      baseAdhesion: 0.35,   // 0..1
      dirMult: [1,1,1,1,1,1], // multipliers for 6 directions (angles above)
    };

    function syncUIFromSettings() {
      ui.fps.value = String(settings.targetFps);
      ui.showWalker.checked = settings.showWalker;

      ui.colorMode.value = settings.colorMode;
      ui.constColor.value = settings.constantColor;
      ui.hueStep.value = String(settings.hueStep);

      ui.baseAdh.value = String(settings.baseAdhesion);

      ui.constColorRow.style.display = (settings.colorMode === 'constant') ? '' : 'none';
      ui.hueStepRow.style.display = (settings.colorMode === 'rainbow') ? '' : 'none';

      renderDirControls();
    }

    function renderDirControls() {
      ui.dirGrid.innerHTML = '';
      for (let i = 0; i < 6; i++) {
        const wrap = document.createElement('div');
        wrap.className = 'dir-item';

        const tag = document.createElement('div');
        tag.className = 'tag';
        tag.textContent = HEX_DIRS[i].ang + '°';

        const rng = document.createElement('input');
        rng.type = 'range';
        rng.min = '0';
        rng.max = '2';
        rng.step = '0.01';
        rng.value = String(settings.dirMult[i]);

        const val = document.createElement('div');
        val.className = 'val';
        val.textContent = settings.dirMult[i].toFixed(2) + '×';

        rng.addEventListener('input', () => {
          settings.dirMult[i] = parseFloat(rng.value);
          val.textContent = settings.dirMult[i].toFixed(2) + '×';
        });

        wrap.appendChild(tag);
        wrap.appendChild(rng);
        wrap.appendChild(val);
        ui.dirGrid.appendChild(wrap);
      }
    }

    // UI handlers
    ui.fps.addEventListener('change', () => {
      const v = Math.max(1, Math.min(240, parseInt(ui.fps.value || '60', 10)));
      settings.targetFps = v;
      ui.fps.value = String(v);
    });

    ui.showWalker.addEventListener('change', () => {
      settings.showWalker = ui.showWalker.checked;
    });

    ui.colorMode.addEventListener('change', () => {
      settings.colorMode = ui.colorMode.value;
      syncUIFromSettings();
    });

    ui.constColor.addEventListener('change', () => {
      settings.constantColor = ui.constColor.value;
    });

    ui.hueStep.addEventListener('change', () => {
      const v = Math.max(1, Math.min(90, parseInt(ui.hueStep.value || '3', 10)));
      settings.hueStep = v;
      ui.hueStep.value = String(v);
    });

    ui.baseAdh.addEventListener('input', () => {
      settings.baseAdhesion = parseFloat(ui.baseAdh.value);
    });

    ui.presetIso.addEventListener('click', () => {
      settings.dirMult = [1,1,1,1,1,1];
      renderDirControls();
    });

    ui.preset120.addEventListener('click', () => {
      // peaks at 120° intervals: 0°, 120°, 240° strong; others weaker
      settings.dirMult = [1.8, 0.2, 1.8, 0.2, 1.8, 0.2];
      renderDirControls();
    });

    ui.preset60.addEventListener('click', () => {
      // "strict": sticks equally in all 6 directions with high multiplier
      settings.dirMult = [2,2,2,2,2,2];
      renderDirControls();
    });

    // ====== Simulation ======
    let occupied = new Set(); // keys "q,r"
    let points = [];          // stuck particles with cached pixel coords + color
    let walker = null;        // current moving particle
    let stuckCount = 0;
    let maxRadius = 0;

    // World parameters (feel free to tweak)
    const SPAWN_MARGIN = 12;  // in hex steps
    const KILL_MARGIN  = 28;  // in hex steps
    const MOVES_PER_TICK = 200; // how many random-walk steps we do per "world frame"

    function resetWorld() {
      occupied = new Set();
      points = [];
      walker = null;
      stuckCount = 0;
      maxRadius = 0;

      // First stuck particle at center
      stickParticle(0, 0);
      // camera center
      const p = hexToPixel(0, 0);
      camera.x = p.x;
      camera.y = p.y;
    }

    function colorForIndex(i) {
      if (settings.colorMode === 'constant') return settings.constantColor;
      const h = (i * settings.hueStep) % 360;
      // bright-ish HSL
      return `hsl(${h} 95% 65%)`;
    }

    function stickParticle(q, r) {
      const k = hexKey(q, r);
      if (occupied.has(k)) return false;
      occupied.add(k);

      const pix = hexToPixel(q, r);
      const col = colorForIndex(stuckCount);
      points.push({ q, r, x: pix.x, y: pix.y, c: col });

      stuckCount++;
      maxRadius = Math.max(maxRadius, hexDist(q, r));
      return true;
    }

    function spawnWalker() {
      // spawn on ring around current maxRadius
      const R = maxRadius + SPAWN_MARGIN;
      const a = Math.random() * Math.PI * 2;
      // pick an approximate axial position from pixel circle and then "snap" by sampling candidates
      // We do a simpler honest trick: pick a random direction and step R along it, then jitter a bit.
      const dir = Math.floor(Math.random() * 6);
      let q = HEX_DIRS[dir].q * R;
      let r = HEX_DIRS[dir].r * R;

      // jitter a bit by random walks
      const jitter = 6 + Math.floor(Math.random() * 10);
      for (let i = 0; i < jitter; i++) {
        const d = Math.floor(Math.random() * 6);
        q += HEX_DIRS[d].q;
        r += HEX_DIRS[d].r;
      }
      walker = { q, r };
    }

    function tryStickAt(q, r) {
      // Check neighbors: if any occupied, attempt adhesion with direction multiplier
      for (let i = 0; i < 6; i++) {
        const nq = q + HEX_DIRS[i].q;
        const nr = r + HEX_DIRS[i].r;
        if (occupied.has(hexKey(nq, nr))) {
          // Contact direction: vector from walker -> occupied neighbor is opposite of i
          const contactDir = hexOpp(i);
          const p = clamp01(settings.baseAdhesion * settings.dirMult[contactDir]);
          if (Math.random() < p) {
            return stickParticle(q, r);
          }
          // if it didn't stick via this neighbor, we still might stick via another neighbor this step
        }
      }
      return false;
    }

    function stepSimulation() {
      if (!walker) spawnWalker();

      // kill if too far
      const killR = maxRadius + KILL_MARGIN;
      if (hexDist(walker.q, walker.r) > killR) {
        spawnWalker();
        return;
      }

      // perform multiple random-walk moves per tick
      for (let m = 0; m < MOVES_PER_TICK; m++) {
        const d = Math.floor(Math.random() * 6);
        walker.q += HEX_DIRS[d].q;
        walker.r += HEX_DIRS[d].r;

        // killed?
        if (hexDist(walker.q, walker.r) > killR) {
          spawnWalker();
          return;
        }

        // attempt stick if adjacent
        if (tryStickAt(walker.q, walker.r)) {
          walker = null; // next tick spawn a new one
          return;
        }
      }
    }

    function clamp01(x) { return Math.max(0, Math.min(1, x)); }

    // ====== Render ======
    function render() {
      // background
      ctx.save();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = '#0b0d10';
      ctx.fillRect(0, 0, window.innerWidth, window.innerHeight);
      ctx.restore();

      // world transform
      ctx.save();
      ctx.setTransform(
        camera.zoom, 0, 0, camera.zoom,
        camera.cx - camera.x * camera.zoom,
        camera.cy - camera.y * camera.zoom
      );

      // draw stuck points
      // (simple iteration; tolerable for demos with tens of thousands of points; can optimize with chunks later)
      const view = getWorldViewBounds();
      const pad = 40 / camera.zoom;
      const minX = view.minX - pad, maxX = view.maxX + pad;
      const minY = view.minY - pad, maxY = view.maxY + pad;

      // choose point radius in world coords
      const r = Math.max(0.5, HEX_SIZE * 0.45);
      const PI2 = Math.PI * 2;
      for (let i = 0; i < points.length; i++) {
        const p = points[i];
        if (p.x < minX || p.x > maxX || p.y < minY || p.y > maxY) continue;
        ctx.fillStyle = p.c;
        ctx.beginPath();
        ctx.arc(p.x, p.y, r, 0, PI2);
        ctx.fill();
      }

      // draw walker
      if (settings.showWalker && walker) {
        const wp = hexToPixel(walker.q, walker.r);
        ctx.fillStyle = '#ffffff';
        const wr = Math.max(0.7, HEX_SIZE * 0.55);
        ctx.beginPath();
        ctx.arc(wp.x, wp.y, wr, 0, PI2);
        ctx.fill();
      }

      ctx.restore();

      // HUD text
      ui.hudLine.textContent =
        `Particles: ${stuckCount.toLocaleString()} | Radius: ${maxRadius} | Zoom: ${camera.zoom.toFixed(2)}` +
        (paused ? ' | PAUSED' : '');
    }

    function getWorldViewBounds() {
      // convert screen corners to world
      const tl = screenToWorld(0, 0);
      const br = screenToWorld(window.innerWidth, window.innerHeight);
      return {
        minX: Math.min(tl.x, br.x),
        maxX: Math.max(tl.x, br.x),
        minY: Math.min(tl.y, br.y),
        maxY: Math.max(tl.y, br.y),
      };
    }

    // ====== Mouse / touch: pan + zoom ======
    let dragging = false;
    let lastX = 0, lastY = 0;

    canvas.addEventListener('mousedown', (e) => {
      dragging = true;
      lastX = e.clientX;
      lastY = e.clientY;
    });
    window.addEventListener('mouseup', () => dragging = false);
    window.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const dx = e.clientX - lastX;
      const dy = e.clientY - lastY;
      lastX = e.clientX; lastY = e.clientY;
      camera.x -= dx / camera.zoom;
      camera.y -= dy / camera.zoom;
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault();
      const mouse = { x: e.clientX, y: e.clientY };
      const before = screenToWorld(mouse.x, mouse.y);

      const zoomFactor = Math.exp((-e.deltaY) * 0.0015);
      const newZoom = Math.max(0.05, Math.min(40, camera.zoom * zoomFactor));
      camera.zoom = newZoom;

      const after = screenToWorld(mouse.x, mouse.y);
      camera.x += (before.x - after.x);
      camera.y += (before.y - after.y);
    }, { passive: false });

    // ====== Buttons ======
    let paused = false;

    ui.reset.addEventListener('click', () => resetWorld());
    ui.pause.addEventListener('click', () => {
      paused = !paused;
      ui.pause.textContent = paused ? 'Resume' : 'Pause';
    });
    ui.step.addEventListener('click', () => {
      // one simulation tick
      stepSimulation();
      render();
    });
    ui.center.addEventListener('click', () => {
      // Center view on origin (0,0)
      const p = hexToPixel(0, 0);
      camera.x = p.x;
      camera.y = p.y;
      camera.zoom = 1.0;
    });

    // Panel collapse
    ui.panelHeader.addEventListener('click', () => {
      const collapsed = ui.panelBody.classList.toggle('collapsed');
      ui.collapseBtn.textContent = collapsed ? '▶' : '▼';
    });

    // ====== Main loop (rAF + target fps for simulation) ======
    let lastTime = performance.now();
    let accum = 0;

    function loop(now) {
      requestAnimationFrame(loop);
      const dt = now - lastTime;
      lastTime = now;
      accum += dt;

      const frameInterval = 1000 / Math.max(1, settings.targetFps);

      // simulate at target fps, render every rAF (for smooth zoom/pan)
      if (!paused) {
        // Cap accumulated time so the universe doesn't "fast-forward" after tab-switch
        accum = Math.min(accum, frameInterval * 5);
        while (accum >= frameInterval) {
          accum -= frameInterval;
          stepSimulation();
        }
      } else {
        accum = 0;
      }

      render();
    }

    // ====== Init ======
    function init() {
      resize();
      syncUIFromSettings();
      resetWorld();
      requestAnimationFrame(loop);
    }
    init();
  </script>
</body>
</html>
