<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Formula Audio Lab</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color-scheme: dark; }
    body { margin: 0; background:#0b0f14; color:#e8eef6; }

    .topbar {
      position: sticky;
      top: 0;
      z-index: 20;
      background:#0d131b;
      border-bottom: 1px solid #1d2a3a;
      padding: 12px 14px;
    }
    .topbar h1 { margin: 0 0 10px; font-size: 16px; font-weight: 750; }

    .row { display:flex; gap:10px; flex-wrap: wrap; align-items:center; }

    button {
      background:#1d3557; color:#fff; border:0; padding:9px 11px;
      border-radius:10px; cursor:pointer; font-weight:650;
    }
    button:disabled { opacity:.5; cursor:not-allowed; }

    .collapseBtn{
      background:#0f1b29;
      border:1px solid #1d2a3a;
      color:#cfe1ff;
      padding:6px 10px;
      border-radius: 999px;
      font-weight:650;
      cursor:pointer;
    }

    .pill {
      padding:6px 10px;
      border-radius:999px;
      background:#0f1b29;
      border:1px solid #1d2a3a;
      font-size:12px;
      color:#bcd0e6;
      white-space: nowrap;
    }

    .meter {
      display:flex; align-items:center; gap:10px;
      padding:6px 10px; border-radius:999px;
      background:#0f1b29; border:1px solid #1d2a3a;
      font-size:12px; color:#bcd0e6;
    }
    .lamp{
      width:10px; height:10px; border-radius:50%;
      border:1px solid #1d2a3a;
      background:#1a2330;
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.35);
    }
    .lamp.on{
      background:#ff3b30;
      box-shadow: 0 0 10px rgba(255,59,48,.65);
      border-color: rgba(255,59,48,.65);
    }
    .meter b{ color:#e8eef6; font-weight: 700; }

    .topgrid{
      display:grid;
      grid-template-columns: 1fr 340px;
      gap: 12px;
      align-items: start;
      margin-top: 10px;
    }
    @media (max-width: 980px){
      .topgrid{ grid-template-columns: 1fr; }
    }

    .scopeWrap{
      border:1px solid #1d2a3a;
      border-radius: 12px;
      background:#060a0f;
      padding: 8px;
    }

    .scopeHeader{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .scopeHeader .left { display:flex; align-items:center; gap:10px; }
    .scopeTitle { font-size: 12px; color:#bcd0e6; }
    canvas { width:100%; height: 120px; display:block; border-radius: 10px; }

    .ctrl { display:grid; grid-template-columns: 130px 1fr 70px; gap: 10px; align-items: center; margin-top: 8px;}
    .ctrl label { font-size: 12px; color:#cfe1ff; }
    input[type="range"] { width: 100%; }
    input[type="checkbox"] { transform: scale(1.15); }
    select {
      background:#0f1b29; color:#e8eef6;
      border:1px solid #1d2a3a; border-radius:10px;
      padding: 8px 10px;
    }
    .small { font-size: 11px; color:#9fb6d3; }

    .effectsPanel{
      margin-top: 10px;
      border:1px solid #1d2a3a;
      border-radius: 14px;
      padding: 12px;
      background:#0b1119;
      display:none;
    }
    .effectsPanel.open{ display:block; }
    .effectsGrid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    @media (max-width: 980px){
      .effectsGrid{ grid-template-columns: 1fr; }
    }
    .fxCard{
      background:#0d131b;
      border:1px solid #1d2a3a;
      border-radius: 14px;
      padding: 12px;
      box-shadow: 0 10px 24px rgba(0,0,0,.22);
    }
    .fxCard h2 { margin: 0 0 8px; font-size: 13px; color:#d9e7ff; display:flex; justify-content:space-between; align-items:center; }
    .sep { height:1px; background:#1d2a3a; margin: 10px 0; }

    main { padding: 14px; max-width: 1200px; margin: 0 auto; }
    .card {
      background:#0d131b; border: 1px solid #1d2a3a; border-radius: 14px;
      padding: 14px; box-shadow: 0 10px 24px rgba(0,0,0,.25);
      margin-top: 14px;
    }
    .card h2 { margin:0 0 10px; font-size:14px; color:#d9e7ff;}

    .formula { border-top:1px solid #1d2a3a; padding-top: 12px; margin-top: 12px; }
    .formula:first-child { border-top:0; padding-top:0; margin-top:0; }
    .fhead { display:flex; justify-content: space-between; gap: 10px; align-items: baseline; }
    .fhead h3 { margin:0; font-size: 13px; display:flex; align-items:center; gap:10px; }
    .tag { font-size: 11px; color:#bcd0e6; background:#0f1b29; border:1px solid #1d2a3a; padding:3px 8px; border-radius: 999px; }
    .factions{ display:flex; gap: 8px; align-items:center; flex-wrap:wrap; }
    .fbody{ margin-top: 10px; }
    .fbody.collapsed{ display:none; }

    /* Scope collapsing */
    .scopeArea{ display:block; }
    .scopeWrap.scopeCollapsed .scopeArea{ display:none; }

    /* Mobile: start with collapsed scope to save height */
    @media (max-width: 600px){
      .scopeWrap{ padding: 8px; }
      .scopeWrap.scopeCollapsed .scopeArea{ display:none; }
    }
  </style>
</head>

<body>

<section class="topbar">
  <h1>Formula Audio Lab — формулы как звук</h1>

  <div class="row">
    <button id="startBtn">Start Audio</button>
    <button id="stopBtn" disabled>Stop</button>
    <button id="recBtn" disabled>Record WAV</button>

    <button id="savePresetBtn" class="collapseBtn" type="button">Сохранить пресет</button>
    <button id="loadPresetBtn" class="collapseBtn" type="button">Загрузить пресет</button>
    <button id="shareBtn" class="collapseBtn" type="button">Поделиться</button>

    <span class="pill" id="status">Status: not started</span>

    <span class="meter">
      <span class="lamp" id="clipLamp" title="CLIP"></span>
      <b>CLIP</b>
      <span>RMS:</span>
      <span id="rmsVal">—</span>
    </span>

    <button id="effectsBtn" class="collapseBtn" type="button">Effects ▾</button>
  </div>

  <div class="topgrid">
    <div class="scopeWrap" id="scopeWrap">
      <div class="scopeHeader">
        <div class="left">
          <span class="scopeTitle">Oscilloscope</span>
          <button id="scopeToggleBtn" class="collapseBtn" type="button">Scope ▾</button>
        </div>
      </div>

      <div class="scopeArea" id="scopeArea">
        <canvas id="scope"></canvas>
        <div class="ctrl">
          <label>Master volume</label>
          <input id="masterGain" type="range" min="0" max="1" step="0.001" value="0.25">
          <div class="small" id="masterGainVal">0.25</div>
        </div>
      </div>
    </div>

    <div>
      <!-- специально пусто/минимально, чтобы на мобиле не “съедать” экран -->
    </div>
  </div>

  <div id="effectsPanel" class="effectsPanel">
    <div class="effectsGrid">

      <div class="fxCard">
        <h2>
          <span>Filter (Biquad)</span>
          <label class="small"><input id="fxFilterOn" type="checkbox"> ON</label>
        </h2>
        <div class="ctrl">
          <label>Type</label>
          <select id="fxFilterType">
            <option value="lowpass">Low-pass</option>
            <option value="highpass">High-pass</option>
            <option value="bandpass">Band-pass</option>
          </select>
          <div></div>
        </div>
        <div class="ctrl">
          <label>Cutoff (Hz)</label>
          <input id="fxFilterFreq" type="range" min="20" max="18000" step="1" value="12000">
          <div class="small" id="fxFilterFreqVal">12000</div>
        </div>
        <div class="ctrl">
          <label>Q</label>
          <input id="fxFilterQ" type="range" min="0.1" max="30" step="0.1" value="0.7">
          <div class="small" id="fxFilterQVal">0.7</div>
        </div>
      </div>

      <div class="fxCard">
        <h2>
          <span>Chorus / Flanger</span>
          <label class="small"><input id="fxChorusOn" type="checkbox"> ON</label>
        </h2>
        <div class="ctrl">
          <label>Mode</label>
          <select id="fxChorusMode">
            <option value="chorus">Chorus</option>
            <option value="flanger">Flanger</option>
          </select>
          <div></div>
        </div>
        <div class="ctrl">
          <label>Rate (Hz)</label>
          <input id="fxChorusRate" type="range" min="0.01" max="8" step="0.01" value="0.35">
          <div class="small" id="fxChorusRateVal">0.35</div>
        </div>
        <div class="ctrl">
          <label>Depth (ms)</label>
          <input id="fxChorusDepth" type="range" min="0" max="20" step="0.1" value="6">
          <div class="small" id="fxChorusDepthVal">6.0</div>
        </div>
        <div class="ctrl">
          <label>Mix (dry↔wet)</label>
          <input id="fxChorusMix" type="range" min="0" max="1" step="0.001" value="0.35">
          <div class="small" id="fxChorusMixVal">0.35</div>
        </div>
        <div class="ctrl">
          <label>Feedback</label>
          <input id="fxChorusFb" type="range" min="0" max="0.95" step="0.001" value="0.15">
          <div class="small" id="fxChorusFbVal">0.15</div>
        </div>
      </div>

      <div class="fxCard">
        <h2>
          <span>Reverb (Convolver)</span>
          <label class="small"><input id="fxReverbOn" type="checkbox"> ON</label>
        </h2>
        <div class="ctrl">
          <label>Decay (s)</label>
          <input id="fxReverbDecay" type="range" min="0.1" max="8" step="0.1" value="2.8">
          <div class="small" id="fxReverbDecayVal">2.8</div>
        </div>
        <div class="ctrl">
          <label>Mix (dry↔wet)</label>
          <input id="fxReverbMix" type="range" min="0" max="1" step="0.001" value="0.25">
          <div class="small" id="fxReverbMixVal">0.25</div>
        </div>
      </div>

      <div class="fxCard">
        <h2>
          <span>Limiter (anti-clip)</span>
          <label class="small"><input id="fxLimiterOn" type="checkbox"> ON</label>
        </h2>
        <div class="ctrl">
          <label>Threshold (dB)</label>
          <input id="fxLimiterThr" type="range" min="-40" max="0" step="0.5" value="-12">
          <div class="small" id="fxLimiterThrVal">-12</div>
        </div>
        <div class="ctrl">
          <label>Release (s)</label>
          <input id="fxLimiterRel" type="range" min="0.02" max="1" step="0.01" value="0.15">
          <div class="small" id="fxLimiterRelVal">0.15</div>
        </div>
      </div>

    </div>
  </div>
</section>

<main>
  <section class="card">
    <h2>Формулы (можно включать одновременно)</h2>
    <div id="formulas"></div>
  </section>
</main>

<script>
(async function(){
  // ---------- AudioWorklet code (generator only) ----------
  const workletCode = `
  class FormulaGeneratorProcessor extends AudioWorkletProcessor {
    constructor(options){
      super();
      const o = (options && options.processorOptions) || {};
      this.formula = o.formula || 'fm';
      this.sr = sampleRate;
      this.t = 0;
      this.phase = 0;

      this.logi = 0.33;
      this.lx = 0.1; this.ly = 0.0; this.lz = 0.0;

      this.ksBuf = null; this.ksIdx = 0; this.ksN = 0;
      this.nlp = 0;

      this.bcHold = 0; this.bcCount = 0;

      this.p = Object.assign({
        gain: 0.2,
        fc: 220, fm: 2, I: 2,
        f1: 220, f2: 221,
        base: 110, depth: 330, r: 3.86, lfoHz: 40,
        f0: 55, k: 0.15,
        fund: 110, N: 12, move: 0.35,
        f: 220, f2pm: 3,
        fbeat: 220, df: 0.8,
        fd: 110, alpha: 3.0,
        fq: 120, Aq: 220, wq: 0.8,
        sigma: 10, rho: 28, beta: 2.6667,
        lBase: 120, lFreqScale: 40, lAmp: 0.25,
        ksFreq: 110, ksDamp: 0.985, ksBright: 0.5,
        bcFreq: 220, bcBits: 6, bcDown: 8,
        nCut: 800
      }, o.params || {});

      this.port.onmessage = (e) => {
        const msg = e.data || {};
        if (msg.type === 'set') {
          for (const [k,v] of Object.entries(msg.params || {})) this.p[k] = v;
        } else if (msg.type === 'reset') {
          this.t = 0; this.phase = 0;
          this.logi = 0.33;
          this.lx = 0.1; this.ly = 0.0; this.lz = 0.0;
          this.nlp = 0; this.bcHold = 0; this.bcCount = 0;
          this._initKS(true);
        }
      };

      this._initKS(true);
    }
    clamp(x,a,b){ return Math.max(a, Math.min(b, x)); }
    _initKS(force){
      const p = this.p;
      const freq = Math.max(20, p.ksFreq || 110);
      const N = Math.max(2, Math.floor(this.sr / freq));
      if (!force && this.ksBuf && this.ksN === N) return;
      this.ksN = N; this.ksBuf = new Float32Array(N); this.ksIdx = 0;
      for (let i=0;i<N;i++) this.ksBuf[i] = (Math.random()*2 - 1);
    }
    process(inputs, outputs){
      const out = outputs[0];
      const ch0 = out[0];
      const n = ch0.length;
      const sr = this.sr;
      const twoPi = 2*Math.PI;

      let p = this.p;
      let phase = this.phase;
      let t = this.t;
      let logi = this.logi;
      let lx = this.lx, ly = this.ly, lz = this.lz;
      let nlp = this.nlp;
      let bcHold = this.bcHold, bcCount = this.bcCount;

      for (let i=0;i<n;i++){
        let x = 0;
        switch(this.formula){
          case 'fm': x = Math.sin(twoPi*p.fc*t + (p.I)*Math.sin(twoPi*p.fm*t)); break;
          case 'am': x = Math.sin(twoPi*p.f1*t) * Math.sin(twoPi*p.f2*t); break;
          case 'logistic': {
            const step = Math.max(1, Math.floor(sr / Math.max(1e-3, p.lfoHz)));
            if ((i % step) === 0){ logi = (p.r) * logi * (1 - logi); logi = this.clamp(logi,0,1); }
            const f = p.base + p.depth * (logi - 0.5);
            phase += twoPi * (Math.max(0, f) / sr);
            x = Math.sin(phase);
            break;
          }
          case 'gliss': {
            const f = p.f0 * Math.exp(p.k * t);
            phase += twoPi * (f / sr);
            x = Math.sin(phase);
            break;
          }
          case 'additive': {
            const fund = p.fund;
            const N = Math.max(1, Math.floor(p.N));
            const move = p.move;
            let s = 0;
            for (let k=1;k<=N;k++){
              const ak = (1/k) * Math.sin(twoPi*move*t + k);
              s += ak * Math.sin(twoPi*(k*fund)*t);
            }
            x = s * (1.0 / Math.log2(N+1));
            break;
          }
          case 'pm': {
            const phi = Math.sin(Math.sin(twoPi*p.f2pm*t));
            x = Math.sin(twoPi*p.f*t + phi*5.0);
            break;
          }
          case 'beats': x = 0.5*(Math.sin(twoPi*p.fbeat*t) + Math.sin(twoPi*(p.fbeat + p.df)*t)); break;
          case 'dist': x = Math.tanh(p.alpha * Math.sin(twoPi*p.fd*t)); break;
          case 'quasi': {
            const mod = Math.sin(Math.sin(Math.sin(p.wq * t)));
            const f = Math.max(0, p.fq + p.Aq*mod);
            phase += twoPi * (f / sr);
            x = Math.sin(phase);
            break;
          }
          case 'lorenz': {
            const dt = 1/sr;
            const dx = p.sigma * (ly - lx);
            const dy = lx * (p.rho - lz) - ly;
            const dz = lx * ly - p.beta * lz;
            lx += dx * dt; ly += dy * dt; lz += dz * dt;

            const freq = Math.max(0, p.lBase + p.lFreqScale * Math.abs(lx));
            const amp = this.clamp(p.lAmp * (0.3 + 0.7 * (0.5 + 0.5*Math.tanh(ly))), 0, 1);
            phase += twoPi * (freq / sr);
            x = amp * Math.sin(phase);
            break;
          }
          case 'karplus': {
            this._initKS(false);
            const buf = this.ksBuf, N = this.ksN;
            const idx = this.ksIdx;
            const y0 = buf[idx];
            const y1 = buf[(idx + 1) % N];
            const damp = this.clamp(p.ksDamp, 0.8, 0.99999);
            const bright = this.clamp(p.ksBright, 0, 1);
            const avg = 0.5 * (y0 + y1);
            const next = damp * (bright * y0 + (1 - bright) * avg);
            buf[idx] = next;
            this.ksIdx = (idx + 1) % N;
            x = y0;
            break;
          }
          case 'bitcrush': {
            const f = Math.max(0, p.bcFreq);
            phase += twoPi * (f / sr);
            const raw = Math.sin(phase);
            const down = Math.max(1, Math.floor(p.bcDown));
            if (bcCount <= 0) {
              bcCount = down;
              const bits = this.clamp(Math.floor(p.bcBits), 1, 16);
              const levels = Math.pow(2, bits - 1);
              bcHold = Math.round(raw * levels) / levels;
            }
            bcCount--;
            x = bcHold;
            break;
          }
          case 'noiselp': {
            const white = (Math.random()*2 - 1);
            const cut = this.clamp(p.nCut, 20, 18000);
            const a = 1 - Math.exp(-2*Math.PI*cut/sr);
            nlp = nlp + a * (white - nlp);
            x = nlp;
            break;
          }
          default: x = 0;
        }

        ch0[i] = x * (p.gain ?? 0.2);
        t += 1/sr;
        if (phase > 1e9) phase %= twoPi;
      }

      this.phase = phase; this.t = t; this.logi = logi;
      this.lx = lx; this.ly = ly; this.lz = lz;
      this.nlp = nlp; this.bcHold = bcHold; this.bcCount = bcCount;
      return true;
    }
  }

  registerProcessor('formula-generator', FormulaGeneratorProcessor);
  `;

  // ---------- UI schema ----------
  const FORMULAS = [
    { id:'fm', title:'FM-синус', tag:'FM', desc:'sin(2π f_c t + I sin(2π f_m t))',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.15},
        {k:'fc', name:'f_c (Hz)', min:20, max:2000, step:1, value:220},
        {k:'fm', name:'f_m (Hz)', min:0.1, max:60, step:0.1, value:2.0},
        {k:'I', name:'Index I', min:0, max:20, step:0.01, value:3.0},
      ]},
    { id:'am', title:'AM / биения', tag:'AM', desc:'sin(2π f1 t)·sin(2π f2 t)',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.15},
        {k:'f1', name:'f1 (Hz)', min:20, max:2000, step:1, value:220},
        {k:'f2', name:'f2 (Hz)', min:20, max:2000, step:1, value:221},
      ]},
    { id:'logistic', title:'Логистическое отображение', tag:'Chaos', desc:'xₙ₊₁ = r xₙ(1−xₙ)',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'base', name:'Base f (Hz)', min:20, max:800, step:1, value:110},
        {k:'depth', name:'Depth (Hz)', min:0, max:1200, step:1, value:330},
        {k:'r', name:'r', min:2.8, max:4.0, step:0.0001, value:3.86},
        {k:'lfoHz', name:'Update rate (Hz)', min:1, max:400, step:1, value:40},
      ]},
    { id:'gliss', title:'Экспоненциальный глиссандо', tag:'Gliss', desc:'f(t)=f0·e^{k t}',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'f0', name:'f0 (Hz)', min:10, max:400, step:1, value:55},
        {k:'k', name:'k', min:-2.0, max:2.0, step:0.001, value:0.15},
      ]},
    { id:'additive', title:'Сумма гармоник', tag:'Additive', desc:'Σ aₙ(t) sin(2π n f t)',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'fund', name:'Fund (Hz)', min:20, max:500, step:1, value:110},
        {k:'N', name:'Harmonics N', min:1, max:40, step:1, value:12},
        {k:'move', name:'Move (Hz)', min:0.01, max:5, step:0.01, value:0.35},
      ]},
    { id:'pm', title:'Фазовая модуляция', tag:'PM', desc:'sin(2π f t + 5·sin(sin(2π f2 t)))',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'f', name:'f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'f2pm', name:'f2 (Hz)', min:0.1, max:40, step:0.1, value:3},
      ]},
    { id:'beats', title:'Два синуса (биения)', tag:'Beats', desc:'sin(2π f t)+sin(2π(f+Δf)t)',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'fbeat', name:'f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'df', name:'Δf (Hz)', min:0, max:20, step:0.01, value:0.8},
      ]},
    { id:'dist', title:'Нелинейная сатурация', tag:'tanh', desc:'tanh(α·sin(2π f t))',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'fd', name:'f (Hz)', min:20, max:2000, step:1, value:110},
        {k:'alpha', name:'α', min:0, max:10, step:0.01, value:3.0},
      ]},
    { id:'quasi', title:'Квазислучайный LFO', tag:'Quasi', desc:'f(t)=fq + Aq·sin(sin(sin(w·t)))',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'fq', name:'Base f (Hz)', min:20, max:500, step:1, value:120},
        {k:'Aq', name:'Depth (Hz)', min:0, max:1200, step:1, value:220},
        {k:'wq', name:'w', min:0.05, max:6, step:0.01, value:0.8},
      ]},
    { id:'lorenz', title:'Аттрактор Лоренца', tag:'Lorenz', desc:'Lorenz ODE mapped to freq/amp',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'sigma', name:'σ', min:0, max:30, step:0.01, value:10},
        {k:'rho', name:'ρ', min:0, max:60, step:0.01, value:28},
        {k:'beta', name:'β', min:0.1, max:10, step:0.0001, value:2.6667},
        {k:'lBase', name:'Base f (Hz)', min:20, max:400, step:1, value:120},
        {k:'lFreqScale', name:'Freq scale', min:0, max:200, step:0.1, value:40},
        {k:'lAmp', name:'Amp scale', min:0, max:1, step:0.001, value:0.25},
      ]},
    { id:'karplus', title:'Karplus–Strong (струна)', tag:'KS', desc:'noise-in-delay + averaging + damping',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.14},
        {k:'ksFreq', name:'Freq (Hz)', min:40, max:880, step:1, value:110},
        {k:'ksDamp', name:'Damping', min:0.90, max:0.9999, step:0.0001, value:0.985},
        {k:'ksBright', name:'Brightness', min:0, max:1, step:0.001, value:0.5},
      ]},
    { id:'bitcrush', title:'Bitcrusher / Downsample', tag:'LoFi', desc:'bit depth + sample hold',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.12},
        {k:'bcFreq', name:'Input f (Hz)', min:20, max:2000, step:1, value:220},
        {k:'bcBits', name:'Bits', min:1, max:16, step:1, value:6},
        {k:'bcDown', name:'Downsample', min:1, max:64, step:1, value:8},
      ]},
    { id:'noiselp', title:'Noise → Low-pass', tag:'Noise', desc:'white noise → 1-pole LP',
      sliders:[
        {k:'gain', name:'Gain', min:0, max:1, step:0.001, value:0.10},
        {k:'nCut', name:'Cutoff (Hz)', min:20, max:18000, step:1, value:800},
      ]},
  ];

  // ---------- DOM helpers ----------
  const $ = (s) => document.querySelector(s);
  const formulasRoot = $('#formulas');
  const PRESET_KEY = 'formula_audio_lab_preset_v2';

  function fmt(v){
    v = Number(v);
    if (Math.abs(v) >= 100) return String(Math.round(v));
    if (Math.abs(v) >= 10) return v.toFixed(2);
    return v.toFixed(3);
  }

  // base64url helpers (UTF-8 safe)
  function b64urlEncode(str){
    const bytes = new TextEncoder().encode(str);
    let bin = '';
    for (const b of bytes) bin += String.fromCharCode(b);
    return btoa(bin).replace(/\+/g,'-').replace(/\//g,'_').replace(/=+$/,'');
  }
  function b64urlDecode(b64u){
    const b64 = b64u.replace(/-/g,'+').replace(/_/g,'/');
    const pad = b64.length % 4 ? '='.repeat(4 - (b64.length % 4)) : '';
    const bin = atob(b64 + pad);
    const bytes = new Uint8Array(bin.length);
    for (let i=0;i<bin.length;i++) bytes[i] = bin.charCodeAt(i);
    return new TextDecoder().decode(bytes);
  }

  // ---------- UI build ----------
  function makeFormulaUI(f){
    const wrap = document.createElement('div');
    wrap.className = 'formula';

    wrap.innerHTML = `
      <div class="fhead">
        <div>
          <h3>
            <input type="checkbox" id="en_${f.id}">
            ${f.title}
          </h3>
          <div class="small">${f.desc}</div>
        </div>
        <div class="factions">
          <span class="tag">${f.tag}</span>
          <button class="collapseBtn" id="col_${f.id}" type="button">Свернуть</button>
        </div>
      </div>

      <div class="fbody" id="body_${f.id}">
        <div id="sl_${f.id}"></div>
        <div class="sep"></div>
        <div class="row">
          <button id="reset_${f.id}" disabled>Reset state</button>
        </div>
      </div>
    `;
    formulasRoot.appendChild(wrap);

    const slidersHost = wrap.querySelector(`#sl_${f.id}`);
    for (const s of f.sliders){
      const line = document.createElement('div');
      line.className = 'ctrl';
      line.innerHTML = `
        <label for="${f.id}_${s.k}">${s.name}</label>
        <input id="${f.id}_${s.k}" type="range" min="${s.min}" max="${s.max}" step="${s.step}" value="${s.value}">
        <div class="small" id="${f.id}_${s.k}_v">${fmt(Number(s.value))}</div>
      `;
      slidersHost.appendChild(line);
    }
  }
  for (const f of FORMULAS) makeFormulaUI(f);

  // ---------- State serialization ----------
  function readStateFromUI(){
    const formulas = {};
    for (const f of FORMULAS){
      const enabled = !!$(`#en_${f.id}`).checked;
      const collapsed = $(`#body_${f.id}`).classList.contains('collapsed');
      const params = {};
      for (const s of f.sliders) params[s.k] = Number($(`#${f.id}_${s.k}`).value);
      formulas[f.id] = { enabled, collapsed, params };
    }
    const fx = {
      panelOpen: $('#effectsPanel').classList.contains('open'),
      filterOn: $('#fxFilterOn').checked,
      filterType: $('#fxFilterType').value,
      filterFreq: Number($('#fxFilterFreq').value),
      filterQ: Number($('#fxFilterQ').value),
      chorusOn: $('#fxChorusOn').checked,
      chorusMode: $('#fxChorusMode').value,
      chorusRate: Number($('#fxChorusRate').value),
      chorusDepth: Number($('#fxChorusDepth').value),
      chorusMix: Number($('#fxChorusMix').value),
      chorusFb: Number($('#fxChorusFb').value),
      reverbOn: $('#fxReverbOn').checked,
      reverbDecay: Number($('#fxReverbDecay').value),
      reverbMix: Number($('#fxReverbMix').value),
      limiterOn: $('#fxLimiterOn').checked,
      limiterThr: Number($('#fxLimiterThr').value),
      limiterRel: Number($('#fxLimiterRel').value),
    };
    const scopeCollapsed = $('#scopeWrap').classList.contains('scopeCollapsed');
    return { v: 2, masterGain: Number($('#masterGain').value), fx, formulas, scopeCollapsed };
  }

  function applyStateToUI(state){
    if (!state || typeof state !== 'object') return;

    if (typeof state.masterGain === 'number'){
      $('#masterGain').value = String(state.masterGain);
      $('#masterGainVal').textContent = state.masterGain.toFixed(3);
    }

    if (state.scopeCollapsed !== undefined){
      setScopeCollapsed(!!state.scopeCollapsed);
    }

    const fx = state.fx || {};
    const setVal = (id, val) => { if (val !== undefined) $(id).value = String(val); };
    const setChk = (id, val) => { if (val !== undefined) $(id).checked = !!val; };

    setChk('#fxFilterOn', fx.filterOn); setVal('#fxFilterType', fx.filterType);
    setVal('#fxFilterFreq', fx.filterFreq); setVal('#fxFilterQ', fx.filterQ);

    setChk('#fxChorusOn', fx.chorusOn); setVal('#fxChorusMode', fx.chorusMode);
    setVal('#fxChorusRate', fx.chorusRate); setVal('#fxChorusDepth', fx.chorusDepth);
    setVal('#fxChorusMix', fx.chorusMix); setVal('#fxChorusFb', fx.chorusFb);

    setChk('#fxReverbOn', fx.reverbOn); setVal('#fxReverbDecay', fx.reverbDecay);
    setVal('#fxReverbMix', fx.reverbMix);

    setChk('#fxLimiterOn', fx.limiterOn); setVal('#fxLimiterThr', fx.limiterThr);
    setVal('#fxLimiterRel', fx.limiterRel);

    const open = !!fx.panelOpen;
    $('#effectsPanel').classList.toggle('open', open);
    $('#effectsBtn').textContent = open ? 'Effects ▴' : 'Effects ▾';

    $('#fxFilterFreqVal').textContent = $('#fxFilterFreq').value;
    $('#fxFilterQVal').textContent = Number($('#fxFilterQ').value).toFixed(1);
    $('#fxChorusRateVal').textContent = Number($('#fxChorusRate').value).toFixed(2);
    $('#fxChorusDepthVal').textContent = Number($('#fxChorusDepth').value).toFixed(1);
    $('#fxChorusMixVal').textContent = Number($('#fxChorusMix').value).toFixed(2);
    $('#fxChorusFbVal').textContent = Number($('#fxChorusFb').value).toFixed(2);
    $('#fxReverbDecayVal').textContent = Number($('#fxReverbDecay').value).toFixed(1);
    $('#fxReverbMixVal').textContent = Number($('#fxReverbMix').value).toFixed(2);
    $('#fxLimiterThrVal').textContent = Number($('#fxLimiterThr').value).toFixed(1);
    $('#fxLimiterRelVal').textContent = Number($('#fxLimiterRel').value).toFixed(2);

    const formulas = state.formulas || {};
    for (const f of FORMULAS){
      const st = formulas[f.id];
      if (!st) continue;

      $(`#en_${f.id}`).checked = !!st.enabled;

      const body = $(`#body_${f.id}`);
      const colBtn = $(`#col_${f.id}`);
      const collapsed = !!st.collapsed;
      body.classList.toggle('collapsed', collapsed);
      colBtn.textContent = collapsed ? 'Развернуть' : 'Свернуть';

      const params = st.params || {};
      for (const s of f.sliders){
        if (params[s.k] === undefined) continue;
        const el = $(`#${f.id}_${s.k}`);
        el.value = String(params[s.k]);
        $(`#${f.id}_${s.k}_v`).textContent = fmt(params[s.k]);
      }
    }
  }

  function loadStateFromURL(){
    const m = location.hash.match(/#s=([A-Za-z0-9\-_]+)/);
    if (!m) return null;
    try {
      const json = b64urlDecode(m[1]);
      return JSON.parse(json);
    } catch {
      return null;
    }
  }
  function writeStateToURL(state){
    const json = JSON.stringify(state);
    const token = b64urlEncode(json);
    history.replaceState(null, '', `#s=${token}`);
    return location.href;
  }

  // ---------- Audio graph ----------
  let ctx = null;
  let analyser = null;

  let mixBus = null;
  let masterGain = null;

  // FX
  let fxInput = null;
  let filterNode = null;

  let chorusDelay = null;
  let chorusLFO = null;
  let chorusLFOGain = null;
  let chorusDry = null;
  let chorusWet = null;
  let chorusFb = null;

  let reverbConv = null;
  let reverbDry = null;
  let reverbWet = null;

  let limiter = null;

  // MediaRecorder (mobile-friendly)
  let mediaDest = null;
  let mediaRecorder = null;
  let mediaChunks = [];
  let downloadUrl = null;
  let scopeRAF = null;

  const nodes = new Map(); // id -> {aw, g, params}

  function buildWorkletURL(){
    const blob = new Blob([workletCode], {type:'application/javascript'});
    return URL.createObjectURL(blob);
  }

  function makeImpulseResponse(ctx, seconds, decay){
    const sr = ctx.sampleRate;
    const len = Math.max(1, Math.floor(sr * seconds));
    const buf = ctx.createBuffer(2, len, sr);
    for (let ch=0; ch<2; ch++){
      const data = buf.getChannelData(ch);
      for (let i=0; i<len; i++){
        const t = i / sr;
        const env = Math.exp(-t / Math.max(1e-3, decay));
        data[i] = (Math.random()*2 - 1) * env;
      }
    }
    return buf;
  }

  function setFXEnabled(){
    if (!ctx) return;

    const filterOn = $('#fxFilterOn').checked;
    const chorusOn = $('#fxChorusOn').checked;
    const reverbOn = $('#fxReverbOn').checked;
    const limiterOn = $('#fxLimiterOn').checked;

    // disconnect known nodes
    fxInput.disconnect();
    filterNode.disconnect();

    chorusDry.disconnect(); chorusWet.disconnect();
    chorusDelay.disconnect(); chorusFb.disconnect();

    reverbDry.disconnect(); reverbWet.disconnect(); reverbConv.disconnect();

    limiter.disconnect();
    masterGain.disconnect();
    analyser.disconnect();

    // end
    analyser.connect(ctx.destination);

    let node = fxInput;

    if (filterOn) { node.connect(filterNode); node = filterNode; }

    if (chorusOn) {
      node.connect(chorusDry);
      node.connect(chorusDelay);

      chorusDelay.connect(chorusFb);
      chorusFb.connect(chorusDelay);

      chorusDelay.connect(chorusWet);

      const chorusSum = ctx.createGain();
      chorusDry.connect(chorusSum);
      chorusWet.connect(chorusSum);
      node = chorusSum;
    }

    if (reverbOn) {
      node.connect(reverbDry);
      node.connect(reverbConv);
      reverbConv.connect(reverbWet);

      const revSum = ctx.createGain();
      reverbDry.connect(revSum);
      reverbWet.connect(revSum);
      node = revSum;
    }

    if (limiterOn) { node.connect(limiter); node = limiter; }

    // master -> analyser -> speakers
    node.connect(masterGain);
    masterGain.connect(analyser);
  }

  function updateFXParams(){
    if (!ctx) return;

    filterNode.type = $('#fxFilterType').value;
    const ff = Number($('#fxFilterFreq').value);
    const fq = Number($('#fxFilterQ').value);
    filterNode.frequency.setValueAtTime(ff, ctx.currentTime);
    filterNode.Q.setValueAtTime(fq, ctx.currentTime);
    $('#fxFilterFreqVal').textContent = String(ff);
    $('#fxFilterQVal').textContent = fq.toFixed(1);

    const mode = $('#fxChorusMode').value;
    const rate = Number($('#fxChorusRate').value);
    const depthMs = Number($('#fxChorusDepth').value);
    const mix = Number($('#fxChorusMix').value);
    const fb = Number($('#fxChorusFb').value);

    const baseMs = (mode === 'flanger') ? 2.0 : 12.0;
    chorusDelay.delayTime.setValueAtTime(baseMs / 1000, ctx.currentTime);
    chorusLFO.frequency.setValueAtTime(rate, ctx.currentTime);
    chorusLFOGain.gain.setValueAtTime(depthMs / 1000, ctx.currentTime);
    chorusDry.gain.setValueAtTime(1 - mix, ctx.currentTime);
    chorusWet.gain.setValueAtTime(mix, ctx.currentTime);
    chorusFb.gain.setValueAtTime(fb, ctx.currentTime);

    $('#fxChorusRateVal').textContent = rate.toFixed(2);
    $('#fxChorusDepthVal').textContent = depthMs.toFixed(1);
    $('#fxChorusMixVal').textContent = mix.toFixed(2);
    $('#fxChorusFbVal').textContent = fb.toFixed(2);

    const decay = Number($('#fxReverbDecay').value);
    const rMix = Number($('#fxReverbMix').value);
    $('#fxReverbDecayVal').textContent = decay.toFixed(1);
    $('#fxReverbMixVal').textContent = prove2(rMix);
    reverbDry.gain.setValueAtTime(1 - rMix, ctx.currentTime);
    reverbWet.gain.setValueAtTime(rMix, ctx.currentTime);

    const seconds = Math.min(6.0, Math.max(0.3, decay * 1.4));
    reverbConv.buffer = makeImpulseResponse(ctx, seconds, decay);

    const thr = Number($('#fxLimiterThr').value);
    const rel = Number($('#fxLimiterRel').value);
    $('#fxLimiterThrVal').textContent = thr.toFixed(1);
    $('#fxLimiterRelVal').textContent = rel.toFixed(2);

    limiter.threshold.setValueAtTime(thr, ctx.currentTime);
    limiter.ratio.setValueAtTime(20, ctx.currentTime);
    limiter.attack.setValueAtTime(0.003, ctx.currentTime);
    limiter.release.setValueAtTime(rel, ctx.currentTime);
    limiter.knee.setValueAtTime(0, ctx.currentTime);

    function prove2(x){ return Number(x).toFixed(2); }
  }

  async function startAudio(){
    if (ctx) return;

    ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });

    const url = buildWorkletURL();
    await ctx.audioWorklet.addModule(url);

    analyser = ctx.createAnalyser();
    analyser.fftSize = 2048;

    mixBus = ctx.createGain();
    mixBus.gain.value = 1;
    fxInput = mixBus;

    filterNode = ctx.createBiquadFilter();

    chorusDelay = ctx.createDelay(0.2);
    chorusDry = ctx.createGain();
    chorusWet = ctx.createGain();
    chorusFb = ctx.createGain();

    chorusLFO = ctx.createOscillator();
    chorusLFOGain = ctx.createGain();
    chorusLFO.connect(chorusLFOGain);
    chorusLFOGain.connect(chorusDelay.delayTime);
    chorusLFO.start();

    reverbConv = ctx.createConvolver();
    reverbDry = ctx.createGain();
    reverbWet = ctx.createGain();

    limiter = ctx.createDynamicsCompressor();

    masterGain = ctx.createGain();
    masterGain.gain.value = Number($('#masterGain').value);

    // destination for MediaRecorder (mobile-friendly)
    mediaDest = ctx.createMediaStreamDestination();
    masterGain.connect(mediaDest);

    setFXEnabled();
    updateFXParams();

    // Create generators
    for (const f of FORMULAS){
      const initParams = {};
      for (const s of f.sliders) initParams[s.k] = Number($(`#${f.id}_${s.k}`).value);

      const aw = new AudioWorkletNode(ctx, 'formula-generator', {
        numberOfInputs: 0,
        numberOfOutputs: 1,
        outputChannelCount: [1],
        processorOptions: { formula: f.id, params: initParams }
      });

      const g = ctx.createGain();
      g.gain.value = 0;
      aw.connect(g);
      g.connect(mixBus);

      nodes.set(f.id, { aw, g, params: initParams });
    }

    // Apply enabled states
    for (const f of FORMULAS){
      const on = $(`#en_${f.id}`).checked;
      const st = nodes.get(f.id);
      const now = ctx.currentTime;
      const gain = Number($(`#${f.id}_gain`).value);
      st.params.gain = gain;
      st.g.gain.setTargetAtTime(on ? gain : 0, now, 0.02);
      $(`#reset_${f.id}`).disabled = !on;
    }

    $('#status').textContent = 'Status: running';
    $('#stopBtn').disabled = false;
    $('#startBtn').disabled = true;
    $('#recBtn').disabled = false;

    startScopeAndMeter();
  }

  function stopAudio(){
    if (!ctx) return;

    // cleanup download URL
    cleanupDownloadUrl();

    // stop recording if active
    try {
      if (mediaRecorder && mediaRecorder.state === 'recording') mediaRecorder.stop();
    } catch {}

    cancelAnimationFrame(scopeRAF);
    scopeRAF = null;

    const now = ctx.currentTime;
    masterGain.gain.setTargetAtTime(0, now, 0.01);

    setTimeout(() => {
      try { chorusLFO.stop(); } catch {}
      ctx.close();
      ctx = null;
      nodes.clear();
      analyser = null;

      $('#status').textContent = 'Status: stopped';
      $('#stopBtn').disabled = true;
      $('#startBtn').disabled = false;
      $('#recBtn').disabled = true;
      $('#recBtn').textContent = 'Record WAV';

      $('#rmsVal').textContent = '—';
      $('#clipLamp').classList.remove('on');
    }, 80);
  }

  // ---------- Scope + meter (no “Scope:” pill) ----------
  const canvas = $('#scope');
  const c2d = canvas.getContext('2d');
  let scopeAutoGain = 1.0;
  let clipUntil = 0;

  function resizeCanvas(){
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = Math.max(1, Math.floor(rect.width * dpr));
    canvas.height = Math.max(1, Math.floor(rect.height * dpr));
  }
  window.addEventListener('resize', resizeCanvas);

  function startScopeAndMeter(){
    resizeCanvas();
    const buf = new Uint8Array(analyser.fftSize);

    const draw = () => {
      scopeRAF = requestAnimationFrame(draw);
      if (!analyser) return;

      analyser.getByteTimeDomainData(buf);

      let peak = 1e-4;
      let sumSq = 0;

      for (let i=0;i<buf.length;i++){
        const v = (buf[i] - 128) / 128;
        const a = Math.abs(v);
        if (a > peak) peak = a;
        sumSq += v*v;
      }

      const rms = Math.sqrt(sumSq / buf.length);
      const rmsDb = 20 * Math.log10(Math.max(1e-9, rms));
      $('#rmsVal').textContent = `${rmsDb.toFixed(1)} dBFS`;

      const nowMs = performance.now();
      if (peak >= 0.98) clipUntil = nowMs + 300;
      $('#clipLamp').classList.toggle('on', nowMs < clipUntil);

      // auto Y scale
      let target = 0.85 / peak;
      target = Math.max(0.25, Math.min(12.0, target));
      scopeAutoGain += (target - scopeAutoGain) * 0.08;

      const w = canvas.width, h = canvas.height;
      c2d.fillStyle = '#060a0f';
      c2d.fillRect(0,0,w,h);

      // grid
      c2d.strokeStyle = '#122033';
      c2d.lineWidth = 1;
      c2d.beginPath();
      for (let i=1;i<10;i++){
        const x = (w*i)/10;
        c2d.moveTo(x,0); c2d.lineTo(x,h);
      }
      for (let i=1;i<5;i++){
        const y = (h*i)/5;
        c2d.moveTo(0,y); c2d.lineTo(w,y);
      }
      c2d.stroke();

      // waveform
      const mid = h/2;
      c2d.strokeStyle = '#8ab4ff';
      c2d.lineWidth = 2;
      c2d.beginPath();

      const gain = scopeAutoGain;
      for (let i=0;i<buf.length;i++){
        const v = (buf[i] - 128) / 128;
        const y = mid - v * (mid * 0.9) * gain;
        const x = (w * i) / (buf.length - 1);
        if (i===0) c2d.moveTo(x,y); else c2d.lineTo(x,y);
      }
      c2d.stroke();
    };

    draw();
  }

  // ---------- MediaRecorder helpers ----------
  function pickRecorderMimeType(){
    const candidates = [
      'audio/webm;codecs=opus',
      'audio/webm',
      'audio/ogg;codecs=opus',
      'audio/ogg',
    ];
    for (const t of candidates){
      if (window.MediaRecorder && MediaRecorder.isTypeSupported && MediaRecorder.isTypeSupported(t)) return t;
    }
    return ''; // let browser choose
  }

  function cleanupDownloadUrl(){
    if (downloadUrl){
      URL.revokeObjectURL(downloadUrl);
      downloadUrl = null;
    }
  }

  async function toggleRecording(){
    if (!ctx || !mediaDest){
      $('#status').textContent = 'Status: start audio first';
      return;
    }

    // START
    if (!mediaRecorder || mediaRecorder.state === 'inactive'){
      cleanupDownloadUrl();
      mediaChunks = [];

      const mimeType = pickRecorderMimeType();
      try {
        mediaRecorder = mimeType
          ? new MediaRecorder(mediaDest.stream, { mimeType })
          : new MediaRecorder(mediaDest.stream);

        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) mediaChunks.push(e.data);
        };

        mediaRecorder.onstart = () => {
          $('#recBtn').textContent = 'Stop Rec';
          $('#status').textContent = 'Status: recording…';
        };

        mediaRecorder.start(250); // timeslice to avoid huge memory spikes on mobile
      } catch (err){
        console.error(err);
        $('#status').textContent = 'Status: recorder init failed';
      }
      return;
    }

    // STOP
    if (mediaRecorder.state === 'recording'){
      const btn = $('#recBtn');
      btn.disabled = true;
      $('#status').textContent = 'Status: finalizing…';

      const stopped = new Promise((resolve) => {
        mediaRecorder.onstop = resolve;
      });

      mediaRecorder.stop();
      await stopped;

      btn.disabled = false;
      btn.textContent = 'Record WAV';

      const blob = new Blob(mediaChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
      downloadUrl = URL.createObjectURL(blob);

      // extension based on mimeType
      const ext = (mediaRecorder.mimeType || '').includes('ogg') ? 'ogg' : 'webm';
      const name = `formula-audio-${new Date().toISOString().replace(/[:.]/g,'-')}.${ext}`;

      // Android Chrome sometimes blocks auto-download after async stop.
      // So: try auto-click + show explicit "Download" link in status.
      const a = document.createElement('a');
      a.href = downloadUrl;
      a.download = name;
      a.rel = 'noopener';
      a.style.display = 'none';
      document.body.appendChild(a);
      a.click();
      a.remove();

      // Explicit link in status in case auto-download didn't work
      $('#status').innerHTML = `Status: ready — <a href="${downloadUrl}" download="${name}" style="color:#8ab4ff;">Download</a>`;

      return;
    }
  }

  // ---------- Scope collapse ----------
  const scopeWrap = $('#scopeWrap');
  const scopeToggleBtn = $('#scopeToggleBtn');

  function setScopeCollapsed(collapsed){
    scopeWrap.classList.toggle('scopeCollapsed', collapsed);
    scopeToggleBtn.textContent = collapsed ? 'Scope ▸' : 'Scope ▾';
    // if we collapsed, canvas can be 0 height; on expand, resize so waveform renders crisply
    if (!collapsed) setTimeout(resizeCanvas, 0);
  }

  // Default: collapsed on narrow screens
  const defaultCollapse = window.matchMedia && window.matchMedia('(max-width: 600px)').matches;
  setScopeCollapsed(defaultCollapse);

  scopeToggleBtn.addEventListener('click', () => {
    setScopeCollapsed(!scopeWrap.classList.contains('scopeCollapsed'));
  });

  // ---------- Buttons ----------
  $('#startBtn').addEventListener('click', startAudio);
  $('#stopBtn').addEventListener('click', stopAudio);
  $('#recBtn').addEventListener('click', toggleRecording);

  $('#masterGain').addEventListener('input', (e)=>{
    const v = Number(e.target.value);
    $('#masterGainVal').textContent = v.toFixed(3);
    if (masterGain) masterGain.gain.value = v;
  });

  // Effects panel toggle
  const effectsPanel = $('#effectsPanel');
  $('#effectsBtn').addEventListener('click', () => {
    const open = !effectsPanel.classList.contains('open');
    effectsPanel.classList.toggle('open', open);
    $('#effectsBtn').textContent = open ? 'Effects ▴' : 'Effects ▾';
    resizeCanvas();
  });

  // FX controls
  const fxRoutingInputs = ['fxFilterOn','fxChorusOn','fxReverbOn','fxLimiterOn'];
  for (const id of fxRoutingInputs){
    $('#'+id).addEventListener('change', () => {
      if (!ctx) return;
      setFXEnabled();
      updateFXParams();
    });
  }
  const fxParamInputs = [
    'fxFilterType','fxFilterFreq','fxFilterQ',
    'fxChorusMode','fxChorusRate','fxChorusDepth','fxChorusMix','fxChorusFb',
    'fxReverbDecay','fxReverbMix',
    'fxLimiterThr','fxLimiterRel'
  ];
  for (const id of fxParamInputs){
    $('#'+id).addEventListener('input', () => {
      if (!ctx) return;
      updateFXParams();
    });
  }

  // ---------- Presets + Share ----------
  $('#savePresetBtn').addEventListener('click', () => {
    const state = readStateFromUI();
    localStorage.setItem(PRESET_KEY, JSON.stringify(state));
    $('#status').textContent = 'Status: preset saved';
  });

  $('#loadPresetBtn').addEventListener('click', () => {
    const raw = localStorage.getItem(PRESET_KEY);
    if (!raw) { $('#status').textContent = 'Status: no preset'; return; }
    try {
      const state = JSON.parse(raw);
      applyStateToUI(state);
      if (ctx) applyUIToAudioLive();
      $('#status').textContent = 'Status: preset loaded';
    } catch {
      $('#status').textContent = 'Status: preset parse error';
    }
  });

  $('#shareBtn').addEventListener('click', async () => {
    const state = readStateFromUI();
    const url = writeStateToURL(state);
    try {
      await navigator.clipboard.writeText(url);
      $('#status').textContent = 'Status: share link copied';
    } catch {
      $('#status').textContent = 'Status: share link in URL';
    }
  });

  function writeStateToURL(state){
    const json = JSON.stringify(state);
    const token = b64urlEncode(json);
    const newHash = `#s=${token}`;
    history.replaceState(null, '', newHash);
    return location.href;
  }

  function loadStateFromURL(){
    const m = location.hash.match(/#s=([A-Za-z0-9\-_]+)/);
    if (!m) return null;
    try {
      const json = b64urlDecode(m[1]);
      return JSON.parse(json);
    } catch {
      return null;
    }
  }

  // Apply URL state on load
  const urlState = loadStateFromURL();
  if (urlState) applyStateToUI(urlState);

  // ---------- Live apply after preset/url changes ----------
  function applyUIToAudioLive(){
    if (masterGain) masterGain.gain.value = Number($('#masterGain').value);

    setFXEnabled();
    updateFXParams();

    for (const f of FORMULAS){
      const st = nodes.get(f.id);
      if (!st) continue;

      const enabled = $(`#en_${f.id}`).checked;
      const now = ctx.currentTime;

      for (const s of f.sliders){
        const v = Number($(`#${f.id}_${s.k}`).value);
        st.params[s.k] = v;
        st.aw.port.postMessage({type:'set', params: {[s.k]: v}});
      }

      const gain = Number($(`#${f.id}_gain`).value);
      st.g.gain.setTargetAtTime(enabled ? gain : 0, now, 0.02);
      $(`#reset_${f.id}`).disabled = !enabled;
    }
  }

  // ---------- Formula control wiring ----------
  for (const f of FORMULAS){
    const en = document.getElementById(`en_${f.id}`);
    const resetBtn = document.getElementById(`reset_${f.id}`);
    const body = document.getElementById(`body_${f.id}`);
    const col = document.getElementById(`col_${f.id}`);

    col.addEventListener('click', () => {
      const collapsed = !body.classList.contains('collapsed');
      body.classList.toggle('collapsed', collapsed);
      col.textContent = collapsed ? 'Развернуть' : 'Свернуть';
    });

    en.addEventListener('change', () => {
      if (!ctx) { en.checked = false; return; }
      const st = nodes.get(f.id);
      if (!st) return;

      const on = en.checked;
      const now = ctx.currentTime;
      const gain = Number(document.getElementById(`${f.id}_gain`).value);
      st.g.gain.setTargetAtTime(on ? gain : 0, now, 0.02);
      resetBtn.disabled = !on;
    });

    resetBtn.addEventListener('click', () => {
      if (!ctx) return;
      nodes.get(f.id)?.aw.port.postMessage({type:'reset'});
    });

    for (const s of f.sliders){
      const slider = document.getElementById(`${f.id}_${s.k}`);
      const val = document.getElementById(`${f.id}_${s.k}_v`);

      slider.addEventListener('input', () => {
        const v = Number(slider.value);
        val.textContent = fmt(v);

        if (!ctx) return;
        const st = nodes.get(f.id);
        if (!st) return;

        st.params[s.k] = v;
        st.aw.port.postMessage({type:'set', params: {[s.k]: v}});

        if (s.k === 'gain'){
          const now = ctx.currentTime;
          if (en.checked) st.g.gain.setTargetAtTime(v, now, 0.02);
        }
      });
    }
  }

  // Initialize FX labels
  $('#fxFilterFreqVal').textContent = $('#fxFilterFreq').value;
  $('#fxFilterQVal').textContent = Number($('#fxFilterQ').value).toFixed(1);
  $('#fxChorusRateVal').textContent = Number($('#fxChorusRate').value).toFixed(2);
  $('#fxChorusDepthVal').textContent = Number($('#fxChorusDepth').value).toFixed(1);
  $('#fxChorusMixVal').textContent = Number($('#fxChorusMix').value).toFixed(2);
  $('#fxChorusFbVal').textContent = Number($('#fxChorusFb').value).toFixed(2);
  $('#fxReverbDecayVal').textContent = Number($('#fxReverbDecay').value).toFixed(1);
  $('#fxReverbMixVal').textContent = Number($('#fxReverbMix').value).toFixed(2);
  $('#fxLimiterThrVal').textContent = Number($('#fxLimiterThr').value).toFixed(1);
  $('#fxLimiterRelVal').textContent = Number($('#fxLimiterRel').value).toFixed(2);

})();
</script>

</body>
</html>
